[{"path":"index.html","id":"введение","chapter":"Введение","heading":"Введение","text":"","code":""},{"path":"index.html","id":"предисловие","chapter":"Введение","heading":"Предисловие","text":"Аудитория telegram ежедневно растёт с геометрической прогрессией, этому способствует удобство мессенджера, наличие каналов, чатов, и конечно возможность создавать ботов.Боты могут использоваться в совершенно разных целях, от автоматизации коммуникации с вашими клиентами до управления вашими собственными задачами.По сути через бота можно используя telegram выполнять любые операции: отправлять, либо запрашивать данные, запускать задачи на сервере, собирать информацию в базу данных, отправлять электронные письма и так далее.Этот веб учебник поможет вам освоить процесс разработки telegram ботов используя язык программирования R.Материал изложен последовательно, от простого к сложному.Первая глава посвящена отправке сообщений из R в Telegram, а в последней главе мы разработаем полноценного бота, который поддерживает последовательный логический диалог с пользователем.В ходе всего учебника основным R пакетом который мы будем использовать будет telegram.bot.Каждая глава заканчивается небольшим заданием и тестом, для того, что бы вы могли проверить насколько хорошо был воспринят материал.","code":""},{"path":"index.html","id":"навыки-необходимые-для-прохождения-учебника","chapter":"Введение","heading":"Навыки необходимые для прохождения учебника","text":"Тему построения ботов я отношу к продвинутым навыкам, не зависимо от выбранного язка программирования. Поэтому в этой книге не рассматриваются базовые вводные темы по основам языка R.Для чтения и понимания книги вам необходимо обладать следующими навыками на языке программирования R:Понимать базовые програмные конструкции, т.е. циклы и условные ветвления.Понимать что такое функция.Разбираться в основных структурах данных языка.Уметь работать со строками.Владеть основами манипуляции данных с помощью пакета dplyr.Иметь поверхностное понимание о том, что такое API.Перечисленные выше темы выходят за рамки этой книги, но подробно рассматриваются в онлайн академии “Язык R для интернет-маркетинга”.","code":""},{"path":"index.html","id":"об-авторе","chapter":"Введение","heading":"Об авторе","text":"Меня зовут Алексей Селезнёв, уже более 10 лет я являюсь практикующим аналитиком. С 2016 года возглавляю отдел аналитики в агентстве интернет - маркетинга Netpeak.Являюсь автором курсов по языку R: “Язык R для интернет - маркетинга” и “Язык R для пользователей Excel”.С 2015 года активно пишу статьи по аналитике, на момент написания этих строк мной опубликовано уже более 120 статей в различных интернет изданиях. Веду собственный блог, хотя он по большей части он является агрегатором моих статей из различных источников.В 2018 году завёл telegram канал R4marketing, в котором делюсь полезными, русскоязычными материалами по языку R: ссылки на статьи, доклады, вебинары, заметки по применению языка R.В 2020 году запустил YouTube канал, в котором делюсь видео уроками по языку R И аналитике в целом.","code":""},{"path":"index.html","id":"видео-введение-в-курс","chapter":"Введение","heading":"Видео введение в курс","text":"","code":""},{"path":"index.html","id":"правки-и-предложения","chapter":"Введение","heading":"Правки и предложения","text":"Перед публикацией учебника я несколько раз перечитал его, но всё же некоторые помарки в разметке, грамматические или синтаксические ошибки могли ускользнуть от моего внимания.К тому же, возможно у вас есть идеи о том, какой информации в учебнике нехватает, или о том, что какая часть учебника потеряла свою актуальность.По таким вопросам прошу писать мне либо на почту, либо напрямую в Telegram.Email: selesnow@gmail.com \nTelegram: AlexeySeleznev","code":""},{"path":"index.html","id":"поддержать-проект","chapter":"Введение","heading":"Поддержать проект","text":"Учебник, и все необходимые материалы находятся в открытом доступе, но при желании вы можете поддержать этот проект любой произвольной сумме перейдя по этой ссылке.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","text":"В этой главе мы разберёмся как создать телеграм бота, и отправлять с его помощью уведомления в telegram.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"создание-телеграм-бота","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.1 Создание телеграм бота","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"видео-урок-о-создании-telegram-бота-через-botfather","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.1.1 Видео урок о создании telegram бота через BotFather","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"конспект-о-создании-telegram-бота-через-botfather","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.1.2 Конспект о создании telegram бота через BotFather","text":"Для начала нам необходимо создать бота. Делается это с помощью специального бота BotFather, переходим по ссылке и пишем боту /start.После чего вы получите сообщение со списком команд:Для создания нового бота отправляем команду /newbot.BotFather попросит вас ввести имя и логин бота.Имя вы можете ввести произвольное, а логин должен заканчиваться на bot.Если вы всё сделали правильно, то получите следующее сообщение:Далее вам понадобится полученный API токен, в моём примере это 123456789:abcdefghijklmnopqrstuvwxyz.Более подробно о возможностях BotFather можно узнать из этой публикации. На этом шаге подготовительные работы по созданию бота завершены.","code":"I can help you create and manage Telegram bots. If you're new to the Bot API, please see the manual (https://core.telegram.org/bots).\n\nYou can control me by sending these commands:\n\n/newbot - create a new bot\n/mybots - edit your bots [beta]\n\nEdit Bots\n/setname - change a bot's name\n/setdescription - change bot description\n/setabouttext - change bot about info\n/setuserpic - change bot profile photo\n/setcommands - change the list of commands\n/deletebot - delete a bot\n\nBot Settings\n/token - generate authorization token\n/revoke - revoke bot access token\n/setinline - toggle inline mode (https://core.telegram.org/bots/inline)\n/setinlinegeo - toggle inline location requests (https://core.telegram.org/bots/inline#location-based-results)\n/setinlinefeedback - change inline feedback (https://core.telegram.org/bots/inline#collecting-feedback) settings\n/setjoingroups - can your bot be added to groups?\n/setprivacy - toggle privacy mode (https://core.telegram.org/bots#privacy-mode) in groups\n\nGames\n/mygames - edit your games (https://core.telegram.org/bots/games) [beta]\n/newgame - create a new game (https://core.telegram.org/bots/games)\n/listgames - get a list of your games\n/editgame - edit a game\n/deletegame - delete an existing gameBotFather, [25.07.20 09:39]\nAlright, a new bot. How are we going to call it? Please choose a name for your bot.\n\nAlexey Seleznev, [25.07.20 09:40]\nMy Test Bot\n\nBotFather, [25.07.20 09:40]\nGood. Now let's choose a username for your bot. It must end in `bot`. Like this, for example: TetrisBot or tetris_bot.\n\nAlexey Seleznev, [25.07.20 09:40]\n@my_test_botDone! Congratulations on your new bot. You will find it at t.me/my_test_bot. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.\n\nUse this token to access the HTTP API:\n123456789:abcdefghijklmnopqrstuvwxyz\n\nFor a description of the Bot API, see this page: https://core.telegram.org/bots/api"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"установка-пакета-для-работы-с-телеграм-ботом-на-r","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.2 Установка пакета для работы с телеграм ботом на R","text":"Я предполагаю, что у вас уже установлен язык R, и среда разработки RStudio. Если это не так, то вы можете посмотреть данный видео урок о том, как их установить.Для работы с Telegram Bot API мы будем использовать R пакет telegram.bot.Установка пакетов в R осуществляется функцией install.packages(), поэтому для установки нужного нам пакета используйте команду install.packages(\"telegram.bot\").Более подробно узнать об установке различных пакетов можно из этого видео.После установки пакета его необходимо подключить:","code":"\nlibrary(telegram.bot)"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"отправка-сообщений-из-r-в-telegram","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.3 Отправка сообщений из R в Telegram","text":"Созданного вами бота можно найти в Telegram по заданному при создании логину, в моём случае это @my_test_bot.Отправьте боту любое сообщение, например “Привет бот”. На данный момент это нам надо для того, что бы получить id вашего с ботом чата.Теперь в R пишем следующий код.Изначально мы создаём экземпляр нашего бота функцией Bot(), в качестве аргумента в неё необходимо передать полученный ранее токен.Хранить токен в коде считается не лучшей практикой, поэтому вы можете хранить его в переменной среды, и считывать его из неё. По умолчанию в пакете telegram.bot реализована поддержка переменных среды следующего наименования: R_TELEGRAM_BOT_ИМЯ_ВАШЕГО_БОТА. Вместо ИМЯ_ВАШЕГО_БОТА подставьте имя которое вы задали при создании, в моём случае будет переменная R_TELEGRAM_BOT_My Test Bot.Создать переменную среды можно несколькими способами, я расскажу о наиболее универсальном и кроссплатформенном. Создайте в вашей домашней директории (узнать её можно с помощью команды path.expand(\"~\")) текстовый файл с названием .Renviron. Сделать это также можно с помощью команды file.edit(path.expand(file.path(\"~\", \".Renviron\"))).И добавьте в него следующую строку.Далее вы можете использовать сохранённый в переменной среды токен с помощью функции bot_token(), т.е. вот так:Метод getUpdates()позволяет нам получить обновления бота, т.е. сообщения которые были ему отправлены. Метод from_chat_id(), позволяет получить идентификатор чата, из которого было отправлено сообщение. Этот идентификатор нам нужен для отправки сообщений от бота.Помимо id чата из объекта полученного методом getUpdates() вы получаете и некоторую другую полезную информацию. Например, информацию о пользователе, отправившем сообщение.Итак, на данном этапе у нас уже есть всё, что необходимо для отправки сообщения от бота в телеграм. Воспользуемся методом sendMessage(), в который необходимо передать идентификатор чата, текст сообщения, и тип разметки текста сообщения. Тип разметки может быть Markdown или HTML и устанавливается аргументом parse_mode.Если вам необходимо отправить сообщение от бота не в чат, а в публичный канал, то в chat_id указывайте адрс вашего канала, например '@MyTGChannel'.При необходимости отправить сообщение в приватный канал, вам необходимо скопировать ссылку на любое сообщение данного канала, из ссылки получить его идентификатор, и к этому идентификатору добавить -100.Пример ссылки приватного канала: https://t./c/012345678/11Соответвенно, к id 012345678 вам необходимо добавить -100, в таком случае в chat_id надо указать -100012345678.Основы форматирования Markdown разметки:Жирный шрифт выделяется с помощью знака *:\nпример: *жирный шритф*\nрезультат: жирный шритф\nпример: *жирный шритф*результат: жирный шритфКурсив задаётся нижним подчёркиванием:\nпример: _курсив_\nрезультат: курсив\nпример: _курсив_результат: курсивМоноширинный шрифт, которым обычно выделяется программный код, задаётся с помощью апострофов:\nпример: `моноширинный шрифт`\nрезультат: моноширинный шрифт\nпример: `моноширинный шрифт`результат: моноширинный шрифтОсновы форматирования HTML разметки:В HTML вы заворачиваете часть текста, которую надо выделать, в теги, пример <тег>текст<\/тег>.<тег> - открывающий тег<\/тег> - закрывающий тегТеги HTML разметки<b> - жирный шрифт\nпример: <b>жирный шрифт<\/b>\nрезультат жирный шрифт\nпример: <b>жирный шрифт<\/b>результат жирный шрифт<> - курсив\nпример: <>курсив<\/>\nрезультат: курсив\nпример: <>курсив<\/>результат: курсив<code> - моноширинный шрифт\nпример: <code\\>моноширинный шрифт<\/code\\>\nрезультат: моноширинный шрифт\nпример: <code\\>моноширинный шрифт<\/code\\>результат: моноширинный шрифтПомимо текста вы можете отправлять и другой контент используя специальные методы:Т.е. например с помощью метода sendPhoto() вы можете отправить сохранённый в виде изображения график, который вы построили с помощью пакета ggplot2.Помимо отправки данных бот имеет и ряд других методов:deleteMessage() - Удалить сообщениеeditMessageText() - Редактирвать текст сообщенияeditMessageCaption() - Редактировать описание изображения, файла и т.д.forwardMessage() - Переслать сообщениеgetFile() - Подготовка файла к скачиваниюgetMe() - Получить информацию о ботеgetUpdates() - Получить список обновлений ботаgetUserProfilePhotos() - Получить аватар пользователяleaveChat() - Выйти из группыclean_updates() - Очистить очередь обновлений","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр бота\nbot <- Bot(token = \"123456789:abcdefghijklmnopqrstuvwxyz\")\n\n# Запрашиваем информацию о боте\nprint(bot$getMe())\n\n# Получаем обновления бота, т.е. список отправленных ему сообщений\nupdates <- bot$getUpdates()\n\n# Запрашиваем идентификатор чата\n# Примечание: перед запросом обновлений вы должны отправить боту сообщение\nchat_id <- updates[[1L]]$from_chat_id()R_TELEGRAM_BOT_ИМЯ_ВАШЕГО_БОТА=123456789:abcdefghijklmnopqrstuvwxyz\nbot <- Bot(token = bot_token(\"My Test Bot\"))\nupdates[[1L]]$message$from$id\n[1] 000000000\n\n$is_bot\n[1] FALSE\n\n$first_name\n[1] \"Alexey\"\n\n$last_name\n[1] \"Seleznev\"\n\n$username\n[1] \"AlexeySeleznev\"\n\n$language_code\n[1] \"ru\"\n# Отправка сообщения\nbot$sendMessage(chat_id,\n                text = \"Привет, *жирный текст* _курсив_\",\n                parse_mode = \"Markdown\"\n)\n# Отправить изображение\nbot$sendPhoto(chat_id,\n  photo = \"https://telegram.org/img/t_logo.png\"\n)\n\n# Отправка голосового сообщения\nbot$sendAudio(chat_id,\n  audio = \"http://www.largesound.com/ashborytour/sound/brobob.mp3\"\n)\n\n# Отправить документ\nbot$sendDocument(chat_id,\n  document = \"https://github.com/ebeneditos/telegram.bot/raw/gh-pages/docs/telegram.bot.pdf\"\n)\n\n# Отправить стикер\nbot$sendSticker(chat_id,\n  sticker = \"https://www.gstatic.com/webp/gallery/1.webp\"\n)\n\n# Отправить видео\nbot$sendVideo(chat_id,\n  video = \"http://techslides.com/demos/sample-videos/small.mp4\"\n)\n\n# Отправить gif анимацию\nbot$sendAnimation(chat_id,\n  animation = \"https://media.giphy.com/media/sIIhZliB2McAo/giphy.gif\"\n)\n\n# Отправить локацию\nbot$sendLocation(chat_id,\n  latitude = 51.521727,\n  longitude = -0.117255\n)\n\n# Имитация действия в чате\nbot$sendChatAction(chat_id,\n  action = \"typing\"\n)"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"как-отправить-в-telegram-таблицу","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.4 Как отправить в telegram таблицу","text":"К сожалению на момент написания книги telegram не поддерживает полноценные таблицы в HTML или Markdown, но вы можете иметировать подобие таблицы. Для этого воспользуйтесь кодом представленной ниже функции to_tg_table():С помощью этой функци вы можете преобразовать любой data.frame и отправить в telegram:У функции to_tg_table() есть несколько дополнительных аргументов:align - выравнивнивание столбцов, тектовая строка, каждая буква соответвует одному столбцу, пример 'llrrc':\nl - выравнивание по левой стороне\nr - выравнивание по правой стороне\nc - выравнивание по центру\nl - выравнивание по левой сторонеr - выравнивание по правой сторонеc - выравнивание по центруindents - количество пробелов для разделения столбцов.parse_mode - разметка сообщения, Markdown или HTML.Пример с выравниванием столбцов:","code":"\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringr)\n\n# функция для перевода data.frame в telegram таблицу \nto_tg_table <- function( table, align = NULL, indents = 3, parse_mode = 'Markdown' ) {\n  \n  # если выравнивание не задано то выравниваем по левому краю\n  if ( is.null(align) ) {\n    \n    col_num <- length(table)\n    align   <- str_c( rep('l', col_num), collapse = '' )\n  \n  }\n  \n  # проверяем правильно ли заданно выравнивание\n  if ( length(table) != nchar(align) ) {\n    \n    align <- NULL\n    \n  }\n  \n  # новое выравнивание столбцов \n  side <- sapply(1:nchar(align), \n         function(x) { \n           letter <- substr(align, x, x)\n           switch (letter,\n                   'l' = 'right',\n                   'r' = 'left',\n                   'c' = 'both',\n                   'left'\n           )\n  })\n  \n  # сохраняем имена\n  t_names      <- names(table)\n\n  # вычисляем ширину столбцов\n  names_length <- sapply(t_names, nchar) \n  value_length <- sapply(table, function(x) max(nchar(as.character(x))))\n  max_length   <- ifelse(value_length > names_length, value_length, names_length)\n  \n  # подгоняем размер имён столбцов под их ширину + указанное в indents к-во пробелов \n  t_names <- mapply(str_pad, \n                    string = t_names, \n                    width  = max_length + indents, \n                    side   = side)\n  \n  # объединяем названия столбцов\n  str_names <- str_c(t_names, collapse = '')\n  \n  # аргументы для фукнции str_pad\n  rules <- list(string = table, width = max_length + indents, side = side)\n\n  # поочереди переводим каждый столбец к нужному виду\n  t_str <-   pmap_df( rules, str_pad )%>%\n              unite(\"data\", everything(), remove = TRUE, sep = '') %>%\n              unlist(data) %>%\n              str_c(collapse = '\\n') \n  \n  # если таблица занимает более 4096 символов обрезаем её\n  if ( nchar(t_str) >= 4021 ) {\n    \n    warning('Таблица составляет более 4096 символов!')\n    t_str <- substr(t_str, 1, 4021)\n    \n  }\n  \n  # символы выделения блока кода согласно выбранной разметке\n  code_block <- switch(parse_mode, \n                       'Markdown' = c('```', '```'),\n                       'HTML' = c('<code>', '<\/code>'))\n           \n  # переводим в code\n  res <- str_c(code_block[1], str_names, t_str, code_block[2], sep = '\\n')\n  \n  return(res)\n}\n# преобразуем таблицу iris \ntg_table <- to_tg_table( head(iris, 15) )\n\n# отправляем таблицу в telegram\nbot$sendMessage(194336771, \n                tg_table,\n                \"Markdown\")\n# преобразуем таблицу iris \ntg_table <- to_tg_table( head(iris, 15), \n                         align = 'llccr')\n\n# отправляем таблицу в telegram\nbot$sendMessage(194336771, \n                tg_table,\n                \"Markdown\")"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"как-добавить-в-сообщение-emoji","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.5 Как добавить в сообщение Emoji","text":"Требования к телеграм ботам могут быть разные, в том числе заказчик может попросить вас добавить в сообщения бота какие то Emoji.Получить полный список доступных смайлов можно по этой ссылке.Таблица смайловИз таблицы нас интересует поле Unicode. Скопиройте код нужного вам смайла, и замените U+ на \\U000. Т.е. если вам необходимо отправить смайл, код котого в таблице U+1F601, то в коде на R вам необходимо добавить его в текст сообщения вот так - \\U0001F601.Пример:","code":"\nbot$sendMessage(chat_id, \n                'Сообщение со смайлом \\U0001F601 код которого в таблице U+1F601')"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"проверка-планировщика-задач-windows-и-отправка-уведомления-о-задачах-работа-которых-была-завершена-аварийно","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.6 Проверка планировщика задач Windows, и отправка уведомления о задачах, работа которых была завершена аварийно","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"видео-урок-о-разработке-бота-для-контроля-планировщика-заданий","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.6.1 Видео урок о разработке бота для контроля планировщика заданий","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"конспект-о-разработке-бота-для-контроля-планировщика-заданий","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.6.2 Конспект о разработке бота для контроля планировщика заданий","text":"Для работы с планировщиком заданий Windows вам необходимо установить пакет taskscheduleR, и для удобства работы с данными установим пакет dplyr.Далее с помощью функции taskscheduler_ls() мы запрашиваем информацию о задачах из нашего планировщика. С помощью функции filter() из пакета dplyr мы убираем из списка задач те, которые были успешно выполненны и имеют статус последнего результата 0, и те, которые ещё ни разу не запускались и имеют статус 267011, выключенные задачи, и задачи которые выполняются в данный момент.В объекте task у нас теперь список задач, работа которых завершилась ошибкой, этот список нам надо отправить в Telegram.Если рассмотреть каждую команду подробнее, то:filter() - фильтрует список задач, по описанным выше условиямselect() - оставляет в таблице только одно поле с названием задачunique() - убирает дубли названийunlist() - переводит выбранный столбец таблицы в векторpaste0() - соединяет названия задач в одну строку, и ставит в качестве разделителя знак перевода строки, т.е. \\n.Всё что нам остаётся - отправить этот результат в телеграм.Итак, на данный момент код бота выглядит вот так:При использовании приведённого выше примера подставьте в код токен вашего бота и ваш идентификатор чата.Вы можете добавлять условия фильтрации задач, например проверяя только те задачи, которые были созданны вами, исключая системные.Так же вы можете вынести различные настройки в отдельный файл конфигурации, и хранить в нём id чата и токен. Читать конфиг можно например с помощью пакета configr.","code":"\n# Установка пакетов\ninstall.packages(c('taskscheduleR', 'dplyr'))\n# Подключение пакетов\nlibrary(taskscheduleR)\nlibrary(dplyr)\n# запрашиваем список задач\ntask <- task <- taskscheduler_ls() %>%\n        filter(! `Last Result`  %in% c(\"0\", \"267011\") & \n               `Scheduled Task State` == \"Enabled\" & \n               Status != \"Running\") %>%\n        select(TaskName) %>%\n        unique() %>%\n        unlist() %>%\n        paste0(., collapse = \"\\n\")\nbot$sendMessage(chat_id,\n                text = task,\n                parse_mode = \"Markdown\"\n)\n# Подключение пакета\nlibrary(telegram.bot)\nlibrary(taskscheduleR)\nlibrary(dplyr)\n\n# инициализируем бота\nbot <- Bot(token = \"123456789:abcdefghijklmnopqrstuvwxyz\")\n\n# идентификатор чата\nchat_id <- 123456789\n\n# запрашиваем список задач\ntask <- taskscheduler_ls() %>%\n        filter(! `Last Result`  %in% c(\"0\", \"267011\")  &\n               `Scheduled Task State` == \"Enabled\" & \n               Status != \"Running\") %>%\n        select(TaskName) %>%\n        unique() %>%\n        unlist() %>%\n        paste0(., collapse = \"\\n\")\n\n# если есть проблемные задачи отправляем сообщение\nif ( task != \"\" ) {\n\n  bot$sendMessage(chat_id,\n                  text = task,\n                  parse_mode = \"Markdown\"\n  )\n\n}[telegram_bot]\n;настройки телеграм бота и чата, в который будут приходить уведомления\nchat_id=12345678\nbot_token=123456789:abcdefghijklmnopqrstuvwxyz\"\nlibrary(configr)\n\n# чтение конфина\nconfig <- read.config('C:/путь_к_конфигу/config.cfg', rcmd.parse = TRUE)\n\nbot_token <- config$telegram_bot$bot_token\nchat_id     <- config$telegram_bot$chat_id"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"настраиваем-расписание-запуска-проверки-задач","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.7 Настраиваем расписание запуска проверки задач","text":"Наиболее подробно процесс настройки запуска скриптов по расписанию описан в этой статье . Тут я лишь опишу шаги, которые для этого необходимо выполнить. Если какой-то из шагов вам не понятен, то обратитесь к статье на которую я указал ссылку.Предположим, что мы сохранили код нашего бота в файл check_bot.R. Для того, что бы запланировать регулярный запуск этого файла выполните следующие шаги:Пропишите в системную переменную Path путь к папке в которой установлен R, в Windows путь будет примерно таким: C:\\Program Files\\R\\R-4.0.2\\bin.Создайте исполняемый bat файл, в котором будет всего одна строка R CMD BATCH C:\\rscripts\\check_bot\\check_bot.R. Замените C:\\rscripts\\check_bot\\check_bot.R на полный путь к вашему R файлу.Далее настройте с помощью планировщика задач Windows расписание запуска, например на каждые пол часа.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"заключение","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8 Заключение","text":"В этой главе мы разобрались с тем, как создать бота, и отправлять с его помощью различные уведомления в telegram.Я описал задачу контроля планировщика заданий Windows, но вы можете использовать материал этой главы для отправки любых уведомлений, от прогноза погоды до котировок акций на фондовой бирже, т.к. R позволяет вам подключиться к огромному количеству источников данных.В следующей главе мы с вами разберёмся с тем, как добавить боту команды и фильтры сообщений, для того, что он мог не только отправлять уведомления, но и выполнять более сложные действия.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"тесты-и-задания","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.9 Тесты и задания","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"тесты","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.9.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"задания","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.9.2 Задания","text":"Создайте с помощью BotFather бота.Перейдите к диалогу с ботом, и узнайте идентификатор вашего с ботом чата.Отправьте с помощью созданного бота в telegram первые 20 строк из встроенного в R набора данных ToothGrowth.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","text":"","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"видео-по-добавлению-боту-поддержки-команд","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.1 Видео по добавлению боту поддержки команд","text":"","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"введение-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.2 Введение","text":"В этой главе мы разберёмся как оживить нашего бота и добавим ему поддержку команд, а также познакомимся с классом Updater.В ходе главы мы напишем нескольких простых ботов, последний будет по заданной дате и коду страны определять является ли день в данной стране выходным или рабочим согласно производственного календаря. Но, как и прежде цель книги ознакомить вас с интерфейсом пакета telegram.bot для решения ваших собственных задач.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"класс-updater","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.3 Класс Updater","text":"Updater - это класс, который упрощает вам разработку телеграм бота, и использует под капотом класс Dispetcher. Назначение класса Updater заключается в том, что бы получить обновления от бота (в предыдущей главе мы использовали для этой цели метод getUpdates()), и передать их далее в Dispetcher.В свою очередь Dispetcher содержит в себе созданные вами обработчики, т.е. объекты класса Handler.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"handlers---обработчики","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.4 Handlers - обработчики","text":"С помощью обработчиков вы добавляете в Dispetcher реакции бота на различные события. На момент написания книги в telegram.bot добавлены следующие типы обработчиков:MessageHandler - Обработчик сообщенийCommandHandler - Обработчик командCallbackQueryHandler - Обработчик данных отправляемых из Inline клавиатурErrorHandler - Обработчик ошибок при запросе обновлений от бота","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"добавляем-первую-команду-боту-обработчик-команд","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.5 Добавляем первую команду боту, обработчик команд","text":"Если вы никогда ранее не использовали ботов, и не в курсе, что такое команда, то команды боту необходимо отправлять с помощью прямого слеша / в качестве префикса.Начнём мы с простых команд, т.е. научим нашего бота здороваться по команде /hi.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Метод start_polling() класса Updater, который используется в конце кода, запускает бесконечный цикл запроса и обработки обновлений от бота.Мы написали боту метод say_hello(). Методами бота являются функции с двумя обязательными аргументами:bot - объект бота, с помощью которого вы можете выполнять любые, доступные боту операции: отправлять сообщения, удалять сообщения, и так далее.update - полученное от пользоватя сообщение (обновление бота).Внутри кода метода вы можете обращаться и к боту, и к обновлению. С методами бота мы познакомились в первой главе, теперь давайте я вкратце опишу методы, доступные в приходящих обновлениях:from_chat_id() - получить идентификатор чата, из которого боту было отправлено сообщениеfrom_user_id() - получить идентификатор пользователя, который отправил боту сообщениеeffective_chat() - получить подробную информацию о чате, из которого бот получил сообщениеeffective_message() - получить подробную информацию о сообщение, включая текс, вложения и т.д.effective_user() - получить подробную информацию о пользователе, который отправил сообщениеТеперь откроем телеграм, и напишем нашему боту первую команду /hi.Теперь наш бот понимает команду /hi, и умеет с нами здороваться.Схематически процесс построения такого простейшего бота можно изобразить следующим образом.Создаём экземпляр класса Updater;Создаём методы, т.е. функции которые будет выполнять наш бот. В примере кода это функция say_hello(). Функции, которые вами будут использоваться как методы бота должны иметь два обязательных аргумента - bot и update, и один необязательный - args. Аргумент bot, это и есть ваш бот, с его помощью вы можете отвечать на сообщения, отправлять сообщения, или использовать любые другие доступные боту методы. Аргумент update это то, что бот получил от пользователя, по сути, то что в первой главе мы получали методом getUpdates(). Аргумент args позволяет вам обрабатывать дополнительные данные отправленные пользователем вместе с командой, к этой теме мы ещё вернёмся немного позже;Создаём обработчики, т.е. связываем какие-то действия пользователя с созданными на прошлом шаге методами. По сути обработчик это триггер, событие которое вызывает какую-то функцию бота. В нашем примере таким триггером является отправка команды /hi, и реализуется командой hi_hendler <- CommandHandler('hi', say_hello). Первый аргумент функции CommandHandler() позволяет вам задать команду, в нашем случае hi, на которую будет реагировать бот. Второй аргумент позволяет указать метод бота, мы будем вызывать метод say_hello, который будет выполняться если пользователь вызвал указанную в первом аргументе команду;Далее добавляем созданный обработчик в диспетчер нашего экземпляра класса Updater. Добавлять обработчики можно несколькими способами, в примере выше я использовал простейший, с помощью знака +, т.е. updater <- updater + hi_hendler. То же самое можно сделать с помощью метода add_handler(), который относится к классу Dispatcher, найти этот метод можно так: updater$dispatcher$add_handler();Запускаем бота с помощью команды start_polling().","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\nsay_hello <- function(bot, update) {\n\n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n\n  # Отправка приветственного сообщения\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\")\n\n}\n\n# создаём обработчик\nhi_hendler <- CommandHandler('hi', say_hello)\n\n# добаляем обработчик в диспетчер\nupdater <- updater + hi_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"обработчик-текстовых-сообщений-и-фильтры","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.6 Обработчик текстовых сообщений и фильтры","text":"Как отправлять боту команды мы разобрались, но иногда нам требуется, что бы бот реагировал не только на команды, но и на какие-то обычные, текстовые сообщения. Для этого необходимо использовать обработчики сообщений - MessageHandler.Обычный MessageHandler будет реагировать на абсолютно все входящие сообщения. Поэтому зачастую обработчики сообщений используются вместе с фильтрами. Давайте научим бота здороваться не только по команде /hi, но и всегда, когда в сообщении отправленном боту встречается одно из следующих слов: привет, здравствуй, салют, хай, бонжур.Пока мы не будем писать какие-то новые методы, т.к. у нас уже есть метод с помощью которого бот с нами здоровается. От нас требуется только создать нужный фильтр и обработчик сообщений.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Итак, в первую очередь мы научили бота не просто здороваться, а отвечать на приветствие. Сделали мы это с помощью аргумента reply_to_message_id, который доступен в методе sendMessage(), в который необходимо передать id сообщения на которое требуется ответить. Получить id сообщения можно вот так: update$message$message_id.Но главное, что мы сделали - добавили боту фильтр с помощью функции BaseFilter():Как вы могли заметить, фильтры необходимо добавлять в объект MessageFilters, в котором изначально уже есть небольшой набор готовых фильтров. В нашем примере в объект MessageFilters мы добавили элемент hi, это новый фильтр.В функцию BaseFilter() вам необходимо передать фильтрующую функцию. По сути, фильтр - это просто функция, которая получает экземпляр сообщения и возвращает TRUE или FALSE. В нашем примере, мы написали простейшую функцию, которая с помощью базовой функции grepl() проверяет текст сообщения, и если он соответствует регулярному выражению привет|здравствуй|салют|хай|бонжур возвращает TRUE.Далее мы создаём обработчик сообщений hi_txt_hnd <- MessageHandler(say_hello, filters = MessageFilters$hi). Первый аргумент функции MessageHandler() - метод, который будет вызывать обработчик, а второй аргумент - это фильтр по которому он будет вызываться. В нашем случае это созданный нами фильтр MessageFilters$hi.Ну и в итоге, мы добавляем в диспетчер созданный только, что обработчик hi_txt_hnd.Как я уже писал выше, в пакете telegram.bot и объекте MessageFilters уже есть набор встроенных фильтров, которые вы можете использовать:- Все сообщенияtext - Текстовые сообщенияcommand - Команды, т.е. сообщения которые начинаются на /reply - Сообщения, которые являются ответом на другое сообщениеaudio - Сообщения в которых содержится аудио файлdocument - Сообщения с отправленным документомphoto - Сообщения с отправленными изображениямиsticker - Сообщения с отправленным стикеромvideo - Сообщения с видеоvoice - Голосовые сообщенияcontact - Сообщения в которых содержится контант телеграм пользователяlocation - Сообщения с геолокациейvenue - Пересылаемые сообщенияgame - ИгрыЕсли вы хотите совместить некоторые фильтры в одном обработчике просто используйте знак | - в качестве логического ИЛИ, и знак & в качестве логического И. Например, если вы хотите что бы бот вызывал один и тот же метод когда он получает видео, изображение или документ используйте следующий пример создания обработчика сообщений:","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветвия\nsay_hello <- function(bot, update) {\n\n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n\n  # Отправляем приветсвенное сообщение\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\",\n                  reply_to_message_id = update$message$message_id)\n\n}\n\n# создаём фильтры\nMessageFilters$hi <- BaseFilter(function(message) {\n\n  # проверяем, встречается ли в тексте сообщения слова: привет, здравствуй, салют, хай, бонжур\n  grepl(x           = message$text,\n        pattern     = 'привет|здравствуй|салют|хай|бонжур',\n        ignore.case = TRUE)\n  }\n)\n\n# создаём обработчик\nhi_hendler <- CommandHandler('hi', say_hello) # обработчик команды hi\nhi_txt_hnd <- MessageHandler(say_hello, filters = MessageFilters$hi)\n\n# добаляем обработчики в диспетчер\nupdater <- updater +\n             hi_hendler +\n             hi_txt_hnd\n\n# запускаем бота\nupdater$start_polling()\n# создаём фильтры\nMessageFilters$hi <- BaseFilter(\n\n  # анонимная фильтрующая функция\n  function(message) {\n\n    # проверяем, встречается ли в тексте сообщения слова приветствия\n    grepl(x           = message$text,\n          pattern     = 'привет|здравствуй|салют|хай|бонжур',\n          ignore.case = TRUE)\n  }\n\n)\nupdater <- updater +\n             hi_hendler +\n             hi_txt_hnd\nhandler <- MessageHandler(callback,\n  MessageFilters$video | MessageFilters$photo | MessageFilters$document\n)"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"добавление-команд-с-параметрами","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.7 Добавление команд с параметрами","text":"Мы уже знаем, что такое команды, как их создавать и как заставить бота выполнить нужную команду. Но в некоторых случаях помимо названия команды, нам необходимо передать некоторые данные для её выполнения.Ниже пример бота, который по заданной дате и стране возвращает вам тип дня из производственного календаря.Приведённый ниже бот использует API производственного календаря isdayoff.ru.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Мы создали бота, который в арсенале имеет всего один метод check_date, данный метод вызывается одноимённой командой.Но, помимо имени команды, данный метод ждёт от вас введения двух параметров, код страны и дату. Далее бот проверяется, является ли заданный день в указанной стране выходным, сокращённым или рабочим согласно официального производственного календаря.Что бы создаваемый нами метод принимал дополнительные параметры вместе с командой, используйте аргумент pass_args = TRUE в функции CommandHandler(), и при создании метода, помимо обязательных аргументов bot, update создайте опциональный - args. Созданный таким образом метод будет принимать параметры, которые вы передаёте боту после названия команды. Параметры необходимо между собой разделять пробелом, в метод они поступят в виде текстового вектора.Давайте запустим, и протестируем нашего бота.","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветвия\ncheck_date <- function(bot, update, args) {\n\n  # входящие данные\n  day     <- args[1]  # дата\n  country <- args[2]  # страна\n\n  # проверка введённых параметров\n  if ( !grepl('\\\\d{4}-\\\\d{2}-\\\\d{2}', day) ) {\n\n    # Send Custom Keyboard\n    bot$sendMessage(update$from_chat_id(),\n                    text = paste0(day, \" - некорреткная дата, введите дату в формате ГГГГ-ММ-ДД\"),\n                    parse_mode = \"Markdown\")\n\n  } else {\n    day <- as.Date(day)\n    # переводим в формат POSIXtl\n    y <- format(day, \"%Y\")\n    m <- format(day, \"%m\")\n    d <- format(day, \"%d\")\n\n  }\n\n  # страна для проверки\n  ## проверяем задана ли страна\n  ## если не задана устанавливаем ru\n  if ( ! country %in% c('ru', 'ua', 'by', 'kz', 'us') ) {\n\n    # Send Custom Keyboard\n    bot$sendMessage(update$from_chat_id(),\n                    text = paste0(country, \" - некорретктный код страны, возможнные значения: ru, by, kz, ua, us. Запрошены данные по России.\"),\n                    parse_mode = \"Markdown\")\n\n    country <- 'ru'\n\n  }\n\n  # запрос данных из API\n  # компоновка HTTP запроса\n  url <- paste0(\"https://isdayoff.ru/api/getdata?\",\n                \"year=\",  y, \"&\",\n                \"month=\", m, \"&\",\n                \"day=\",   d, \"&\",\n                \"cc=\",    country, \"&\",\n                \"pre=1&\",\n                \"covid=1\")\n\n  # получаем ответ\n  res <- readLines(url)\n\n  # интрепретация ответа\n  out <- switch(res,\n                \"0\"   = \"Рабочий день\",\n                \"1\"   = \"Нерабочий день\",\n                \"2\"   = \"Сокращённый рабочий день\",\n                \"4\"   = \"covid-19\",\n                \"100\" = \"Ошибка в дате\",\n                \"101\" = \"Данные не найдены\",\n                \"199\" = \"Ошибка сервиса\")\n\n  # отправляем сообщение\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(day, \" - \", out),\n                  parse_mode = \"Markdown\")\n\n}\n\n# создаём обработчик\ndate_hendler <- CommandHandler('check_date', check_date, pass_args = TRUE)\n\n# добаляем обработчик в диспетчер\nupdater <- updater + date_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"запускаем-бота-в-фоновом-режиме","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.8 Запускаем бота в фоновом режиме","text":"Последний шаг который нам осталось выполнить - запустить бота в фоновом режиме.Для этого следуйте по описанному ниже алгоритму:Сохраните код бота в файл с расширением R. При работе в RStudio это делается через меню File, командой Save ….Добавьте путь к папке bin, которая в свою очередь находится в папке в которую вы установили язык R в переменную Path, инструкция тут.Создайте обычный текстовый файл, в котором пропишите 1 строку: R CMD BATCH C:\\Users\\Alsey\\Documents\\my_bot.R. Вместо *C:_bot.R* пропишите путь к своему скрипту бота. При этом важно, что бы в пути не встречалась кириллица и пробелы, т.к. это может вызвать проблемы при запуске бота. Сохраните его, и замените его расширение с txt на bat.Откройте планировщик заданий Windows, есть множество способов это сделать, например откройте любую папку и в адресс введите %windir%\\system32\\taskschd.msc /s. Другие способы запуска можно найти тут.В верхнем правом меню планировщика нажмите “Создать задачу…”.На вкладке “Общие” задайте произвольное имя вашей задаче, и переключатель перевидите в состояние “Выполнять для всех пользователей”.Перейдите на вкладку “Действия”, нажмите “Создать”. В поле “Программа или сценарий” нажмите “Обзор”, найдите созданный на втором шаге bat файл, и нажмите ОК.Жмём ОК, при необходимости вводим пароль от вашей учётной записи операционной системы.Находим в планировщике созданную задачу, выделяем и в нижнем правом углу жмём кнопку “Выполнить”.Наш бот запущен в фоновом режиме, и будет работать до тех пор, пока вы не остановите задачу, или не выключите ваш ПК или сервер на котором его запустили.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"как-добавить-бота-в-группу","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.9 Как добавить бота в группу","text":"Для того, что бы использовать бота в публичных или закрытых группах, изначально проверьте соответвующую настройку в BotFather. По умолчанию эта настройка должна быть включена. Находится она тут: /mybots -> @bot_username -> Bot Settings -> Allow Groups?. Если настройка включена то вы увидите следующее сообщение:Далее добааляете бота в нужные группы и используете его через команды. Если вам необходимо сделать так, что бы бот прослушивал не только команды, но и все сообщения в группе, то вам необходимо назначить его администратором, посе чего вы увидите что бот имеет доступ ко всем сообщениям.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"как-добавить-описание-команд-в-интерфейс-бота","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.10 Как добавить описание команд в интерфейс бота","text":"Теперь вы умеете создавать полноценных ботов, которых помимо вас могут использовать другие пользователи. Но, для того, что бы облегчить поиск нужных команд вы можете добавить их в интефейс бота.Делается это через BotFather -> @bot_username -> Edit Bot -> Edit Commands. Далее просто передаёте название команды и через тире их описание:","code":"command1 - Description\ncommand2 - Another description"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"заключение-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.11 Заключение","text":"В этой главе мы разобрались как написать полноценного бота, который не только умеет отправлять сообщения, но и реагировать на входящие сообщения и команды. Полученных знананий уже достаточно для решения большинства ваших задач.В следующей главе речь пойдёт о том, как добавить боту клавиатуру, для более удобной работы.Подписываетесь на мой telegram и youtube каналы.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"тесты-и-задания-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.12 Тесты и задания","text":"","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"тесты-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.12.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"задания-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.12.2 Задания","text":"Создайте бота, который будет по команде /sum и переданное в качестве дополнительных параметров произвольное количество перечисленных через пробел чисел, возвращать их сумму.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"как-добавить-боту-поддержку-клавиатуры","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"Глава 3 Как добавить боту поддержку клавиатуры","text":"","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"видео-урок-по-добавлению-боту-клавиатуры","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.1 Видео урок по добавлению боту клавиатуры","text":"","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"введение-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.2 Введение","text":"В этой главе мы повысим юзабилити нашего бота за счёт добавления клавиатуры, которая сделает интерфейс бота интуитивно понятным, и простым в использовании.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"какие-типы-клавиатур-поддерживает-телеграм-бот","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.3 Какие типы клавиатур поддерживает телеграм бот","text":"На момент написания книги telegram.bot позволяет вам создать клавиатуры двух типов:Reply - Основная, обычная клавиатура, которая находится под панелью ввода текста сообщения. Такая клавиатура просто отправляет боту текстовое сообщение, и в качестве текста отправит тот текст, который написан на самой кнопке.Inline - Клавиатура привязанная к конкретному сообщению бота. Данная клавиатура отправляет боту данные, привязанные к нажатой кнопке, эти данные могут отличаться от текста, написанного на самой кнопке. И обрабатываются такие кнопки через CallbackQueryHandler.Для того, что бы бот открыл клавиатуру необходимо при отправке сообщения через метод sendMessage(), передать созданную ранее клавиатуру в аргумент reply_markup.Ниже мы разберём несколько примеров.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"reply-клавиатура","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.4 Reply клавиатура","text":"Как я уже писал выше, это основная клавиатура управления ботом.Выше приведён пример из официальной справки пакета telegram.bot. Для создания клавиатуры используется функция ReplyKeyboardMarkup(), которая в свою очередь принимает список списков кнопок, которые создаются функцией KeyboardButton().Почему в ReplyKeyboardMarkup() необходимо передавать не просто список, а список списков? Дело в том, что вы передаёте основной список, и в нём отдельными списками вы задаёте каждый ряд кнопок, т.к. в один ряд можно расположить несколько кнопок.Аргумент resize_keyboard позволяет автоматически подбирать оптимальный размер кнопок клавиатуры, а аргумент one_time_keyboard позволяет скрывать клавиатуру после каждого нажатия на кнопку.Давайте напишем простейшего бота, у которого будет 3 кнопки:\n* Чат ID - Запросить чат ID диалога с ботом\n* Моё имя - Запросить своё имя\n* Мой логин - Запросить своё имя пользователя в телеграмЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.После запуска задайте боту команду /start, т.к. именно её мы определили для запуска клавиатуры.Если на данный момент вам сложно разобрать приведённый пример кода, с созданием методов, фильтров и обработчиков, то следует вернуться к предыдущей главе, в которой я подробно всё это описал.Мы создали 4 метода:start - Запуск клавиатурыchat_id - Запрос идентификатора чатаmy_name - Запрос своего имениmy_username - Запрос своего логинаВ объект MessageFilters добавили 3 фильтра сообщений, по их тексту:chat_id - Сообщения с текстом \"Чат ID\"name - Сообщения с текстом \"Моё имя\"username - Сообщения с текстом \"Мой логин\"И создали 4 обработчика, которые по заданным командам и фильтрам будут выполнять указанные методы.Сама клавиатура создаётся внутри метода start() командой ReplyKeyboardMarkup().В нашем случае все кнопки мы расположили друг под другом, но мы можем расположить их в один ряд, внеся изменения в список списков кнопок. Т.к. один ряд внутри клавиатуры создаётся через вложенный список кнопок, то для того, что бы вывести наши кнопки в один ряд надо переписать часть кода по построению клавиатуры вот так:Отправляется клавиатура в чат методом sendMessage(), в аргументе reply_markup.","code":"\nbot <- Bot(token = \"TOKEN\")\nchat_id <- \"CHAT_ID\"\n\n# Create Custom Keyboard\ntext <- \"Aren't those custom keyboards cool?\"\nRKM <- ReplyKeyboardMarkup(\n  keyboard = list(\n    list(KeyboardButton(\"Yes, they certainly are!\")),\n    list(KeyboardButton(\"I'm not quite sure\")),\n    list(KeyboardButton(\"No...\"))\n  ),\n  resize_keyboard = FALSE,\n  one_time_keyboard = TRUE\n)\n\n# Send Custom Keyboard\nbot$sendMessage(chat_id, text, reply_markup = RKM)library(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# создаём методы\n## метод для запуска клавиатуры\nstart <- function(bot, update) {\n\n  # создаём клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(KeyboardButton(\"Чат ID\")),\n      list(KeyboardButton(\"Моё имя\")),\n      list(KeyboardButton(\"Мой логин\"))\n    ),\n    resize_keyboard = FALSE,\n    one_time_keyboard = TRUE\n  )\n\n  # отправляем клавиатуру\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)\n\n}\n\n## метод возвразающий id чата\nchat_id <- function(bot, update) {\n\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Чат id этого диалога: \", update$from_chat_id()),\n                  parse_mode = \"Markdown\")\n\n}\n\n## метод возвращающий имя\nmy_name <- function(bot, update) {\n\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Вас зовут \", update$effective_user()$first_name),\n                  parse_mode = \"Markdown\")\n\n}\n\n## метод возвращающий логин\nmy_username <- function(bot, update) {\n\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Ваш логин \", update$effective_user()$username),\n                  parse_mode = \"Markdown\")\n\n}\n\n# создаём фильтры\n## сообщения с текстом Чат ID\nMessageFilters$chat_id <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Чат ID\"\n\n}\n)\n\n## сообщения с текстом Моё имя\nMessageFilters$name <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Моё имя\"\n\n}\n)\n\n## сообщения с текстом Мой логин\nMessageFilters$username <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Мой логин\"\n)\n\n# создаём обработчики\nh_start    <- CommandHandler('start', start)\nh_chat_id  <- MessageHandler(chat_id, filters = MessageFilters$chat_id)\nh_name     <- MessageHandler(my_name, filters = MessageFilters$name)\nh_username <- MessageHandler(my_username, filters = MessageFilters$username)\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n            h_start +\n            h_chat_id +\n            h_name +\n            h_username\n\n# запускаем бота\nupdater$start_polling()\n# создаём обработчики\nh_start    <- CommandHandler('start', start)\nh_chat_id  <- MessageHandler(chat_id, filters = MessageFilters$chat_id)\nh_name     <- MessageHandler(my_name, filters = MessageFilters$name)\nh_username <- MessageHandler(my_username, filters = MessageFilters$username)\nRKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(KeyboardButton(\"Чат ID\")),\n      list(KeyboardButton(\"Моё имя\")),\n      list(KeyboardButton(\"Мой логин\"))\n    ),\n    resize_keyboard = FALSE,\n    one_time_keyboard = TRUE\n)\nRKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n          KeyboardButton(\"Чат ID\"),\n          KeyboardButton(\"Моё имя\"),\n          KeyboardButton(\"Мой логин\")\n     )\n    ),\n    resize_keyboard = FALSE,\n    one_time_keyboard = TRUE\n)\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"как-запросить-у-пользователя-номер-телефона-и-локацию","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.4.1 Как запросить у пользователя номер телефона и локацию","text":"При создании кнопок Reply клавиатуры мы используем функцию KeyboardButton(), у которой доступны 2 дополнительные аргумента:request_contact - Запросить номер телефона пользователяrequest_location - Запросить локацию пользователяКогда пользователь поделиться с ботом контактами, то в принятом от бота обновлении, в сообщении будет раздел contact со следующими данными:phone_number - номер телефона в международном форматеfirst_name - Имяlast_name - Фамилияuser_id - Внутренний идентификатор пользователя в telegramКогда пользователь делиться местонахождением то в сообщении полученного ответа будет раздел location с информацией о координатах местонахождения пользователя, т.е. широта и долгота.","code":"\nbot <- Bot(token = \"ТОКЕН ВАШЕГО БОТА\")\n\nchat_id <- \"ID ВАШЕГО ЧАТА\"\n\n# Create Custom Keyboard\ntext <- \"Поделитесь своими данными\"\n\nRKM <- ReplyKeyboardMarkup(\n  keyboard = list(\n    list(KeyboardButton(\"Поделиться номером телефона\", request_contact = TRUE)),\n    list(KeyboardButton(\"Поделиться местонахождением\", request_location = TRUE))\n  ),\n  resize_keyboard = FALSE,\n  one_time_keyboard = TRUE\n)\n\n# Send Custom Keyboard\nbot$sendMessage(chat_id, text, reply_markup = RKM)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"inline-клавиатура","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.5 Inline клавиатура","text":"Как я уже писал выше, Inline клавиатура привязана к конкретному сообщению. С ней работать несколько сложнее чем с основной клавиатурой.Изначально вам необходимо добавить боту метод, для вызова Inline клавиатуры.Для ответа на нажатие Inline кнопки также можно использовать метод бота answerCallbackQuery(), который может вывести уведомление в интерфейсе telegram, пользователю нажавшему Inline кнопку.Данные отправленные с Inline кнопки не являются текстом, поэтому для их обработки необходимо создать специальный обработчик с помощью команды CallbackQueryHandler().Код построения Inline клавиатуры который приводится в официальной справке пакета telegram.bot.Строить Inline клавиатуру необходимо с помощью команды InlineKeyboardMarkup(), по такому же принципу, как и Reply клавиатуру. В InlineKeyboardMarkup() необходимо передать список, списков Inline кнопок, каждая отдельная кнопка создаётся функцией InlineKeyboardButton().Inline кнопка может либо передавать боту какие-то данные с помощью аргумента callback_data, либо открывать какую-либо HTML страницу, заданную с помощью аргумента url.В результате будет список, в котором каждый элемент так же является списком Inline кнопок, которые необходимо объединить в один ряд.Далее мы рассмотрим несколько примеров ботов с Inline кнопками.","code":"\n# Initialize bot\nbot <- Bot(token = \"TOKEN\")\nchat_id <- \"CHAT_ID\"\n\n# Create Inline Keyboard\ntext <- \"Could you type their phone number, please?\"\nIKM <- InlineKeyboardMarkup(\n  inline_keyboard = list(\n    list(\n      InlineKeyboardButton(1),\n      InlineKeyboardButton(2),\n      InlineKeyboardButton(3)\n    ),\n    list(\n      InlineKeyboardButton(4),\n      InlineKeyboardButton(5),\n      InlineKeyboardButton(6)\n    ),\n    list(\n      InlineKeyboardButton(7),\n      InlineKeyboardButton(8),\n      InlineKeyboardButton(9)\n    ),\n    list(\n      InlineKeyboardButton(\"*\"),\n      InlineKeyboardButton(0),\n      InlineKeyboardButton(\"#\")\n    )\n  )\n)\n\n# Send Inline Keyboard\nbot$sendMessage(chat_id, text, reply_markup = IKM)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"пример-простейшего-бота-с-поддержкой-inline-кнопок","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.5.1 Пример простейшего бота с поддержкой InLine кнопок","text":"Для начала мы напишем бота для экспресс тестирования на covid-19. По команде /test, он будет отправлять вам клавиатуру с двумя кнопками, в зависимости от нажатой кнопки он будет присылать вам сообщение с результатами вашего тестирования.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Мы создали два метода:test - Для отправки в чат Inline клавиатурыanswer_cb - Для обработки отправленных с клавиатуры данных.Данные, которые будут отправлены с каждой кнопки задаются в аргументе callback_data, при создании кнопки. Получить отправленные с кнопки данные можно с помощью конструкции update$callback_query$data, внутри метода answer_cb.Что бы бот реагировал на Inline клавиатуру, метод answer_cb обрабатывается специальным обработчиком: CallbackQueryHandler(answer_cb). Который запускает указанный метод по нажатию Inline кнопки. Обработчик CallbackQueryHandler принимает два аргумента:callback - Метод который необходимо запуститьpattern - Фильтр по данным, которые привязаны к кнопке с помощью аргумента callback_data.Соответвенно с помощью аргумента pattern мы можем под нажатие каждой кнопки написать отдельный метод:Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Теперь мы написали 2 отдельных метода, т.е. по одному методу, под нажатие каждой кнопки, и использовали аргумент pattern, при создании их обработчиков:Заканчивается код метода answer_cb командой bot$answerCallbackQuery(callback_query_id = update$callback_query$id), которая сообщает боту, что данные с inline клавиатуры получены.","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# метод для отправки InLine клавиатуры\ntest <- function(bot, update) {\n\n\n  # создаём InLine клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(\"Да\", callback_data = 'yes'),\n        InlineKeyboardButton(\"Нет\", callback_data = 'no')\n      )\n    )\n  )\n\n  # Отправляем клавиатуру в чат\n  bot$sendMessage(update$from_chat_id(),\n                  text = \"Вы болете коронавирусом?\",\n                  reply_markup = IKM)\n}\n\n# метод для обработки нажатия кнопки\nanswer_cb <- function(bot, update) {\n\n  # полученные данные с кнопки\n  data <- update$callback_query$data\n\n  # получаем имя пользователя, нажавшего кнопку\n  uname <- update$effective_user()$first_name\n\n  # обработка результата\n  if ( data == 'no' ) {\n\n    msg <- paste0(uname, \", поздравляю, ваш тест на covid-19 отрицательный.\")\n\n  } else {\n\n    msg <- paste0(uname, \", к сожалени ваш тест на covid-19 положительный.\")\n\n  }\n\n\n  # Отправка сообщения\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = msg)\n\n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# создаём обработчики\ninline_h      <- CommandHandler('test', test)\nquery_handler <- CallbackQueryHandler(answer_cb)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + inline_h + query_handler\n\n# запускаем бота\nupdater$start_polling()\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# метод для отправки InLine клавиатуры\ntest <- function(bot, update) {\n\n  # создаём InLine клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(\"Да\", callback_data = 'yes'),\n        InlineKeyboardButton(\"Нет\", callback_data = 'no')\n      )\n    )\n  )\n\n  # Отправляем клавиатуру в чат\n  bot$sendMessage(update$from_chat_id(),\n                  text = \"Вы болете коронавирусом?\",\n                  reply_markup = IKM)\n}\n\n# метод для обработки нажатия кнопки Да\nanswer_cb_yes <- function(bot, update) {\n\n  # получаем имя пользователя, нажавшего кнопку\n  uname <- update$effective_user()$first_name\n\n  # обработка результата\n  msg <- paste0(uname, \", к сожалени ваш текст на covid-19 положительный.\")\n\n  # Отправка сообщения\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = msg)\n\n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# метод для обработки нажатия кнопки Нет\nanswer_cb_no <- function(bot, update) {\n\n  # получаем имя пользователя, нажавшего кнопку\n  uname <- update$effective_user()$first_name\n\n  msg <- paste0(uname, \", поздравляю, ваш текст на covid-19 отрицательный.\")\n\n  # Отправка сообщения\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = msg)\n\n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# создаём обработчики\ninline_h          <- CommandHandler('test', test)\nquery_handler_yes <- CallbackQueryHandler(answer_cb_yes, pattern = 'yes')\nquery_handler_no  <- CallbackQueryHandler(answer_cb_no, pattern = 'no')\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n            inline_h +\n            query_handler_yes +\n            query_handler_no\n\n# запускаем бота\nupdater$start_polling()\nquery_handler_yes <- CallbackQueryHandler(answer_cb_yes, pattern = 'yes')\nquery_handler_no  <- CallbackQueryHandler(answer_cb_no, pattern = 'no')"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"пример-бота-который-сообщает-текущую-погоду-по-выбранному-городу","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.5.2 Пример бота, который сообщает текущую погоду по выбранному городу","text":"Давайте попробуем написать бота, который запрашивает данные о погоде.Логика его работы будет следующая. Изначально командой /start вы вызываете основную клавиатуру, в которой присутствует всего одна кнопка “Погода”. Нажав на эту кнопку вы получаете сообщение с Inline клавиатурой, для выбора города, по которому требуется узнать текущую погоду. Выбираете один из городов, и получаете текущую погоду.В этом примере кода мы будем использовать несколько дополнительных пакетов:httr - пакет для работы с HTTP запросами, на основе которых построена работа с любым API. В нашем случае мы будем использовать бесплатный API openweathermap.org.stringr - пакет для работы с текстом, в нашем случае мы будем его использовать для формирования сообщения о погоде в выбранном городе.Код бота, который сообщает текущую погоду по выбранному городуЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Мы создали 3 метода, доступные внутри нашего погодного бота:start - Запуск основной клавиатуры ботаweather - Запуск Inline клавиатуры для выбора городаanswer_cb - Основной метод, который по заданному городу запрашивает в API погоду, и отправляет её в чат.Метод start у нас запускается командой /start, что реализовано обработчиком CommandHandler('start', start).Для запуска метода weather мы создали одноимённый фильтр:И вызываем этот метод следующим обработчиком сообщений: MessageHandler(weather, filters = MessageFilters$weather).И в конце концов, основной наш метод answer_cb реагирует на нажатие Inline кнопок, что реализовано специальным обработчиком: CallbackQueryHandler(answer_cb).Внутри метода answer_cb, мы считываем отправленные с клавиатуры данные и записываем их в переменную city: city <- update$callback_query$data. После чего запрашиваем из API данные о погоде, формируем и отправляем сообщение, и в конце концов используем метод answerCallbackQuery для того, что бы сообщить боту, о том, что мы обработали нажатие Inline кнопки.","code":"\nlibrary(telegram.bot)\nlibrary(httr)\nlibrary(stringr)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# создаём методы\n## метод для запуска основной клавиатуры\nstart <- function(bot, update) {\n\n  # создаём клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n        KeyboardButton(\"Погода\")\n      )\n    ),\n    resize_keyboard = TRUE,\n    one_time_keyboard = TRUE\n  )\n\n  # отправляем клавиатуру\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)\n\n}\n\n## Метод вызова Inine клавиатуры\nweather <- function(bot, update) {\n\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(text = 'Москва', callback_data = 'New York,us'),\n        InlineKeyboardButton(text = 'Санкт-Петербург', callback_data = 'Saint Petersburg'),\n        InlineKeyboardButton(text = 'Нью-Йорк', callback_data = 'New York')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Екатеринбург', callback_data = 'Yekaterinburg,ru'),\n        InlineKeyboardButton(text = 'Берлин', callback_data = 'Berlin,de'),\n        InlineKeyboardButton(text = 'Париж', callback_data = 'Paris,fr')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Рим', callback_data = 'Rome,it'),\n        InlineKeyboardButton(text = 'Одесса', callback_data = 'Odessa,ua'),\n        InlineKeyboardButton(text = 'Киев', callback_data = 'Kyiv,ua')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Токио', callback_data = 'Tokyo'),\n        InlineKeyboardButton(text = 'Амстердам', callback_data = 'Amsterdam,nl'),\n        InlineKeyboardButton(text = 'Вашингтон', callback_data = 'Washington,us')\n      )\n    )\n  )\n\n  # Send Inline Keyboard\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = \"Выберите город\",\n                  reply_markup = IKM)\n}\n\n# метод для сообщения погоды\nanswer_cb <- function(bot, update) {\n\n  # получаем из сообщения город\n  city <- update$callback_query$data\n\n  # отправляем запрос\n  ans <- GET('https://api.openweathermap.org/data/2.5/weather',\n             query = list(q     = city,\n                          lang  = 'ru',\n                          units = 'metric',\n                          appid = '4776568ccea136ffe4cda9f1969af340'))\n\n  # парсим ответ\n  result <- content(ans)\n\n  # формируем сообщение\n  msg <- str_glue(\"{result$name} погода:\\n\",\n                  \"Текущая температура: {result$main$temp}\\n\",\n                  \"Скорость ветра: {result$wind$speed}\\n\",\n                  \"Описание: {result$weather[[1]]$description}\")\n\n  # отправляем информацию о погоде\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text    = msg)\n\n\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# создаём фильтры\n## сообщения с текстом Погода\nMessageFilters$weather <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Погода\"\n\n}\n)\n\n# создаём обработчики\nh_start         <- CommandHandler('start', start)\nh_weather       <- MessageHandler(weather, filters = MessageFilters$weather)\nh_query_handler <- CallbackQueryHandler(answer_cb)\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n              h_start +\n              h_weather +\n              h_query_handler\n\n# запускаем бота\nupdater$start_polling()\n# создаём фильтры\n## сообщения с текстом Погода\nMessageFilters$weather <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Погода\"\n\n}\n)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"пример-бота-который-выводит-список-самых-свежих-статей-со-ссылками-по-указанному-хабу-из-habr.com.","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.5.3 Пример бота, который выводит список самых свежих статей со ссылками по-указанному Хабу из habr.com.","text":"Данного бота я привожу для того, что бы показать вам, как вывести Inline кнопки которые ведут на веб страницы.Логика данного бота схожа с предыдущим, изначально мы запускаем основную клавиатуру командой /start. Далее бот даёт нам на выбор список из 6 хабов, мы выбираем интересующий нас хаб, и получаем 5 самых свежих публикаций из выбранного Хаба.Как вы понимаете, в данном случае нам необходимо получить список статей, и для этого мы будем использовать специальный пакет habR, который позволяет запрашивать из хабры статьи и некоторую статистику по ним в R.Установить пакет habR можно только из github, для чего вам понадобится дополнительный пакет devtools. Для установки воспользуйтесь приведённым ниже кодом.Теперь рассмотрим код построения описанного выше бота:Код бот который выводит список наиболее свежих статей по выбранному ХабуЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Список доступных для выбора Хабов мы вбили хардкодом, в методе habs:Список статей из указанного Хаба мы получаем командой habr_hub_posts(), из пакета habR. При этом указываем, что нам не требуется список статей за всё время, а только первая страница на которой располагаются 20 статей. Из полученной таблицы с помощью команды head() оставляем только 5 самых верхних, которые и являются самыми свежими статьями.Логика очень схожа с предыдущим ботом, но в данном случае Inline клавиатуру со списком статей мы генерируем динамически с помощью функции lapply().В текст кнопки мы подставляем название статьи posts$title[x], а в аргумент url ссылку на статью: url = posts$link[x].Далее, создаём фильтр, обработчики и запускаем нашего бота.","code":"\ninstall.packages('devtools')\ndevtools::install_github('selesnow/habR')\nlibrary(telegram.bot)\nlibrary(habR)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# создаём методы\n## метод для запуска основной клавиатуры\nstart <- function(bot, update) {\n\n  # создаём клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n        KeyboardButton(\"Список статей\")\n      )\n    ),\n    resize_keyboard = TRUE,\n    one_time_keyboard = TRUE\n  )\n\n  # отправляем клавиатуру\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)\n\n}\n\n## Метод вызова Inine клавиатуры\nhabs <- function(bot, update) {\n\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(text = 'R', callback_data = 'R'),\n        InlineKeyboardButton(text = 'Data Mining', callback_data = 'data_mining'),\n        InlineKeyboardButton(text = 'Data Engineering', callback_data = 'data_engineering')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Big Data', callback_data = 'bigdata'),\n        InlineKeyboardButton(text = 'Python', callback_data = 'python'),\n        InlineKeyboardButton(text = 'Визуализация данных', callback_data = 'data_visualization')\n      )\n    )\n  )\n\n  # Send Inline Keyboard\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = \"Выберите Хаб\",\n                  reply_markup = IKM)\n}\n\n# метод для сообщения погоды\nanswer_cb <- function(bot, update) {\n\n  # получаем из сообщения город\n  hub <- update$callback_query$data\n\n  # сообщение о том, что данные по кнопке получены\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id,\n                          text = 'Подождите несколько минут, запрос обрабатывается')\n\n  # сообщение о том, что надо подождать пока бот получит данные\n  mid <- bot$sendMessage(chat_id = update$from_chat_id(),\n                         text    = \"Подождите несколько минут пока, я соберу данные по выбранному Хабу\")\n\n  # парсим Хабр\n  posts <- head(habr_hub_posts(hub, 1), 5)\n\n  # удаляем сообщение о том, что надо подождать\n  bot$deleteMessage(update$from_chat_id(), mid$message_id)\n\n  # формируем список кнопок\n  keys <- lapply(1:5, function(x) list(InlineKeyboardButton(posts$title[x], url = posts$link[x])))\n\n  # формируем клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard =  keys\n    )\n\n  # отправляем информацию о погоде\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text    = paste0(\"5 наиболее свежих статей из Хаба \", hub),\n                  reply_markup = IKM)\n\n}\n\n# создаём фильтры\n## сообщения с текстом Погода\nMessageFilters$hubs <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Список статей\"\n\n}\n)\n\n# создаём обработчики\nh_start         <- CommandHandler('start', start)\nh_hubs          <- MessageHandler(habs, filters = MessageFilters$hubs)\nh_query_handler <- CallbackQueryHandler(answer_cb)\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n  h_start +\n  h_hubs  +\n  h_query_handler\n\n# запускаем бота\nupdater$start_polling()\n## Метод вызова Inine клавиатуры\nhabs <- function(bot, update) {\n\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(text = 'R', callback_data = 'r'),\n        InlineKeyboardButton(text = 'Data Mining', callback_data = 'data_mining'),\n        InlineKeyboardButton(text = 'Data Engineering', callback_data = 'data_engineering')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Big Data', callback_data = 'bigdata'),\n        InlineKeyboardButton(text = 'Python', callback_data = 'python'),\n        InlineKeyboardButton(text = 'Визуализация данных', callback_data = 'data_visualization')\n      )\n    )\n  )\n\n  # Send Inline Keyboard\n  bot$sendMessage(chat_id = update$message$chat_id,\n                  text = \"Выберите Хаб\",\n                  reply_markup = IKM)\n}\n  # парсим Хабр\n  posts <- head(habr_hub_posts(hub, 1), 5)\n  # формируем список кнопок\n  keys <- lapply(1:5, function(x) list(InlineKeyboardButton(posts$title[x], url = posts$link[x])))\n\n  # формируем клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard =  keys\n    )"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"заключение-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.6 Заключение","text":"Теперь написанные вами боты будут значительно удобней в работе, за счёт того, что управление ими будет осуществляться с клавиатуры, а не вводом команд. Как минимум при взаимодействии с ботом через смартфон клавиатура ощутимо упростит процесс его использования.В следующей главе мы разберёмся как строить логический диалог с ботом, и работать с базами данных.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"тесты-и-задания-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.7 Тесты и задания","text":"","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"тесты-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.7.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"задания-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.7.2 Задания","text":"Создайте бота, который будет поддерживать Reply клавиатуру. На Reply клавиатуре будет всего одна кнопка “Время”. По нажатию на неё будет появляться Inline клавиатура с выбором из 6 часовых поясов.Africa/CairoAmerica/ChicagoEurope/MoscowAsia/BangkokEurope/KievAustralia/SydneyКнопки Inline клавиатуры необходимо расположить по 2 в ряд, соответвенно в три ряда.По нажатию на одну из кнопки Inline клавиатуры бот будет запрашивать информацию по текущему времени из API worldtimeapi.org.Формат запроса к API: http://worldtimeapi.org/api/timezone/{area}/:{location}.Где {area} это континент, например Europe, а {location} это город, например Kiev. Дату и время надо брать в ответе из компонента datetime.Если вы всё сделали правильно результат будет такой:","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"построение-последовательного-логического-диалога-с-ботом","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"Глава 4 Построение последовательного, логического диалога с ботом","text":"В этой главе мы с вами научимся писать бота, который будет поддерживать последовательный диалог. Т.е. бот будет задавать вам вопросы, и ждать от вас ввода какой-либо информации. В зависимости от введённых вами данных бот будет выполнять некоторые действия.Также в данной главе мы научимся использовать под капотом бота базы данных, в нашем примере это будет SQLite, но вы можете использовать любую другую СУБД. Более подробно о взаимодействии с базами данных на языке R я писал в статье на Хабре.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"видео-урок-по-разработке-последовательного-диалога-с-ботом","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.1 Видео урок по разработке последовательного диалога с ботом","text":"","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"конспект-по-разработке-логического-диалога-с-ботом","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2 Конспект по разработке логического диалога с ботом","text":"","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"введение-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.1 Введение","text":"Для того, что бы бот мог запрашивать от вас данные, и ждать ввод какой-либо информации вам потребуется фиксировать текущее состояние диалога. Лучший способ это делать, использовать какую нибудь встраиваемую базу данных, например SQLite.Т.е. логика будет следующей. Мы вызываем метод бота, и бот последовательно запрашивает у нас какую-то информацию, при этом на каждом шаге он ждёт ввод этой информации, и может осуществлять её проверку.Мы напишем максимально простого бота, сначала он будет спрашивать ваше имя, потом возраст, полученные данные будет сохранять в базу данных. При запросе возраста будет проверять, что бы введённые данные были числом, а не текстом.Такой простой диалог будет иметь всего три состояния:\n1. start - обычное состояние бота, в котором он не ждёт от вас никакой информации\n2. wait_name - состояние, при котором бот ожидает ввод имени\n3. wait_age - состояние, при котором бот ожидает ввод вашего возраста, количество полных лет.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"процесс-построения-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.2 Процесс построения бота","text":"Создаём конфиг бота, в котором будем хранить некоторые настройки. В нашем случае токен бота, и путь к файлу базы данных.Создаём переменную среды, в которой будет хранится путь к проекту с ботом.Создаём саму базу данных, и ряд функций для того, что бы бот мог взаимодействовать с ней.Пишем методы бота, т.е. функции которые он будет выполнять.Добавляем фильтры сообщений. С помощью которых бот будет обращаться к нужным методам, в зависимости от текущего состояния чата.Добавляем обработчики, которые свяжут команды и сообщения с нужными методами бота.Запускаем бота.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"структура-проекта-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.3 Структура проекта бота","text":"Для удобства мы разобъём код нашего бота, и прочие связанные с ним файлы на следующую структуру.bot.R - основной код нашего ботаdb_bot_function.R - блок кода с функциями для работы с базой данныхbot_methods.R - код методов ботаmessage_filters.R - фильтры сообщенийhandlers.R - обработчикиconfig.cfg - конфиг ботаcreate_db_data.sql - SQL скрипт создания таблицы с данными чата в базе данныхcreate_db_state.sql - SQL скрипт создания таблицы текущего состояния чата в базе данныхbot.db - база данных ботаВесь проект бота можно посмотреть, или скачать из моего репозитория на GitHub.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"конфиг-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.4 Конфиг бота","text":"В качестве конфига мы будем использовать обычный ini файл, следующего вида:В конфиг мы записываем токен бота, и путь к базе данных, т.е. к файлу bot.db, сам файл мы будем создавать на следующем шаге.Для более сложных ботов можно создавать и более сложные конфиги, к тому же необязательно писать именно ini конфиг, можете использовать любой другой формат включая JSON.","code":"[bot_settings]\nbot_token=ТОКЕН_ВАШЕГО_БОТА\n\n[db_settings]\ndb_path=C:/ПУТЬ/К/ПАПКЕ/ПРОЕКТА/bot.db"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"создаём-переменную-среды","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.5 Создаём переменную среды","text":"На каждом ПК папка с проектом бота может располагаться в разных директориях, и на разных дисках, поэтому в коде путь к папке проекта будет задан через переменную среды TG_BOT_PATH.Создать переменную среды можно несколькими способами, наиболее простой - прописать её в файле .Renviron.Создать, или редактировать данный файл можно с помощью команды file.edit(path.expand(file.path(\"~\", \".Renviron\"))). Выполните её и добавьте в файл одну строку:Далее сохраните файл .Renviron и перезапустите RStudio.","code":"TG_BOT_PATH=C:/ПУТЬ/К/ВАШЕМУ/ПРОЕКТУ"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"создаём-базу-данных","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.6 Создаём базу данных","text":"Следующий шаг - создание базы данных. Нам понадобится 2 таблицы:chat_data - данные которые бот запросил у пользователяchat_state - текущее состояние всех чатовСоздать эти таблицы можно с помощью следующего SQL запроса:Если вы скачали проект бота с GitHub, то для создания базы можете воспользоваться следующим кодом на языке R.","code":"CREATE TABLE chat_data (\n    chat_id BIGINT  PRIMARY KEY\n                    UNIQUE,\n    name    TEXT,\n    age     INTEGER\n);\n\nCREATE TABLE chat_state (\n    chat_id BIGINT PRIMARY KEY\n                   UNIQUE,\n    state   TEXT\n);\n# Скрипт создания базы данных\nlibrary(DBI)     # интерфейс для работы с СУБД\nlibrary(configr) # чтение конфига\nlibrary(readr)   # чтение текстовых SQL файлов\nlibrary(RSQLite) # драйвер для подключения к SQLite\n\n# директория проекта\nsetwd(Sys.getenv('TG_BOT_PATH'))\n\n# чтение конфига\ncfg <- read.config('config.cfg')\n\n# подключение к SQLite\ncon <- dbConnect(SQLite(), cfg$db_settings$db_path)\n\n# Создание таблиц в базе\ndbExecute(con, statement = read_file('create_db_data.sql'))\ndbExecute(con, statement = read_file('create_db_state.sql'))"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"пишем-функции-для-работы-с-базой-данных","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.7 Пишем функции для работы с базой данных","text":"У нас уже готов файл конфигурации и создана база данных. Теперь необходимо написать функции для чтения и записи данных в эту базу.Если вы скачали проект из GitHub, то функции вы можете найти в файле db_bot_function.R.Мы создали 4 простые функции:\n* get_state() - получить текущее состояние чата из БД\n* set_state() - записать текущее состояние чата в БД\n* get_chat_data() - получить данные отправленные пользователем\n* set_chat_data() - записать данные полученные от пользователяВсе функции достаточно простые, они либо читают данные из базы с помощью команды dbGetQuery(), либо совершают UPSERT операцию (изменение существующих данных или запись новых данных в БД), с помощью функции dbExecute().Синтаксис UPSERT операции выглядит следующим образом:Т.е. в наших таблицах поле chat_id имеет ограничение по уникальности и является первичным ключом таблиц. Изначально мы пробуем добавить информацию в таблицу, и получаем ошибку если данные по текущему чату уже присутствуют, в таком случае мы просто обновляем информацию по данному чату.Далее эти функции мы будем использовать в методах и фильтрах бота.","code":"\n# ###########################################################\n# Function for work bot with database\n\n# получить текущее состояние чата\nget_state <- function(chat_id) {\n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  chat_state <- dbGetQuery(con, str_interp(\"SELECT state FROM chat_state WHERE chat_id == ${chat_id}\"))$state\n  \n  return(unlist(chat_state))\n  \n  dbDisconnect(con)\n}\n\n# установить текущее состояние чата\nset_state <- function(chat_id, state) {\n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  # upsert состояние чата\n  dbExecute(con, \n            str_interp(\"\n            INSERT INTO chat_state (chat_id, state)\n                VALUES(${chat_id}, '${state}') \n                ON CONFLICT(chat_id) \n                DO UPDATE SET state='${state}';\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n}\n\n# запись полученных данных в базу\nset_chat_data <- function(chat_id, field, value) {\n  \n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  # upsert состояние чата\n  dbExecute(con, \n            str_interp(\"\n            INSERT INTO chat_data (chat_id, ${field})\n                VALUES(${chat_id}, '${value}') \n                ON CONFLICT(chat_id) \n                DO UPDATE SET ${field}='${value}';\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n}\n\n# read chat data\nget_chat_data <- function(chat_id, field) {\n  \n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  # upsert состояние чата\n  data <- dbGetQuery(con, \n                     str_interp(\"\n            SELECT ${field}\n            FROM chat_data\n            WHERE chat_id = ${chat_id};\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n  return(data[[field]])\n  \n}INSERT INTO chat_data (chat_id, ${field})\nVALUES(${chat_id}, '${value}') \nON CONFLICT(chat_id) \nDO UPDATE SET ${field}='${value}';"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"методы-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.8 Методы бота","text":"Следующим шагом в построении нашего бота будет создание методов. Если вы скачали проект с GitHub, то все методы находятся в файле bot_methods.R.Мы создали 5 методов:start - Запуск диалогаstate - Получить текущее состояние чатаreset - Сбросить текущее состояние чатаenter_name - Бот запрашивает ваше имяenter_age - Бот запрашивает ваш возрастМетод start запрашивает ваше имя, и переводит состояние чата в wait_name, т.е. в режим ожидания ввода вашего имени.Далее, вы отправляете имя и оно обрабатывается методом enter_name, бот с вами здоровается, записывает полученное имя в базу, и переводит чат в состояние wait_age.На этом этапе бот ждёт от вас ввода вашего возраста. Вы отправляете ваш возраст, бот проверяет сообщение, если вы вместо числа отправили какой-то текст он скажет: Ты ввёл некорректные данные, введи число, и будет ждать от вас повторного ввода данных. В случае если вы отправили число, бот сообщит о том, что он принял ваш возраст, запишет полученные данные в базу, сообщит все полученные от вас данные и переведёт состояние чата в исходное положение, т.е. в start.Вызвав метод state вы в любой момент можете запросить текущее состояние чата, а методом reset перевести чат в исходное состояние.","code":"\n# ###########################################################\n# bot methods\n\n# start dialog\nstart <- function(bot, update) {\n  \n  # \n  \n  # Send query\n  bot$sendMessage(update$from_chat_id(), \n                  text = \"Введи своё имя\")\n  \n  # переключаем состояние диалога в режим ожидания ввода имени\n  set_state(chat_id = update$from_chat_id(), state = 'wait_name')\n  \n}\n\n# get current chat state\nstate <- function(bot, update) {\n  \n  chat_state <- get_state(update$from_chat_id())\n  \n  # Send state\n  bot$sendMessage(update$from_chat_id(), \n                  text = unlist(chat_state))\n  \n}\n\n# reset dialog state\nreset <- function(bot, update) {\n  \n  set_state(chat_id = update$from_chat_id(), state = 'start')\n  \n}\n\n# enter username\nenter_name <- function(bot, update) {\n  \n  uname <- update$message$text\n  \n  # Send message with name\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(uname, \", приятно познакомится, я бот!\"))\n  \n  # Записываем имя в глобальную переменную\n  #username <<- uname\n  set_chat_data(update$from_chat_id(), 'name', uname) \n  \n  # Справшиваем возраст\n  bot$sendMessage(update$from_chat_id(), \n                  text = \"Сколько тебе лет?\")\n  \n  # Меняем состояние на ожидание ввода имени\n  set_state(chat_id = update$from_chat_id(), state = 'wait_age')\n  \n}\n\n# enter user age\nenter_age <- function(bot, update) {\n  \n  uage <- as.numeric(update$effective_message()$text)\n  \n  # проверяем было введено число или нет\n  if ( is.na(uage) ) {\n    \n    # если введено не число то переспрашиваем возраст\n    bot$sendMessage(update$from_chat_id(), \n                    text = \"Ты ввёл некорректные данные, введи число\")\n    \n  } else {\n    \n    # если введено число сообщаем что возраст принят\n    bot$sendMessage(update$from_chat_id(), \n                    text = \"ОК, возраст принят\")\n    \n    # записываем глобальную переменную с возрастом\n    #userage <<- uage\n    set_chat_data(update$from_chat_id(), 'age', uage) \n    \n    # сообщаем какие данные были собраны\n    username <- get_chat_data(update$from_chat_id(), 'name')\n    userage  <- get_chat_data(update$from_chat_id(), 'age')\n    \n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Тебя зовут \", username, \" и тебе \", userage, \" лет. Будем знакомы\"))\n    \n    # возвращаем диалог в исходное состояние\n    set_state(chat_id = update$from_chat_id(), state = 'start')\n  }\n  \n}"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"фильтры-сообщений","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.9 Фильтры сообщений","text":"В нашем случае это одна из наиболее важных частей в построении бота. Именно с помощью фильтров сообщений бот будет понимать какую информацию он от вас ждёт, и как её надо обрабатывать.В проекте на GitHub фильтры прописаны в файле message_filters.R.Код фильтров сообщений:В фильтрах мы используем написанную ранее функцию get_state(), для того, что бы запрашивать текущее состояние чата. Данна функция требует всего 1 аргумент, id чата.Далее фильтр wait_name обрабатывает сообщения когда чат находится в состоянии wait_name, и соответственно фильтр wait_age обрабатывает сообщения когда чат находится в состоянии wait_age.","code":"\n# ###########################################################\n# message state filters\n\n# фильтр сообщений в состоянии ожидания имени\nMessageFilters$wait_name <- BaseFilter(function(message) {\n  get_state( message$chat_id )  == \"wait_name\"\n}\n)\n\n# фильтр сообщений в состоянии ожидания возраста\nMessageFilters$wait_age <- BaseFilter(function(message) {\n  get_state( message$chat_id )   == \"wait_age\"\n}\n)"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"обработчики","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.10 Обработчики","text":"Файл с обработчиками называется handlers.R, и имеет следующий код:Сначала мы создаём обработчики команд, которые позволят вам запускать методы для начала диалога, его сброса, и запроса текущего состояния.Далее мы создаём 2 обработчика сообщений с использованием созданных на прошлом шаге фильтров, и добавляем к ним фильтр !MessageFilters$command, для того, что бы мы в любом состоянии чата могли использовать команды.","code":"\n# ###########################################################\n# handlers\n\n# command handlers\nstart_h <- CommandHandler('start', start)\nstate_h <- CommandHandler('state', state)\nreset_h <- CommandHandler('reset', reset)\n\n# message handlers\n## !MessageFilters$command - означает что команды данные обработчики не обрабатывают, \n## только текстовые сообщения\nwait_age_h  <- MessageHandler(enter_age,  MessageFilters$wait_age  & !MessageFilters$command)\nwait_name_h <- MessageHandler(enter_name, MessageFilters$wait_name & !MessageFilters$command)"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"код-запуска-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.11 Код запуска бота","text":"Теперь у нас всё готово к запуску, основной код запуска бота находится в файле bot.R.В любой момент с помощью команды /state мы можем запрашивать текущее состояние чата, а с помощью команды /reset переводить чат в исходное состояние и начинать диалог заново.","code":"\nlibrary(telegram.bot)\nlibrary(tidyverse)\nlibrary(RSQLite)\nlibrary(DBI)\nlibrary(configr)\n\n# переходим в папку проекта\nsetwd(Sys.getenv('TG_BOT_PATH'))\n\n# читаем конфиг\ncfg <- read.config('config.cfg')\n\n# создаём экземпляр бота\nupdater <- Updater(cfg$bot_settings$bot_token)\n\n# Загрузка компонентов бота\nsource('db_bot_function.R') # функции для работы с БД\nsource('bot_methods.R')     # методы бота\nsource('message_filters.R') # фильтры сообщений\nsource('handlers.R') # обработчики сообщений\n\n# Добавляем обработчики в диспетчер\nupdater <- updater +\n  start_h +\n  wait_age_h +\n  wait_name_h +\n  state_h +\n  reset_h\n\n# Запускаем бота\nupdater$start_polling()"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"заключение-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.12 Заключение","text":"В этой главе мы разобрались как использовать внутри бота базы данных, и как строить последовательные логические диалоги за счёт фиксации состояния чата.В данном случае мы рассмотрели самый примитивный пример, для того, что бы вам проще было понять идею построения таких ботов, на практике вы можете строить гораздо более сложные диалоги.В следующей статье из этой серии мы научимся ограничивать пользователям бота права на использования различных его методов.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"тесты-и-задания-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.3 Тесты и задания","text":"","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"тесты-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.3.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"задания-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.3.2 Задания","text":"Постройте бота который будет поддерживать игру угадай число. Т.е. по команде /start бот будет загадывать число от 1 до 50. Далее у вас будет 5 попыток угадать это число.Вы по очереди в каждой из попыток вводите числа, если введённое число меньше чем то, которое загадал бот то бот пишет “моё число больше”, иначе бот пишет “моё число меньше”. Если вы ввели правильное число то бот пишет что вы выйграли, и переводит диалог в исходное состояние.Если вы всё сделали правильно, бот будет выглядеть так:Победа с 5 попытки:Пройгрыш\n","code":""},{"path":"управление-правами-пользователей-бота.html","id":"управление-правами-пользователей-бота","chapter":"Глава 5 Управление правами пользователей бота","heading":"Глава 5 Управление правами пользователей бота","text":"В этой главе мы разберёмся с тем, как управлять правами использования отдельных методов бота на различных уровнях.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"введение-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.1 Введение","text":"Ваш бот может выполнять совершенно любые задачи, и автоматизировать как некоторые внутренние процессы, так и наладить коммуникации с клиентами.Т.е. бот может использоваться в многопользовательском режиме. При этом, вам может понадобиться разграничить права на использование бота. Например, некоторые пользователи смогут использовать абсолютно все возможности бота, а некоторым вы предоставите ограниченные права.Ограничить права можно не только на уровне пользователя, но и на уровне отдельных чатов.Мы создадим простейшего бота, у которого в арсенале будет всего 2 метода:say_hello - команда приветствияwhat_time - команда, по которой бот сообщает текущую дату и времяЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather (о создании бота я рассказывал в первой статье).В данной главе мы разберёмся с тем, как разными способами, и на разных уровнях ограничить использование методов этого бота.","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\",\n                  reply_to_message_id = update$effective_message()$message_id)\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # Запрашиваем текущее время\n  cur_time <- as.character(Sys.time())\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Текущее время, \", cur_time),\n                                parse_mode = \"Markdown\",\n                                reply_to_message_id = update$effective_message()$message_id)\n                  \n  \n}\n\n# обработчики\nh_hello <- CommandHandler('say_hello', say_hello)\nh_time  <- CommandHandler('what_time', what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-пользователя-с-помощью-фильтров-сообщений","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.2 Ограничиваем права пользователя с помощью фильтров сообщений","text":"Из предыдущих публикаций мы уже разобрались с тем, что такое фильтры сообщений. Но ранее мы использовали их в основном для, того, что бы вызывать какие-то методы бота через обычное сообщение, а не команду и для прослушиваний сообщений в определённом состоянии чата.В этот раз мы научимся с помощью фильтров ограничивать возможности по использованию методов бота, на разных уровнях.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-имени-пользователя","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.2.1 Ограничиваем права на уровне имени пользователя","text":"Для создания собственных фильтров вам необходимо с помощью функции BaseFilter() добавить новый элемент в объект MessageFilters. Более подробно об этом я рассказывал во второй статье из данной серии.В анонимную функцию, которую вы прописываете внутри BaseFilter() передаётся всего один аргумент - message. Это сообщение которое вы, или другой пользователей отправляет боту, со всеми его метаданными. Данный объект имеет следующую структуру:Более подробно описание ответа и всех его компонентов можно узнать из официальной документации:User - Этот объект представляет бота или пользователя Telegram.Chat - Этот объект представляет собой чат.Message - Этот объект представляет собой сообщение.Соответственно вы можете разделять права пользователей бота, и его методов используя любую, отправляемую с сообщением информацию, т.е. любые элементы объекта message. Для того, что бы ограничить круг пользователей которые могут использовать методы вашего бота достаточно создать фильтр:Где c('AlexeySeleznev', 'user1', 'user2') - вектор, с именами пользователей, которые могут использовать все функции бота. Далее этот фильтр мы используем при создании обработчиков.Теперь нашего бота могут использовать пользователи с логинами AlexeySeleznev, user1, user2. На сообщения отправленные боту другими пользователями он никак не будет реагировать.Изменённый код нашего бота на данный момент выглядит вот так:","code":"$message_id\n[1] 1174\n\n$from\n$from$id\n[1] 194336771\n\n$from$is_bot\n[1] FALSE\n\n$from$first_name\n[1] \"Alexey\"\n\n$from$last_name\n[1] \"Seleznev\"\n\n$from$username\n[1] \"AlexeySeleznev\"\n\n$from$language_code\n[1] \"ru\"\n\n\n$chat\n$chat$id\n[1] 194336771\n\n$chat$first_name\n[1] \"Alexey\"\n\n$chat$last_name\n[1] \"Seleznev\"\n\n$chat$username\n[1] \"AlexeySeleznev\"\n\n$chat$type\n[1] \"private\"\n\n\n$date\n[1] 1601295189\n\n$text\n[1] \"отправленный пользователем текст\"\n\n$chat_id\n[1] 194336771\n\n$from_user\n[1] 194336771\n## список пользователей, с полными правами\nMessageFilters$admins <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$effective_user()$username %in% c('AlexeySeleznev', 'user1', 'user2')\n    \n }\n)\n## фильтр для вызова команды say_hello\nMessageFilters$say_hello <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/say_hallo'\n    \n  }\n)\n\n## фильтр для вызова команды what_time\nMessageFilters$what_time <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/what_time'\n    \n  }\n)\n\n\n# обработчики\nh_hello <- MessageHandler(say_hello, MessageFilters$admins & MessageFilters$say_hello)\nh_time  <- MessageHandler(what_time, MessageFilters$admins & MessageFilters$what_time)\nlibrary(telegram.bot)\n\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\",\n                  reply_to_message_id = update$effective_message()$message_id)\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # Запрашиваем текущее время\n  cur_time <- as.character(Sys.time())\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Текущее время, \", cur_time),\n                                parse_mode = \"Markdown\",\n                                reply_to_message_id = update$effective_message()$message_id)\n                  \n  \n}\n\n# фильтры\n## список пользователей, с полными правами\nMessageFilters$admins <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$from$username %in% c('AlexeySeleznev', 'user1', 'user2')\n    \n }\n)\n\n## фильтр для вызова команды say_hello\nMessageFilters$say_hello <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/say_hallo'\n    \n  }\n)\n\n## фильтр для вызова команды what_time\nMessageFilters$what_time <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/what_time'\n    \n  }\n)\n\n\n# обработчики\nh_hello <- MessageHandler(say_hello, MessageFilters$admins & MessageFilters$say_hello)\nh_time  <- MessageHandler(what_time, MessageFilters$admins & MessageFilters$what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-чата","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.2.2 Ограничиваем права на уровне чата","text":"Тем же способом мы можем создать фильтр не только по списку пользователей, но и по конкретному чату. Для этого достаточно создать ещё один фильтр:","code":"\n## список чатов в которых разрешено использовать бота\nMessageFilters$chats <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$chat_id %in% c(194336771, 0, 1)\n    \n  }\n)\n\n\n## фильтр для вызова команды say_hello\nMessageFilters$say_hello <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/say_hallo'\n    \n  }\n)\n\n## фильтр для вызова команды what_time\nMessageFilters$what_time <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/what_time'\n    \n  }\n)\n\n\n# обработчики\nh_hello <- MessageHandler(say_hello, MessageFilters$admins & MessageFilters$chats & MessageFilters$say_hello)\nh_time  <- MessageHandler(what_time, MessageFilters$admins & MessageFilters$chats & MessageFilters$what_time)"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-пользователя-внутри-кода-методов","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.3 Ограничиваем права пользователя внутри кода методов","text":"Так же вы можете ограничить использование методов не прибегая к созданию дополнительных фильтров, а прописав все условия внутри каждого метода.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-имени-пользователя-1","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.3.1 Ограничиваем права на уровне имени пользователя","text":"Давайте создадим функцию, которая будет принимать данные для проверки имени пользователя.В аргумент admins далее нам надо передавать список пользователей, которым разрешено использовать данный метод, а в аргумент username имя пользователя, которого надо проверить в списке.Далее в каждый метод, который мы хотим защитить с помощью конструкции добавляем проверку, разрешено пользователю использовать данный метод или нет. В случае если у пользователя нет таких прав бот будет сообщать об этом в чате.Давайте, для примера, я исключу себя из списка пользователей, которым разрешено использовать метод what_time.Результат будет следующим:Теперь бот не просто игнорирует сообщения от обычных пользователей, а сообщает им, что у них недостаточно прав использовать какой либо метод.","code":"\n# функция для проверки прав пользователя\nbot_check_usernames <- \n  function(admins, username) {\n  \n   username %in% admins \n  \n}\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$username\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('AlexeySeleznev', 'user1', 'user2'), user_name) ) {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n      \n  } else {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('user1', 'user2'), update$effective_user()$username) ) {\n      \n    # Запрашиваем текущее время\n    cur_time <- as.character(Sys.time())\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$message$chat_id, \n                    text = paste0(\"Текущее время, \", cur_time),\n                                  parse_mode = \"Markdown\",\n                                  reply_to_message_id = update$effective_message()$message_id)\n  } else {\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$message$chat_id, \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n                  \n  \n}\n\n# обработчики\nh_hello <- CommandHandler('say_hello', say_hello)\nh_time  <- CommandHandler('what_time', what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-чата-1","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.3.2 Ограничиваем права на уровне чата","text":"Думаю у вас уже не возникнет трудностей при доработке ваших методов, таким образом, что бы их можно было использовать только в определённых чатах, тем не менее приведу пример.Напишем функцию, которая будет проверять входит ли текущий чат в список разрешенных.Далее используем эту функции внутри наших методов:","code":"\nbot_check_chat_id <- \n  function(allowed_chats, current_chat) {\n\n     current_chat %in% allowed_chats \n    \n}\nlibrary(telegram.bot)\n\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$message$from$username\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('AlexeySeleznev', 'user1', 'user2'), user_name) \n       &\n       bot_check_chat_id(c(194336771, 1, 2), update$from_chat_id())) {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n      \n  } else {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('AlexeySeleznev', 'user1', 'user2'), update$message$from$username)\n       &\n       bot_check_chat_id(c(194336771, 1, 2), update$message$chat_id)) {\n      \n    # Запрашиваем текущее время\n    cur_time <- as.character(Sys.time())\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Текущее время, \", cur_time),\n                                  parse_mode = \"Markdown\",\n                                  reply_to_message_id = update$effective_message()$message_id)\n  } else {\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n                  \n  \n}\n\n# обработчики\nh_hello <- CommandHandler('say_hello', say_hello)\nh_time  <- CommandHandler('what_time', what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"заключение-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.4 Заключение","text":"На этом серия статей о построении telegram ботов завершается. Я старался структурировать и подавать материал достаточно сжато, убрав всю воду, но при этом сделать так, что бы материал был вам понятен. Очень надеюсь на то, что мне это удалось.Успехов вам в ботостроении. В комментариях можете написать примеры ваших ботов, и как вы их на практике используете.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"тесты-и-задания-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.5 Тесты и задания","text":"","code":""},{"path":"управление-правами-пользователей-бота.html","id":"тесты-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.5.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"задания-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.5.2 Задания","text":"Возьмите задачу из второй главы, и ограничьте использование единственного метода, доступного в созданном боте, так, что бы он работал только когда его запрашиваете вы.","code":""},{"path":"повышаем-стабильность-работы-бота.html","id":"повышаем-стабильность-работы-бота","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"Глава 6 Повышаем стабильность работы бота","text":"К этому моменту вы знаете уже достаточно для того, что бы решить значительную часть своих задач по ботостроению. Простой бот будет работать достаточно стабильно, но всё равно иногда сервера API Telegram могут давать сбой. Даже если в вашем коде нет ошибок, и пользователи используют его правильно, иногда он может падать.В этой главе мы поговорим о том, как повысить работоспособность бота за счёт отлавливания и обработки ошибок пуллинга.","code":""},{"path":"повышаем-стабильность-работы-бота.html","id":"конструкция-trycatch","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.1 Конструкция tryCatch()","text":"Повысить работоспособность вашего бота поможет конструкция tryCatch(). Данная конструкция имеет следующий синтаксис:","code":"tryCatch(expr = {\n  \n    ~ Тут код который будет выполняться ~\n  \n}, \n  error = function(err) {\n    \n    ~ код который будет выполняться в случае возникновения ошибки в блоке expr ~\n    \n  }, \n  finally = {\n    \n    ~ Код который будет выполняться в любом случае, не зависимо от того закончилось выражение expr ошибкой или нет ~\n    \n  })"},{"path":"повышаем-стабильность-работы-бота.html","id":"логика-работы-конструкции-trycatch","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.2 Логика работы конструкции tryCatch()","text":"Из описанного синтаксиса понятно, что вам необходимо завернуть выражение в фигурные скобки в аргументе expr. Это выражение будет выполняться либо до тех пор, пока не встретится ошибка, либо если ошибки нет, оно будет выполнено полностью.Если в выражении переданном в expr встречается ошибка, то конструкция tryCath() запустит анонимную функцию, которую вы передали в блоке error.В любом случае, не зависимо от того, встретилась в выражении expr ошибка или нет, в завершении выполнения будет выполнен код, переданный в аргумент finally.Если вы хотите более подробно узнать про конструкцию tryCatch() посмотрите этот видео урок.","code":""},{"path":"повышаем-стабильность-работы-бота.html","id":"используем-trycatch-внутри-бота","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.3 Используем tryCatch() внутри бота","text":"По большому счёту вы можете использовать tryCatch() внутри каждой функции вашего бота. Но можно убить всех зайцев одним выстрелом.В разработке ботов слабым местом является пуллинг, т.е. метод updater$start_polling(). Пуллинг - это бесконечный цикл, именно он выполняется всё время работы бота, и даёт сбой если пользователь неправильно использовал бота, или API Telegram не отправил вам ответ. Соответственно если завернуть пуллинг в tryCatch(), и перезапускать вашего бота в бота в блоке finally то при любой ошибке он будет самостоятельно перезапускаться.Перед перезапуском бота не забывайте очистить его апдейты, что бы избавиться от ошибки, которая вызвала падение бота.Выглядеть такой пуллинг будет следующим образом:В приведённом выше коде вам необходимо подставить токен созданного вами бота, и указать ID чата, в который бот будет отправлять уведомление о падении пуллинга.В блок expr мы завернули процесс пуллинга, таким образом он постоянно контролируется конструкцией tryCatch.Далее в блок error мы передали безымянную функцию, которая принимает всего один аргумент err, т.е. саму ошибку. Сообщение об ошибке мы получаем через err$message, и отправляем в указанный чат. С помощью updater$bot$clean_updates() мы очищаем очередь апдейтов бота, т.к. последний апдейт вызвал ошибку и падение нашего бота.В блоке finally мы останавливаем пуллинг, и командой source('C:\\\\telegram_bot\\\\my_bot.R') занова запускаем скрипт с ботом.Такая схема позволяет боту очищаться и подниматься при любой ошибке пуллинга.Очищать апдейты бота с помощью комманды updater$bot$clean_updates() можно так же и при запуске бота, указав эту команду сразу, после инициализации объекта бота.","code":"\ntryCatch(\n  \n  # запускаем пуллинг\n  expr = updater$start_polling(), \n  \n  # действия при ошибке пуллинга\n  error = function(err) {\n    \n    # бот для оповещения\n    bot <- Bot(token = bot_token(\"Токен вашего бота\"))\n    \n    # чат для оповещения\n    chat_id <- \"Идентификатор чата в который необходимо отправить сообщение\"\n    \n    # сообщение\n    msg <- str_glue(\"*Бот упал*: Ошибка (_{err$message}_).\")\n    \n    bot$sendMessage(chat_id = chat_id, \n                    text = msg,\n                    parse_mode = 'Markdown')\n    \n    # очищаем полученный апдейт бота, который вызвал ошибку\n    updater$bot$clean_updates()\n    \n    # информация о том, что бот будет перезапущен\n    bot$sendMessage(chat_id = chat_id, \n                    text = str_glue('*Перезапускаю бота* в {Sys.time()}'),\n                    parse_mode = 'Markdown')\n\n    \n  }, \n  # действия которые будут выполненны в любом случае\n  finally = {\n    \n    # останавливаем пулинг\n    updater$stop_polling()\n        \n    # перезапускаем скрипт бота\n    source('C:\\\\telegram_bot\\\\my_bot.R') \n\n  }\n)"},{"path":"добавляем-боту-асинхронность.html","id":"добавляем-боту-асинхронность","chapter":"Глава 7 Добавляем боту асинхронность","heading":"Глава 7 Добавляем боту асинхронность","text":"","code":""},{"path":"добавляем-боту-асинхронность.html","id":"что-такое-асинхронное-программирование","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.1 Что такое асинхронное программирование","text":"По умолчанию созданные вами боты работают в параллельном, однопоточном режиме. Т.е. они выполняют заданные команды последовательно. Это не доставит никаких дополнительных трудностей если:ваш бот выполняет простейшие команды длительность работы которых не превышает 1 секунды;вашего бота использует всего несколько пользователей, и редко используют его одновременно.Асинхронность в программировании — выполнение процесса в неблокирующем режиме системного вызова, что позволяет потоку программы продолжить обработку.– tproger.ru","code":""},{"path":"добавляем-боту-асинхронность.html","id":"пример-последовательного-бота-с-поддержкой-длительных-команд","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.2 Пример последовательного бота с поддержкой длительных команд","text":"В этом разделе мы разберёмся с тем, как сделать нашего бота асинхронным, т.е. способным обрабатывать одновременно несколько команд, таким образом, что бы одна длительная команда, не блокировала работу боту на время её выполнения. Для демонстрации примера мы создадим бота с двумя простейшими командами:fast - быстрая команда, время выполнение которой менее 1 секунды.slow - команда, на выполнение которой боту требуется некоторое время, в нашем случае более 10 секунд.Для создания бота выполните приведённый ниже код:В многофункциональных ботах также можно разделить все команды на быстрые и медленные. Команды, которые бот выполняет мгновенно не требуют асинхронности, а вот команды реализующие длительные, дорогие вычисления, например запросы к API, лучше выполнять в параллельном, фоновом процессе не блокируя на период вычислений работу бота.Для демонстрации проблемы давайте попробуем запустить бота, по приведённому выше примеру кода.Изначально мы запустили медленную команду /slow, и не дожидаясь её выполнения отправили быструю команду /fast. Но, к выполнению команды /fast бот приступил только после того, как выполнил длительную команду /slow. Это видно из диалога, т.к. после того, как боту была отправлена команда /fast, он завершил работу команды /slow, сообщил нам “Медленная функция выполнена! ID процесса: 868”. Только после этого приступил к выполнению быстрой функции, сообщив “Быстрая функция, выполняется последовательный режим!ID процесса: 868”.Представьте ситуацию, если у вас одновременно 5 пользователей отправят вперемешку быстрые и длительные команды. В качестве эксперимента давайте отправим боту очередь команд:/slow/slow/fast/slow/fastВ данном случае не важно, эти команды запустил один пользователь или 5, выполняться они будут последовательно. Несмотря на то, что 5ая команда является быстрой, пользователю, который её отправил придётся ждать выполнения всех 4ёх, предыдущих команд. Если изобразить этот процесс схематически, и допустить, что быстрая команда выполняется за 1 секунду, а медленная за 10, то получится следующее:В последовательном режиме выполнения, несмотря на то, что 5ая по счёту команда требует всего 1 секунду на вычисления, она 31 секунду находится в ожидании, пока будут выполнены 4 предыдущие операции.","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\n\nupdater <- Updater(\"Токен вашего бота\")\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  # Сообщение о том, что начата работа длительного вычисления\n  bot$sendMessage(\n      update$message$chat_id,\n      text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n      parse_mode = \"Markdown\"\n  )\n  \n  # Добавляем паузу, для того, что бы исскусственно сделать функцию длительной\n  Sys.sleep(10)\n  \n  # Сообщаем о том, что все вычисления выполнены\n  bot$sendMessage(update$message$chat_id,\n      text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n      parse_mode = \"Markdown\")\n\n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# создаём обработчики\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + slow_hendler + fast_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-асинхронность.html","id":"многопоточность-в-r","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.3 Многопоточность в R","text":"В языке R есть множество реализаций многопоточности:foreachparallelfutureЭто далеко не полный перечень пакетов, которые позволяют вам производить вычисления в многопоточном режиме используя язык R. Для реализации многопоточности при разработке telegram ботов наиболее удобным является пакет future, о котором я подробно рассказывал в уроке “Пакет future” курса “Циклы и функционалы в языке R”. Крайне рекомендую пройти весь курс “Циклы и функционалы в языке R” для большего погружения в тему многопоточности. Т.к. в данном курсе мы не будет подробно рассматривать параллельное программирование.Пакет future позволяет вам, выполнять вычисления как в последовательном (обычном) режиме, так и в многопоточном. При этом данный пакет поддерживает несколько различных многопоточных режима:Изменять план выполнения вычислений можно с помощью future::plan(). Наиболее простым, и удобным для использования при построении telegram ботов многопоточный план вычислений - multisession. Данный план позволяет запускать на вашем локальном ПК параллельные R сеансы в фоновом режиме, после выполнения вычислений их результат импортируется в основной R сеанс.Далее, после переопределения плана вычислений, запустить вычисление в многопоточном режиме можно с помощью одноимённой функции future().","code":""},{"path":"добавляем-боту-асинхронность.html","id":"используем-future-для-построения-асинхронного-бота","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.4 Используем future для построения асинхронного бота","text":"Хочу обратить ваше внимание, когда мы в начале этого урока запустили бота в последовательном режиме, он с помощью функции Sys.getpid() получал, и выводил в сообщении идентификатор R сеанса, в ходе которого выполнялись все вычисления бота. Во всех представленных выше сообщение идентификатор процесса был одинаковым - 868. Это связано с тем, что все вычисления производились последовательно в рамках одного R сеанса.Ниже я приведу пример, доработанного бота, таким образом, что бы функция /slow запускалась в фоновом, параллельном R сеансе, и не блокировала работу бота. При этом функцию /fast мы оставим без изменений, т.к. она выполняется ботом достаточно быстро, и скорее всего накладные расходы на создание фонового сеанса будут больше, чем вычисление самой функции.Что мы изменили в коде бота:\n1. В начале скрипта, командой future::plan('multisession') мы переопределили план вычислений с последовательного на многопоточный. На самом деле весь код будет выполняться последовательно, кроме кода используемого внутри функции future().\n2. Весь код внутри функции бота slow_fun() мы завернули в future::future(), таким образом, при запуске медленной функции будет запускаться параллельный фоновый R процесс, и все вычисления данной функции будут выполняться там, не блокируя основной сеанс.Теперь давайте попробуем в параллельном режиме запустить такую же очередь команд, как и в предыдущем последовательном примере:Обратите внимание на то, что вычисление всех долгих команд /slow выполняются в разных процессах, бот выводит в каждом сообщение информацию “ID процесса: XX”. При этом вычисление быстрой команды /fast оба раза выполнялись в корневом процессе с id 868.Схематически весь процесс обработки команд, даже при одновременном их запуске, теперь выглядит так:В последовательном режиме выполнение всех команд заняло 32 секунды (10 + 10 + 1 + 10 + 1), в многопоточном всего 10 секунд. При этом даже в течении этих 10 секунд основной сеанс практически не был заблокирован, только на первые две секунды, когда в нём происходили вычисления быстрых команд /fast в последовательном режиме.","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\n\n# Включаем параллельный план вычислений\nfuture::plan('multisession')\n\nupdater <- Updater(\"Токен вашего бота\")\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  # Запускаем выполнение кода в параллельной сессии\n  future::future(\n    {\n      # Сообщение о том, что начата работа длительного вычисления\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n      \n      # Добавляем паузу, для того, что бы исскусственно сделать функцию длительной\n      Sys.sleep(10)\n      \n      # Сообщаем о том, что все вычисления выполнены\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n    }\n  )\n  \n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  \n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# создаём обработчик\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + slow_hendler + fast_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-асинхронность.html","id":"управление-количеством-потоков","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.5 Управление количеством потоков","text":"По умолчанию функция future::plan() при изменении плана с последовательного на многопоточный автоматически определяет оптимальное количество потоков, т.е. фоновых процессов, которые будут доступны в фоновом режиме. По умолчанию будет создано столько процессов, сколько ядер доступно в процессоре вашего ПК. Программно можно посмотреть количество доступных ядер следующим образом:В моём случае одновременно будет доступно 8 фоновых R сеансов. Для большинства задач этого будет достаточно, но в функции future::plan() доступен аргумент workers, который позволяет самостоятельно задать необходимое количество фоновых процессов.Приведённый выше код демонстрирует сокращение количества доступных процессов до 4ёх.","code":"\nfuture::availableCores()## system \n##      8\nfuture::plan('multisession', workers = 4)"},{"path":"добавляем-боту-асинхронность.html","id":"функция-promisesfuture_promise","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.6 Функция promises::future_promise()","text":"Пакет promises часто используется в связке с future органично дополняя его.В приведённых выше практических примерах нам было достаточно количества созданных фоновых потоков. Но всегда есть вероятность того, что все потоки будут заняты. Например, мы включили мультисессионый режим вычислений с двумя потоками (workers = 4) и бот получил практически одновременно 3 команды /slow. В таком случае первые две команды уйдут выполняться в фоновые процессы, а третья, и последующие встанут в очередь ожидания свободного процесса, заняв при этом основной процесс. В такой ситуации до тех пор, пока не появится свободный процесс, основной процесс будет заблокирован, и даже при попытке отправить быструю функцию /fast, она будет также поставлена в очередь.Решить эту проблему можно с помощью функции promises::future_promise(). Преимущество promises::future_promise() перед future::future(), заключается в том, что даже если нет свободных потоков, созданная очередь не будет блокировать основной поток, она будет создана так же в фоновом потоке. Для доработки приведенного ранее примера достаточно просто заменить в коде функции slow() функцию future::future() на promises::future_promise().","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\n\n# Включаем параллельный план вычислений\nfuture::plan('multisession')\n\nupdater <- Updater(\"Токен вашего бота\")\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  # Запускаем выполнение кода в параллельной сессии\n  promises::future_promise(\n    {\n      # Сообщение о том, что начата работа длительного вычисления\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n      \n      # Добавляем паузу, для того, что бы исскусственно сделать функцию длительной\n      Sys.sleep(10)\n      \n      # Сообщаем о том, что все вычисления выполнены\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n    }\n  )\n  \n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  \n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# создаём обработчик\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\n\n# добаляем добавляем в диспетчер\nupdater <- updater + slow_hendler + fast_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-асинхронность.html","id":"заключение-5","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.7 Заключение","text":"Итак, для того, что бы ваш бот умел одновременно обрабатывать входящие команды необходимо:Выявить список команд, требующих длительных вычислений.В начале скрипта добавить команду future::plan('multisession'), для того, что бы у вас была возможность запускать вычисление длительных операций в фоновых, параллельных R сеансах.Код методов бота, которые требуют длительных вычислений заворачиваем в future::future().Улучшить многопоточность бота можно заменив функцию future::future() на promises::future_promise(), которая оставляет свободным основной поток R, даже если все фоновые потоки заняты.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"упаковываем-бота-в-docker-контейнер","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"Глава 8 Упаковываем бота в Docker контейнер","text":"","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"что-такое-докер","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.1 Что такое докер","text":"Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений. Позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер.Docker предназначен для заключения сред внутри образа/контейнера. Это позволяет, например, иметь компьютер с Linux на Windows или компьютер с R 3.3, когда на вашем основном компьютере установлен R 3.5. Кроме того, это означает, что вы можете использовать более старые версии пакета для конкретной задачи, сохраняя при этом пакет на вашем компьютере в актуальном состоянии.Т.е. вы можете запустить бота в абсолютно изолированной среде, на которой будет предустановлены всё необходимое ПО, настроены переменные окружения, и она никак не будет зависеть от внешних настроек вашей операционной системы. Соответственно, при запуске контейнера по созданному образу на любой другой машине, вам не придётся её каким либо образом предварительно настраивать, прописывать переменные среды, устанавливать нужные пакеты, устанавливать сам язык R и т.д.В этом учебнике мы не будем подробно изучать сам Docker, т.к. это отдельная большая тема, а учебник у нас по разработке telegram ботов, а не работе с Docker. Но в интернете вы без проблем найдёте огромное количество статей и видео уроков, которые помогут вам глубже погрузиться в изучение возможностей Docker, несколько полезных ссылок я приведу в завершении данной главы. Здесь же мы лишь рассмотрим рабочий процесс упаковки и запуска бота написанного на языке R. В нашем случае мы рассмотрим рабочий процесс упаковки на примере ОС Windows 10 Home, но на других ОС процесс будет отличаться не значительно.Описанные в этой главе приёмы универсальны, по такому же принципу можно упаковать в Docker и запустить любой R скрипт.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"установка-docker","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.2 Установка Docker","text":"Для начала вам необходимо скачать и установить Docker на свой ПК. Тут есть некоторый нюанс, дело в том, что для Windows есть два варианта Docker:Docker WindowsDocker Toolbox WindowsКакую версию выбрать вам:Если у вас Windows 10 x64 Pro, Enterprise или Education то включаем службу Hyper-V и ставим Docker Windows.Если же у вас другая версия Windows(7 Pro, 8, 8.1, 10 Home) то ставим Virtual Box и Docker Toolbox Windows.У меня Windows 10 Home, если у вас тоже то перейдите по ссылке, скачайте инсталлятор для своей операционной системы и запустите процесс установки.У меня никаких дополнительных манипуляций процесс установки не потребовал, но в случае возникновения каких либо сложностей, я рекомендую найти на YouTube урок по установке Docker на вашу операционную систему. Например, в этом видео рассматривается процесс установки как Docker Windows, так и Docker Toolbox Windows.Все приведённые ниже примеры использовались с Docker Toolbox Windows.По завершению установки запустите Docker Quickstart Terminal, ярлык вы найдёте на рабочем столе.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"создаём-проект-в-rstudio","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.3 Создаём проект в RStudio","text":"Для удобства работы я рекомендую создать проект.Открываем RStudio и создаём новый проект. Перейдите в меню file -> New Project....Далее выбираем “New project” и указываем имя проекта.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"код-бота","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.4 Код бота","text":"В данном случае нам не особо важен функционал нашего бота, поэтому мы просто возьмём код асинхронного бота из 7ой главы этого учебника, но предварительно немного его доработали:Мы добавили команду очистки очереди бота от старых сообщений, сразу после его инициализации.Добавили боту две новые команды:\n/stop - Команда остановки бота.\n/crush - Команда с ошибкой, имитирующая падение бота.\n/stop - Команда остановки бота./crush - Команда с ошибкой, имитирующая падение бота.Добавили боту процесс логирования его работы в обычный текстовый файл bot.log.Все эти доработки нам потребовались для демонстрации некоторых дополнительных возможностей, которые даёт Docker.Меню file -> New file -> R script (или сочетание клавиш Ctrl+Shift+N). Далее скопируйте приведённый ниже код бота, и сохраните его с именем bot.R.Обратите внимание, я явно указал количество потоков future::plan('multisession', workers = 4), т.к. в контейнере по умолчанию функция plan() определит всего 1 ядро, и соответственно бот будет запущен в последовательном режиме работы.","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\nlibrary(lgr)\n\n# Включаем логгер\nlg <- get_logger()\nlg$set_appenders(AppenderFile$new(file = 'log/bot.log'))\nlg$info('Bot start')\n\n# Включаем параллельный план вычислений\nlg$info('Run multisession mode')\nfuture::plan('multisession', workers = 4)\n\n# Инициализируем бота\nlg$info('Make updater')\nupdater <-  Updater(bot_token('botname'))\n# Очищаем очередь бота от старых сообщений\nlg$info('Clean update queue')\nupdater$bot$clean_updates()\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  lg$info('Run slow command')\n  # Запускаем выполнение кода в параллельной сессии\n  promises::future_promise(\n    {\n      # Сообщение о том, что начата работа длительного вычисления\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n      \n      # Добавляем паузу, для того, что бы искусственно сделать функцию длительной\n      Sys.sleep(10)\n      \n      # Сообщаем о том, что все вычисления выполнены\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n    }\n  )\n  \n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  lg$info('Run fast command')\n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# Остановка пуллинга\nstop <- function(bot, update) {\n  \n  lg$info('Bot stop')\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Останавливаю работу бота!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  # Просто отправляем сообщение\n  updater$stop_polling()\n  \n}\n\n# Функция с ошибкой, имитирующая падение бота\ncrush <- function(bot, update) {\n  \n  lg$info('Crush command')\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Функция с ошибкой, сбой в работе бота!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n  stop(\"Ошибка, сбой бота!\")\n  \n}\n\n# создаём обработчик\nlg$info('Make handlers')\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\nstop_hendler <- CommandHandler('stop', stop)\ncrush_hendler <- CommandHandler('crush', crush)\n\n# добавляем в диспетчер\nlg$info('Add handlers to dispatcher')\nupdater <- updater + slow_hendler + fast_hendler + stop_hendler + crush_hendler\n\n# запускаем бота\nlg$info('Run polling')\nupdater$start_polling()"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"образы-и-контейнеры","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.5 Образы и контейнеры","text":"В основе работы Docker лежат образы и созданные из них контейнеры. Образы — это описание среды и её настроек, необходимых для работы вашего бота (R, пакеты, переменные среды), а контейнеры — это фактически запущенные экземпляры образов. Образ создаётся один раз, а контейнеры будут запускаться всякий раз, когда вам необходимо запустить бота. И, конечно же, одновременно можно запускать несколько контейнеров с одними и теми же образами.Применительно к R, это тот же принцип, что установка и загрузка пакета. Для начала вам необходимо один раз установить пакет командой install.packages(), а потом подключать его командой library() каждый раз, когда вам требуется его функционал. И пакет можно легко запустить в нескольких сеансах R одновременно.Продолжая аналогию с пакетами, создание образа по смыслу схоже на команду install.packages(), а запуск контейнера на основе образа по смыслу близко к команде library().","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"создание-dockerfile","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.6 Создание Dockerfile","text":"Docker образ создаётся из Dockerfile. По сути это обычный текстовый файл, без расширения, в котором вы прописываете команды для развёртывания нужной для запуска вашего бота среды.Теперь необходимо создать в рабочей директории проекта обычный текстовый файл, и дать ему имя Dockerfile.Докер файл будет содержать следующие команды:Тут давайте остановимся и разберём отдельно каждую команду:rocker/r-ver:4.2.1, создаёт среду с установленным R 4.2.1, вы можете указать любую, нужную вам версию R.RUN mkdir /home/bot и RUN mkdir /home/bot/log создаёт в контейнере папку bot, и папку log внутри неё.ENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА эта команда создаёт переменную среды R_TELEGRAM_BOT_botname внутри контейнера. В данную переменную передайте токен вашего бота.COPY bot.R /home/bot/bot.R копирует скрипт с кодом нашего бота в контейнер.RUN R -e \"install.packages(c('telegram.bot', 'stringr', 'future', 'promises','fastmap', 'lgr'))\", конструкция RUN R -e \"код на R\" позволяет запускать внутри контейнера R команды. В данном случае мы устанавливаем все, нужные нам пакеты.CMD cd /home/bot, команда, которая переключает рабочую директорию на /home/bot. Команда CMD запускается каждый раз, при запуске контейнера.&& R -e \"source('/home/analysis/bot.R')\", объединяется с предыдущей командой, и запускает скрипт бота.Если вам необходимы определённые версии используемых пакетов то вы можете заменить команду из 5 пункта на:Или установить пакет из снимка MRAN на определённую дату:","code":"FROM rocker/r-ver:4.2.1\n\nRUN mkdir /home/bot\nRUN mkdir /home/bot/log\n\nENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА\n\nCOPY bot.R /home/bot/bot.R\n\nRUN R -e \"install.packages(c('telegram.bot', 'stringr', 'future', 'promises','fastmap', 'lgr'))\"\n\nCMD cd /home/bot \\\n  &&  R -e \"source('/home/bot/bot.R')\"RUN R -e \"install.packages('remotes'); \\\n  remotes::install_version('package_name', '0.1.2')\"RUN R -e \"options(repos = \\\n  list(CRAN = 'http://mran.revolutionanalytics.com/snapshot/2022-08-01/')); \\\n  install.packages('package_name')\""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"создание-образа","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.7 Создание образа","text":"Теперь нам необходимо перейти в терминал, и запустить команду создания образа docker build. Данная команда требует от вас передачи нескольких параметров:-t - позволяет задать тег вашего образа;вторым параметром является путь к папке с Dockerfile, если вы создали Dockerfile в текущем рабочем каталоге проекта, то просто в качестве этого параметра передайте точку.Т.е. для создания образа перейдите в терминал (найти терминал можно на соседней вкладке с консолью в RStudio) и запустите в терминале (не в консоли RStudio, а именно в терминале!) следующую команду:","code":"docker build -t rbot ."},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"запуск-контейнера","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.8 Запуск контейнера","text":"Итак, теперь у нас уже есть собранный Docker образ с нашим ботом, и нам остаётся запустить его командой docker run. При запуске контейнера вам необходимо указать следующие параметры:--name позволяет задать название контейнера-d флаг, который запускает контейнер в фоновом режиме, не блокируя терминалпоследним параметром мы задаём имя образа, на основе которого будет запущен контейнер.Дополнительно мы могли указать флаг --rm, который автоматически удалит контейнер после его остановки.","code":"docker run --name my_bot -d rbotdocker run --name my_bot -d --rm rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"прокидываем-токен-бота-в-контейнер-при-его-запуске","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.9 Прокидываем токен бота в контейнер при его запуске","text":"В примере выше мы указывали токен нашего бота непосредственно в Dockerfile с помощью команды ENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА. Это не всегда удобно, например, вам может понадобиться возможность указывать токен бота непосредственно при запуске контейнера и вам не хочется постоянно редактировать Dockerfile. В таком случае вы можете прокидывать переменные среды при запуске контейнера используя флаг -e.Вы можете удалить из Dockerfile команду ENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА, и прокинуть эту же переменную непосредственно при запуске контейнера.","code":"docker run --name my_bot -d --rm -e R_TELEGRAM_BOT_botname=\"ТОКЕН_ВАШЕГО_БОТА\" rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"политика-перезапуска-бота","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.10 Политика перезапуска бота","text":"В главе “Повышаем стабильность работы бота” мы разобрались, как написать бота, который автоматически перезапускается в случае падения.При запуске бота через docker контейнер, у вас есть отдельная опция --restart, которая позволяет более гибко управлять перезапуском вашего бота. Данная опция принимает одно из следующих значений:- Не перезапускать контейнер после завершения. Это значение по умолчанию.-failure[:max-retries] - Перезапускает контейнер если он завершился с не нулевым статусом (т.е. завершился с ошибкой). Опционально можно указать количество попыток перезапуска. Это наиболее подходящая опция для работы бота, т.к. вы можете добавить боту метод остановки пуллинга, и он при запуске команды остановки успешно выключиться, а в случае аварийной остановки - будет перезапущен.always - Всегда перезапускает контейнер в не зависимости от статуса завершения. Когда вы выбираете данный вариант, Docker демон будет пытаться перезапустить контейнер бесконечное число раз. Также контейнер будет всегда запускаться при запуске демона, не зависимо от текущего состояния контейнера. В данном случае у вас не будет возможности остановить бота.unless-stopped - Всегда перезапускает контейнер не зависимо от статуса завершения, но контейнер не будет запускаться при запуске демона, если контейнер до этого был остановлен вручную.Т.е. следующая команда позволяет запустить бота, который автоматически будет перезапуска в случае ошибки, но при этом, вы в любой момент сможете остановить его любой командой.Давайте протестируем команду /crush и /stop, как я уже писал ранее, первая имитирует ошибку в работе бота, вторая же корректно останавливает его работу.Из скрина видно, что даже при выполнении команды /crush вызывающую критическую ошибку и падение бота, сам бот автоматически перезапускается, очищает очередь команд, и продолжает работу.Команда /stop при этом корректно останавливает работу бота.","code":"docker run --name my_bot -d --rm -e --restart=on-failure rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"просмотр-списка-запущенных-контейнеров","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.11 Просмотр списка запущенных контейнеров","text":"Команда docker ps позволяет посмотреть список запущенных в данный момент контейнеров.","code":"docker ps"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"остановка-контейнера","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.12 Остановка контейнера","text":"Для остановки контейнера используйте команду docker stop, передав в качестве единственного аргумента либо id, либо название контейнера, который необходимо остановить, в моём случае равнозначными будет две следующее команды:","code":"docker stop my_botdocker stop d06f8cebe987"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"удаление-контейнера","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.13 Удаление контейнера","text":"После остановки контейнера с ботом вы можете его удалить командой docker rm передав ей имя контейнера.","code":"docker rm my_bot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"публикация-образа-в-docker-hub","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.14 Публикация образа в Docker hub","text":"На данном этапе мы уже разобрались с тем, как устроен Docker, и узнали его основные команды. Но пока мы работали с образами, и запускали контейнеры локально, на ПК на котором мы эти образы собирали. Вся мощь Docker заключается в том, что собранные образы очень легко можно переносить на любой другой ПК, единственное требование - наличие на нём установленного Docker.Для такого переноса удобно использовать docker-hub, для начала перейдите по ссылке и зарегистрируйтесь там.Далее возвращаемся в терминал RStudio, логинимся в Docker-hub.Далее введите свой логин и пароль, или ключ API вместо пароля. Теперь нам необходимо добавить нужный тег нашему образу для его публикации. Команда tag принимает два аргумента, имя образа, которому надо присвоить тег, и сам тег. Присваиваемый тег должен иметь следующий вид username/repository, т.е. имя пользователя на Docker-hub и название репозитория, куда вы хотите опубликовать образ.Следующая команда позволяет опубликовать образ на Docker-hub:Теперь вы можете загрузить опубликованный ранее образ на любой ПК, независимо от того, какая на нём установлена операционная система, главное предварительно установите на него сам Docker. Используйте следующую команду, что бы забрать образ из Docker-hub:После чего образ будет загружен в ваш локальный реестр образов, убедиться в этом можно с помощью команды docker images. Процесс запуска контейнера из загруженного образа ничем не отличается от описанного выше в этой главе.Обратите внимание, если вы планируете опубликовать образ с публичным доступом, то не включайте в Dockerfile секретные данные, такие как токен бота или пароли. Рекомендованным способом передачи секретных данных в контейнер является прокинуть необходимые переменные с этими данными непосредственно при запуске контейнера как описано в разделе Прокидываем токен бота в контейнер при его запуске.","code":"docker logindocker tag rbot username/rbotdocker push username/rbotdocker pull username/rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"как-создать-общую-папку-для-хранения-файлов","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.15 Как создать общую папку для хранения файлов","text":"По умолчанию контейнер является полностью изолированным, т.е. все файлы, которые создаются внутри контейнера, удаляются после его запуска, и все данные которые были в эти файлы записаны, также удаляются.В ходе работы нашего бота пишется лог, сам файл лога bot.log создаётся внутри контейнера в папке log, и за пределами самого контейнера он не доступен. В коде нашего бота за создание лога отвечает следующие команды:Если вы до этого момента не знакомы с процессом логирования, то рекомендую либо ознакомиться со статьёй “Логирование выполнения скриптов на языке R, пакет lgr”, либо видео уроком “Логирование процесса выполнения скриптов на языке R (пакеты lgr / lgrExtra)”.В данном случае лог пишется в обычный текстовый файл. Но функционал может быть гораздо шире, чем в рассматриваемом нами примере, бот может работать с базой данных, может принимать какие-то файлы. И нам может потребоваться получить доступ к этим данным.Для того, что бы организовать на вашем ПК общую с каким либо контейнером папку в Docker есть понятие томов - volume. Но при работе на Windows требуется некоторая предварительная подготовка.Вместе с Docker toolbox вы установили несколько программ, включая Oracle VM Virtual Box. Запустите её, если у вас возникает ошибка при запуске VirtualBox, то скорее всего вам необходимо перейти по ссылке, и скачать наиболее актуальную версию.В Virtual Box выберите дефолтную машину и нажмите “Настроить”:Перейдите в меню “Общие папки” и создайте новую общую папку прописав ей путь и дав имя. В моём случае сама папка находится по пути D:\\packlab\\docker_bot\\log, и имя для неё я задал d/packlab/docker_bot/log:Теперь вернитесь в терминал RStudio и перезапустите виртуальную машину командой docker-machine restart.Теперь вернитесь в терминал RStudio и перезапустите виртуальную машину командой docker-machine restart.После перезагрузки, при запуске контейнера используйте флаг -v и укажите через двоеточие соответствие папки на локальном компьютере с папкой в контейнере. В нашем случае папка на локальном компьютере d/packlab/docker_bot/log должна быть связана с папкой /home/bot/log в контейнере. Команда будет выглядеть следующим образом:После перезагрузки, при запуске контейнера используйте флаг -v и укажите через двоеточие соответствие папки на локальном компьютере с папкой в контейнере. В нашем случае папка на локальном компьютере d/packlab/docker_bot/log должна быть связана с папкой /home/bot/log в контейнере. Команда будет выглядеть следующим образом:Обратите внимание, я указал двойной слеш // перед именем папки на локальном компьютере, без этого иногда при запуске контейнера возникает ошибка invalid value \"C:\\\\...\" flag -v: ...:... absolute path.Сразу после запуска у меня в локальной папке \"D:\\packlab\\docker_bot\\log\" создаётся файл bot.log, в котором в реальном времени пишется лог работы бота, давайте в этом убедимся:Содержание локального файла bot.log:Отставание на 4 часа между временем в telegram, и файлом лога объясняется тем, что в контейнере по умолчанию установлен другой часовой пояс - UTC.","code":"\nlibrary(lgr)\n\n# Включаем логгер\nlg <- get_logger()\nlg$set_appenders(AppenderFile$new(file = 'log/bot.log'))\nlg$info('Bot start')docker run --rm --name my_bot -v //d/packlab/docker_bot/log:/home/bot/log rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"полезные-ссылки","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.16 Полезные ссылки","text":"Как я уже писал в начале главы, в интернете полно информации по работе с Docker, тем не менее тут я приведу небольшую подборку ссылок, которые помогут вам получше с ним разобраться:Основы Docker. Большой практический выпускAn Introduction Docker R Users (англ.)Docker под Windows для разработки, разбор подводных камней","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"заключение-6","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.17 Заключение","text":"Теперь мы умеем упаковывать telegram ботов в контейнер, что даёт несколько следующих преимуществ:Вы легко можете перенести вашего бота с ноутбука на сервер, или переносить его между серверами, весь процесс займёт пару минут. Никакой предварительной настройки среды для запуска бота теперь не потребуется.У вас появляется более гибкая возможность управления политикой перезапуска бота.Основные команды docker и их параметры, которые вам понадобятся в ходе упаковки, запуска, публикации и загрузки бота:docker build - создать образ:\n-t - тег образа;\nвторой аргумент - путь к папке с Dockerfile.\n-t - тег образа;второй аргумент - путь к папке с Dockerfile.docker run - запуск контейнера:\n--name - имя контейнера;\n-d - запускает контейнер в фоновом режиме;\n--rm - автоматически удаляет контейнер после его остановки;\n-e - создаёт переменную окружения при запуске контейнера;\n--restart - управление политикой перезапуска контейнера;\n-v позволяет прикрепить к контейнеру физическую папку на вашем локальном ПК;\nпоследний аргумент - имя образа на основе которого будет запущен контейнер.\n--name - имя контейнера;-d - запускает контейнер в фоновом режиме;--rm - автоматически удаляет контейнер после его остановки;-e - создаёт переменную окружения при запуске контейнера;--restart - управление политикой перезапуска контейнера;-v позволяет прикрепить к контейнеру физическую папку на вашем локальном ПК;последний аргумент - имя образа на основе которого будет запущен контейнер.docker ps - просмотр списка запущенных контейнеров:\n-выводит список всех контейнеров, включая остановленные.\n-выводит список всех контейнеров, включая остановленные.docker stop - остановка контейнера:\nв качестве параметра необходимо передать имя или id контейнера.\nв качестве параметра необходимо передать имя или id контейнера.docker rm - удаление контейнера:\nв качестве параметра необходимо передать имя или id контейнера.\nв качестве параметра необходимо передать имя или id контейнера.docker login - авторизация в Docker-hub.docker tag - добавить тег образу:\nлокальное название образа, которому надо присвоить тег;\nназвание образа в docker-hub по шаблону username/repository.\nлокальное название образа, которому надо присвоить тег;название образа в docker-hub по шаблону username/repository.docker push - опубликовать образ в docker-hub:\nназвание образа в docker-hub по шаблону username/repository.\nназвание образа в docker-hub по шаблону username/repository.docker pull - забрать образ из docker-hub:\nназвание образа в docker-hub по шаблону username/repository.\nназвание образа в docker-hub по шаблону username/repository.","code":""},{"path":"обновления.html","id":"обновления","chapter":"Обновления","heading":"Обновления","text":"","code":""},{"path":"обновления.html","id":"section","chapter":"Обновления","heading":"2023-01-20","text":"В первую главу добавлено описание всех методов бота.Во вторую главу добавлено описание методов обновлений.Во вторую главу добавлена информация о том, как запросить у пользователя номер телефона или локацию.","code":""},{"path":"обновления.html","id":"section-1","chapter":"Обновления","heading":"2022-09-06","text":"Добавлена 8 глава “Упаковываем бота в Docker контейнер”.","code":""},{"path":"обновления.html","id":"section-2","chapter":"Обновления","heading":"2022-08-17","text":"Добавлена 7 глава “Добавляем боту асинхронность”.","code":""},{"path":"обновления.html","id":"section-3","chapter":"Обновления","heading":"2022-08-09","text":"Практически во все уроки добавлены видео;Учебник переведён в формат bs4;Добавлена странца обновлений курса;Все ихсходники проекта учебника залиты на github.","code":""},{"path":"решение-задач.html","id":"решение-задач","chapter":"Решение задач","heading":"Решение задач","text":"В этом разделе книги приведены решения всех, представленных в учебнике задач.","code":""},{"path":"решение-задач.html","id":"задача-1.1","chapter":"Решение задач","heading":"Задача 1.1","text":"Создайте с помощью BotFather бота.Перейдите к диалогу с ботом, и узнайте идентификатор вашего с ботом чата.Отправьте с помощью созданного бота в telegram первые 20 строк из встроенного в R набора данных ToothGrowth.Решение:","code":"\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(telegram.bot)\n\n# функция для перевода data.frame в telegram таблицу \nto_tg_table <- function( table, align = NULL, indents = 3, parse_mode = 'Markdown' ) {\n  \n  # если выравнивание не задано то выравниваем по левому краю\n  if ( is.null(align) ) {\n    \n    col_num <- length(table)\n    align   <- str_c( rep('l', col_num), collapse = '' )\n    \n  }\n  \n  # проверяем правильно ли заданно выравнивание\n  if ( length(table) != nchar(align) ) {\n    \n    align <- NULL\n    \n  }\n  \n  # новое выравнивание столбцов \n  side <- sapply(1:nchar(align), \n                 function(x) { \n                   letter <- substr(align, x, x)\n                   switch (letter,\n                           'l' = 'right',\n                           'r' = 'left',\n                           'c' = 'both',\n                           'left'\n                   )\n                 })\n  \n  # сохраняем имена\n  t_names      <- names(table)\n  \n  # вычисляем ширину столбцов\n  names_length <- sapply(t_names, nchar) \n  value_length <- sapply(table, function(x) max(nchar(as.character(x))))\n  max_length   <- ifelse(value_length > names_length, value_length, names_length)\n  \n  # подгоняем размер имён столбцов под их ширину + указанное в indents к-во пробелов \n  t_names <- mapply(str_pad, \n                    string = t_names, \n                    width  = max_length + indents, \n                    side   = side)\n  \n  # объединяем названия столбцов\n  str_names <- str_c(t_names, collapse = '')\n  \n  # аргументы для фукнции str_pad\n  rules <- list(string = table, width = max_length + indents, side = side)\n  \n  # поочереди переводим каждый столбец к нужному виду\n  t_str <-   pmap_df( rules, str_pad )%>%\n    unite(\"data\", everything(), remove = TRUE, sep = '') %>%\n    unlist(data) %>%\n    str_c(collapse = '\\n') \n  \n  # если таблица занимает более 4096 символов обрезаем её\n  if ( nchar(t_str) >= 4021 ) {\n    \n    warning('Таблица составляет более 4096 символов!')\n    t_str <- substr(t_str, 1, 4021)\n    \n  }\n  \n  # символы выделения блока кода согласно выбранной разметке\n  code_block <- switch(parse_mode, \n                       'Markdown' = c('```', '```'),\n                       'HTML' = c('<code>', '<\/code>'))\n  \n  # переводим в code\n  res <- str_c(code_block[1], str_names, t_str, code_block[2], sep = '\\n')\n  \n  return(res)\n}\n\n# создаём экземпляр бота\nbot <- Bot('1165649194:AAFkDqIzQ6Wq5GV0YU7PmEZcv1gmWIFIB_8')\n\n# получаем ID чата \n# (предварительно отправьте боту любое сообщение)\nchat_id <- bot$getUpdates()[[1]]$from_chat_id()\n\n# преоразуем таблицу ToothGrowth\nTG <- to_tg_table( head(ToothGrowth, 20) )\n\n# отправляем таблицу в Telegram\nbot$sendMessage(chat_id, \n                TG,\n                'Markdown')"},{"path":"решение-задач.html","id":"задача-2.1","chapter":"Решение задач","heading":"Задача 2.1","text":"Создайте бота, который будет по команде /sum и переданное в качестве дополнительных параметров произвольное количество перечисленных через пробел чисел, возвращать их сумму.Решение:","code":"\nlibrary(telegram.bot)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Создаём функцию, которая будет суммировать переданные числа\nsumming <- function(bot, update, args) {\n\n  # Переводим полученный вектор параметров в числа и суммируем\n  x <- sum(as.integer(args))\n\n  # создаём сообщение\n  msg <- paste0('Сумма переданных чисел: ', x)\n\n  # отправляем результат\n  bot$sendMessage(update$message$chat_id, msg, 'Markdown')\n\n}\n\n# создаём обработчик\nh_sum <- CommandHandler('sum', summing, pass_args = TRUE)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + h_sum\n\n# запускаем бота\nupdater$start_polling()"},{"path":"решение-задач.html","id":"задача-3.1","chapter":"Решение задач","heading":"Задача 3.1","text":"Создайте бота, который будет поддерживать Reply клавиатуру. На Reply клавиатуре будет всего одна кнопка “Время”. По нажатию на неё будет появляться Inline клавиатура с выбором из 6 часовых поясов.Africa/CairoAmerica/ChicagoEurope/MoscowAsia/BangkokEurope/KievAustralia/SydneyКнопки Inline клавиатуры необходимо расположить по 2 в ряд, соответвенно в три ряда.По нажатию на одну из кнопки Inline клавиатуры бот будет запрашивать информацию по текущему времени из API worldtimeapi.org.Формат запроса к API: http://worldtimeapi.org/api/timezone/{area}/:{location}.Где {area} это континент, например Europe, а {location} это город, например Kiev. Дату и время надо брать в ответе из компонента datetime.Решение:","code":"\nlibrary(telegram.bot)\nlibrary(httr)\nlibrary(stringr)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Запуск клавиатуры\nstart <- function(bot, update) {\n  \n  # строим Reply клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n        KeyboardButton('Время')\n      )\n    ))\n  \n  # отпралвяем Reply клавиатуру\n  bot$sendMessage(update$message$chat_id, \n                  'Выберите команду', \n                  'Markdown',\n                  reply_markup = RKM)\n  \n}\n\n# Отправляем inline клавиатуру\ninline <- function(bot, update) {\n  \n  IKM <- InlineKeyboardMarkup(\n              inline_keyboard = \n                list(\n                  list(\n                    InlineKeyboardButton(text = 'Africa/Cairo', callback_data = 'Africa/Cairo'),\n                    InlineKeyboardButton(text = 'America/Chicago', callback_data = 'America/Chicago')\n                  ),\n                  list(\n                    InlineKeyboardButton(text = 'Europe/Moscow', callback_data = 'Europe/Moscow'),\n                    InlineKeyboardButton(text = 'Asia/Bangkok', callback_data = 'Asia/Bangkok')\n                  ),\n                  list(\n                    InlineKeyboardButton(text = 'Europe/Kiev', callback_data = 'Europe/Kiev'),\n                    InlineKeyboardButton(text = 'Australia/Sydney', callback_data = 'Australia/Sydney')\n                  )\n                ))\n  \n  # отпралвяем Reply клавиатуру\n  bot$sendMessage(update$message$chat_id, \n                  'Выберите регион', \n                  'Markdown',\n                  reply_markup = IKM)\n  \n}\n\n# обрабатываем нажатие на кнопку\ncurtime <- function(bot, update) {\n  \n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id) \n  \n  # данные с кнопки\n  data <- update$callback_query$data\n  \n  # разбиваем на регион и город\n  geo <- unlist(strsplit(data, split = '/'))\n  \n  # компонуем URL\n  url <- str_glue('http://worldtimeapi.org/api/timezone/{geo[1]}/{geo[2]}')\n  \n  # запрос к API\n  answer <- GET(url)\n  \n  # парсим ответ\n  res <- content(answer)\n  \n  # создаём сообщение\n  msg <- str_glue('Текущее время в {data}: {res$datetime}')\n  \n  # отправляем сообщение\n  bot$sendMessage(update$from_chat_id(), \n                  msg, \n                  'Markdown')\n}\n\n# Фильтр для Reply клавиатуры\nMessageFilters$start <- \n  BaseFilter(\n    function(message) {\n      message$text == 'Время'\n    }\n  )\n\n# Обработчики\nh_start <- CommandHandler('start', start)\nh_time  <- MessageHandler(inline, MessageFilters$start)\nh_cb    <- CallbackQueryHandler(curtime)\n\n# Добавляем обработчики в диспетчер\nupdater <- updater + h_start + h_time + h_cb\n\n# Запускаем бота\nupdater$start_polling()"},{"path":"решение-задач.html","id":"задача-4.1","chapter":"Решение задач","heading":"Задача 4.1","text":"Постройте бота который будет поддерживать игру угадай число. Т.е. по команде /start бот будет загадывать число от 1 до 50. Далее у вас будет 5 попыток угадать это число.Вы по очереди в каждой из попыток вводите числа, если введённое число меньше чем то, которое загадал бот то бот пишет “моё число больше”, иначе бот пишет “моё число меньше”. Если вы ввели правильное число то бот пишет что вы выйграли, и переводит диалог в исходное состояние.Решение:Создаём таблицу в базе данных для хранеия числа и текущей попытки.Далее создаём функции для работы с бахой данных.Основной код бота выглядит так:","code":"CREATE TABLE chat_data (\n    chat_id BIGINT  PRIMARY KEY\n                    UNIQUE,\n    attempt    INTEGER,\n    number     INTEGER\n);\n# write chat data\n# write chat data\nset_chat_data <- function(chat_id, field, value) {\n  \n  \n  con <- dbConnect(SQLite(), db)\n  \n  # upsert состояние чата\n  dbExecute(con, \n            str_interp(\"\n            INSERT INTO chat_data (chat_id, ${field})\n                VALUES(${chat_id}, '${value}') \n                ON CONFLICT(chat_id) \n                DO UPDATE SET ${field}='${value}';\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n}\n\n# read chat data\nget_chat_data <- function(chat_id, field) {\n  \n  \n  con <- dbConnect(SQLite(), db)\n  \n  # upsert состояние чата\n  data <- dbGetQuery(con, \n                     str_interp(\"\n            SELECT ${field}\n            FROM chat_data\n            WHERE chat_id = ${chat_id};\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n  return(data[[field]])\n  \n}\nlibrary(RSQLite)\nlibrary(DBI)\nlibrary(telegram.bot)\nlibrary(stringr)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# путь к базе\ndb <- \"ПУСТЬ К БАЗЕ ДАННЫХ/bot.db\"\n\nstart <- function(bot, update) {\n  \n  # бот загадывает число\n  num <- round(runif(1, 1, 50), 0)\n  \n  # записываем данные в базу о начале игры\n  set_chat_data( update$message$chat_id, 'number', num)\n  set_chat_data( update$message$chat_id, 'attempt', 1)\n  \n  # отпралвяем Reply клавиатуру\n  bot$sendMessage(update$message$chat_id, \n                  'Число загаданно, начинаем игру, ваша первая попытка.', \n                  'Markdown')\n  \n}\n\nattempt <- function(bot, update) {\n  \n  num <- get_chat_data(update$message$chat_id, 'number')\n  att <- get_chat_data(update$message$chat_id, 'attempt')\n  \n  user_num <- update$message$text\n  \n  if ( user_num < num ) {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0('Номер попытки: ', att, \". Моё число больше\"),\n                    'Markdown')\n    \n  } else if ( user_num > num ) {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0('Номер попытки: ', att, \". Моё число меньше\"),\n                    'Markdown')\n    \n  } else {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0('Номер попытки: ', att, \". Поздравляю, вы угадали число!\"),\n                    'Markdown')\n    \n    set_chat_data( update$message$chat_id, 'attempt', 0)\n    \n  }\n  \n  if ( att == 5 &  user_num != num )  {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0(\"Вы проиграли, я загадал число \", num),\n                    'Markdown')\n    set_chat_data( update$message$chat_id, 'attempt', 0)\n    \n  }\n  \n  set_chat_data( update$message$chat_id, 'attempt', att + 1)\n  \n}\n\n\n# фильтр сообщение в состоянии ожидания имени\nMessageFilters$attempt <- BaseFilter(function(message) {\n\n  att <- get_chat_data(message$chat_id, 'attempt') \n  0 < att & att < 6\n}\n)\n\n# обработчики\nh_start   <- CommandHandler('start', start)\nh_attempt <- MessageHandler(attempt, MessageFilters$attempt & !MessageFilters$command)\n\n# диспетчер\nupdater <- updater + h_start + h_attempt\n\n# запуск\nupdater$start_polling()"},{"path":"решение-задач.html","id":"задача-5.1","chapter":"Решение задач","heading":"Задача 5.1","text":"Возьмите задачу 2.1 из второй главы, и ограничьте использование единственного метода, доступного в созданном боте, так, что бы он работал только когда его запрашиваете вы.Решение:","code":"\nlibrary(telegram.bot)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Создаём функцию, которая будет суммировать переданные числа\nsumming <- function(bot, update, args) {\n  \n  if ( update$message$from$username == 'YourUsername' ) {\n\n    # Переводим полученный вектор параметров в числа и суммируем\n    x <- sum(as.integer(args))\n  \n    # создаём сообщение\n    msg <- paste0('Сумма переданных чисел: ', x)\n  \n    # отправляем результат\n    bot$sendMessage(update$message$chat_id, msg, 'Markdown')\n    \n  } else {\n    \n    # отправляем результат\n    bot$sendMessage(update$message$chat_id, \n                    'У вас не достаточно прав на использование этой функции бота!', \n                    'Markdown')\n    \n  }\n\n}\n\n# создаём обработчик\nh_sum <- CommandHandler('sum', summing, pass_args = TRUE)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + h_sum\n\n# запускаем бота\nupdater$start_polling()"}]
