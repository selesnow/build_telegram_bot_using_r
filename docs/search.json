[{"path":"index.html","id":"введение","chapter":"Введение","heading":"Введение","text":"Аудитория Telegram растёт с геометрической прогрессией. Популярность мессенджера объясняется его удобством, наличием каналов и чатов, а также возможностью создавать ботов.Боты могут использоваться для самых разных задач: от автоматизации общения с клиентами до управления личными делами и автоматизации рутинных задач. С их помощью можно выполнять практически любые операции: отправлять и запрашивать данные, запускать задачи на сервере, собирать информацию в базу данных, отправлять электронные письма и многое другое. Т.е. telegram бот может стать интерфейсом для выполнения любых ваших задач.Этот веб-учебник научит вас разрабатывать Telegram-ботов на языке программирования R. Материал изложен последовательно: от простого к сложному.В первой главе мы рассмотрим, как отправлять сообщения из R в Telegram, к четвёртой главе мы создадим полноценного бота, который сможет вести логический диалог с пользователем, а далее расмотрим ещё несколько смежных тем, разберёмся с контейнерезацией приложений, и запуском ботов в облачных платформах.Основным R-пакетом, который мы будем использовать на протяжении всего учебника, является telegram.bot. Каждая глава завершается небольшим заданием и тестом, чтобы вы могли проверить свои знания и понять, насколько хорошо усвоили материал.","code":""},{"path":"index.html","id":"навыки-необходимые-для-прохождения-учебника","chapter":"Введение","heading":"Навыки необходимые для прохождения учебника","text":"Тему построения ботов я отношу к продвинутым навыкам, не зависимо от выбранного язка программирования. Поэтому в этой книге не рассматриваются базовые вводные темы по основам языка R.Для чтения и понимания книги вам необходимо обладать следующими навыками на языке программирования R:Понимать базовые програмные конструкции, т.е. циклы и условные ветвления.Понимать что такое функция.Разбираться в основных структурах данных языка.Уметь работать со строками.Владеть основами манипуляции данных с помощью пакета dplyr.Иметь поверхностное понимание о том, что такое API.Перечисленные выше темы выходят за рамки этой книги, но подробно рассматриваются в онлайн академии “Язык R для интернет-маркетинга”.","code":""},{"path":"index.html","id":"об-авторе","chapter":"Введение","heading":"Об авторе","text":"Меня зовут Алексей Селезнёв, и я уже более 10 лет работаю аналитиком. С 2016 года руковожу отделом аналитики в агентстве интернет-маркетинга Netpeak.Являюсь автором курсов по языку R:Язык R для пользователей Excel.Введение в dplyr 1.0.0.Циклы и функционалы в языке R.Разработка пакетов на языке R.Язык R для интернет-маркетинга.Неоднократно выступал в роли спикера на различных конференция посвящённых аналитике и маркетингу, среди которых: 8P, Матемаркениг, Analyze, Ecommerce, GoAnalytics и другие.Являюсь автором ряда R пакетов опубликованных в CRAN: rgoogleads, rfacebookstat, timesperiodR и др.С 2015 года активно публикую статьи по аналитике; на момент написания этих строк у меня более 120 публикаций в различных интернет-изданиях. Веду собственный блог, который служит агрегатором моих статей с различных источников.В 2018 году я создал Telegram-канал R4marketing, где делюсь полезными русскоязычными материалами по языку R: ссылками на статьи, доклады, вебинары и заметками. В 2020 году запустил YouTube канал с видеоуроками по языку R и аналитике в целом.","code":""},{"path":"index.html","id":"видео-введение-в-курс","chapter":"Введение","heading":"Видео введение в курс","text":"","code":""},{"path":"index.html","id":"правки-и-предложения","chapter":"Введение","heading":"Правки и предложения","text":"Перед публикацией учебника я несколько раз его перечитал, но некоторые ошибки в разметке, грамматике или синтаксисе всё же могли ускользнуть от моего внимания.Кроме того, если у вас есть предложения по улучшению учебника, например, какие темы стоило бы добавить или что потеряло актуальность, буду рад услышать ваше мнение.По всем вопросам вы можете связаться со мной по почте или напрямую в Telegram.Email: selesnow@gmail.com \nTelegram: AlexeySeleznev","code":""},{"path":"index.html","id":"поддержать-проект","chapter":"Введение","heading":"Поддержать проект","text":"Учебник, и все необходимые материалы находятся в открытом доступе, но при желании вы можете поддержать этот проект любой произвольной сумме перейдя по этой ссылке.","code":""},{"path":"предисловие.html","id":"предисловие","chapter":"Предисловие","heading":"Предисловие","text":"Добро пожаловать в мир разработки Telegram-ботов с использованием языка R! Эта книга — ваш детализированный и практический путеводитель в увлекательный процесс создания, настройки и развертывания ботов. Независимо от того, являетесь ли вы новичком в разработке ботов или просто хотите расширить свои навыки, эта книга предоставит вам все необходимые инструменты и знания.Мы начнем с самого начала, и вам не потребуется предварительных знаний в области разработки ботов. Постепенно, шаг за шагом, мы пройдем весь процесс, начиная с создания базового бота и заканчивая его развертыванием на платформе Google Cloud Run.Вы узнаете:Основы создания бота: Мы начнем с нуля, разберем, как создать простого Telegram-бота, который будет выполнять базовые функции и взаимодействовать с пользователями. Вы научитесь настраивать основные параметры и использовать API Telegram для запуска своего первого бота.Команды и фильтры: Вы увидите, как добавлять команды для управления ботом и настраивать фильтры для обработки сообщений. Это позволит вашему боту выполнять задачи по заданию команд и эффективно обрабатывать входящие сообщения.Клавиатуры: В этой части книги мы погрузимся в создание и настройку двух типов клавиатур: reply и inline. Вы научитесь добавлять интерактивные элементы в чат, которые помогут пользователям легко выбирать варианты и взаимодействовать с ботом.Строительство диалогов: Мы изучим, как создавать сложные последовательности диалогов, чтобы бот мог вести более естественное и осмысленное взаимодействие с пользователями. Это поможет вашему боту лучше понимать запросы и предоставлять полезные ответы.Управление правами пользователей: В этой главе мы разберем, как настраивать права доступа для различных пользователей, чтобы контролировать, кто и как может взаимодействовать с вашим ботом. Это повысит безопасность и гибкость вашего проекта.Повышение стабильности: Мы обсудим методы улучшения надежности вашего бота, такие как обработка ошибок и оптимизация производительности. Это поможет вам создать более стабильное и устойчивое приложение.Асинхронность: Узнаете, как внедрить асинхронные операции для улучшения производительности вашего бота. Мы рассмотрим, как обрабатывать множество задач одновременно, чтобы ваш бот работал быстрее и эффективнее.Упаковка в Docker: Научитесь создавать Docker-контейнеры для вашего бота. Это упростит развертывание и управление его окружением, обеспечивая совместимость и переносимость.Развертывание на Google Cloud Run: В завершающей главе мы изучим, как развернуть вашего бота на Google Cloud Run. Это обеспечит его масштабируемость и доступность, а также упростит управление ресурсами и мониторинг.Каждая глава содержит практические примеры и пошаговые инструкции, которые помогут вам не только понять теоретические аспекты, но и применять их на практике. Мы также обсудим общие проблемы и решения, которые могут возникнуть на пути разработки, чтобы вы могли быстрее находить ответы и двигаться вперед.Эта книга — ваш надежный помощник в создании и развитии Telegram-ботов. Надеюсь, что вы найдете её полезной, увлекательной и вдохновляющей на пути к созданию успешного бота. Желаю вам увлекательного и продуктивного путешествия в мир ботов!","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","text":"В этой главе мы начинаем наше путешествие в мир разработки Telegram-ботов. Вы узнаете, как создать своего первого бота, получить уникальный токен и настроить его для работы с Telegram API с помощью языка R.Мы подробно рассмотрим, как с помощью пакета telegram.bot реализовать основные функции, такие как отправка сообщений и интеграция бота с Telegram. Вы получите практические навыки, необходимые для настройки и управления ботом, а также сможете увидеть, как эти знания применяются на практике.Эта глава даст вам прочную основу для дальнейшего освоения более сложных возможностей и функционала ботов. Надеюсь, что начало работы с ботами станет для вас вдохновляющим шагом к созданию собственных уникальных проектов и решений.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"создание-телеграм-бота","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.1 Создание телеграм бота","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"видео-урок-о-создании-telegram-бота-через-botfather","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.1.1 Видео урок о создании telegram бота через BotFather","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"конспект-о-создании-telegram-бота-через-botfather","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.1.2 Конспект о создании telegram бота через BotFather","text":"Для начала нам необходимо создать бота. Делается это с помощью специального бота BotFather, переходим по ссылке и пишем боту /start.После чего вы получите сообщение со списком команд:Для создания нового бота отправляем команду /newbot.BotFather попросит вас ввести имя и логин бота.Имя вы можете ввести произвольное, а логин должен заканчиваться на bot.Если вы всё сделали правильно, то получите следующее сообщение:Далее вам понадобится полученный API токен, в моём примере это 123456789:abcdefghijklmnopqrstuvwxyz.Более подробно о возможностях BotFather можно узнать из этой публикации. На этом шаге подготовительные работы по созданию бота завершены.","code":"I can help you create and manage Telegram bots. If you're new to the Bot API, please see the manual (https://core.telegram.org/bots).\n\nYou can control me by sending these commands:\n\n/newbot - create a new bot\n/mybots - edit your bots [beta]\n\nEdit Bots\n/setname - change a bot's name\n/setdescription - change bot description\n/setabouttext - change bot about info\n/setuserpic - change bot profile photo\n/setcommands - change the list of commands\n/deletebot - delete a bot\n\nBot Settings\n/token - generate authorization token\n/revoke - revoke bot access token\n/setinline - toggle inline mode (https://core.telegram.org/bots/inline)\n/setinlinegeo - toggle inline location requests (https://core.telegram.org/bots/inline#location-based-results)\n/setinlinefeedback - change inline feedback (https://core.telegram.org/bots/inline#collecting-feedback) settings\n/setjoingroups - can your bot be added to groups?\n/setprivacy - toggle privacy mode (https://core.telegram.org/bots#privacy-mode) in groups\n\nGames\n/mygames - edit your games (https://core.telegram.org/bots/games) [beta]\n/newgame - create a new game (https://core.telegram.org/bots/games)\n/listgames - get a list of your games\n/editgame - edit a game\n/deletegame - delete an existing gameBotFather, [25.07.20 09:39]\nAlright, a new bot. How are we going to call it? Please choose a name for your bot.\n\nAlexey Seleznev, [25.07.20 09:40]\nMy Test Bot\n\nBotFather, [25.07.20 09:40]\nGood. Now let's choose a username for your bot. It must end in `bot`. Like this, for example: TetrisBot or tetris_bot.\n\nAlexey Seleznev, [25.07.20 09:40]\n@my_test_botDone! Congratulations on your new bot. You will find it at t.me/my_test_bot. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.\n\nUse this token to access the HTTP API:\n123456789:abcdefghijklmnopqrstuvwxyz\n\nFor a description of the Bot API, see this page: https://core.telegram.org/bots/api"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"установка-пакета-для-работы-с-телеграм-ботом-на-r","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.2 Установка пакета для работы с телеграм ботом на R","text":"Я предполагаю, что у вас уже установлен язык R, и среда разработки RStudio. Если это не так, то вы можете посмотреть данный видео урок о том, как их установить.Для работы с Telegram Bot API мы будем использовать R пакет telegram.bot.Установка пакетов в R осуществляется функцией install.packages(), поэтому для установки нужного нам пакета используйте команду install.packages(\"telegram.bot\").Более подробно узнать об установке различных пакетов можно из этого видео.После установки пакета его необходимо подключить:","code":"\nlibrary(telegram.bot)"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"отправка-сообщений-из-r-в-telegram","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.3 Отправка сообщений из R в Telegram","text":"Созданного вами бота можно найти в Telegram по заданному при создании логину, в моём случае это @my_test_bot.Отправьте боту любое сообщение, например “Привет бот”. На данный момент это нам надо для того, что бы получить id вашего с ботом чата.Теперь в R пишем следующий код.Изначально мы создаём экземпляр нашего бота функцией Bot(), в качестве аргумента в неё необходимо передать полученный ранее токен.Хранить токен в коде считается не лучшей практикой, поэтому вы можете хранить его в переменной среды, и считывать его из неё. По умолчанию в пакете telegram.bot реализована поддержка переменных среды следующего наименования: R_TELEGRAM_BOT_ИМЯ_ВАШЕГО_БОТА. Вместо ИМЯ_ВАШЕГО_БОТА подставьте имя которое вы задали при создании, в моём случае будет переменная R_TELEGRAM_BOT_My Test Bot.Создать переменную среды можно несколькими способами, я расскажу о наиболее универсальном и кроссплатформенном. Создайте в вашей домашней директории (узнать её можно с помощью команды path.expand(\"~\")) текстовый файл с названием .Renviron. Сделать это также можно с помощью команды file.edit(path.expand(file.path(\"~\", \".Renviron\"))).И добавьте в него следующую строку.Далее вы можете использовать сохранённый в переменной среды токен с помощью функции bot_token(), т.е. вот так:Метод getUpdates()позволяет нам получить обновления бота, т.е. сообщения которые были ему отправлены. Метод from_chat_id(), позволяет получить идентификатор чата, из которого было отправлено сообщение. Этот идентификатор нам нужен для отправки сообщений от бота.Помимо id чата из объекта полученного методом getUpdates() вы получаете и некоторую другую полезную информацию. Например, информацию о пользователе, отправившем сообщение.Итак, на данном этапе у нас уже есть всё, что необходимо для отправки сообщения от бота в телеграм. Воспользуемся методом sendMessage(), в который необходимо передать идентификатор чата, текст сообщения, и тип разметки текста сообщения. Тип разметки может быть Markdown или HTML и устанавливается аргументом parse_mode.Если вам необходимо отправить сообщение от бота не в чат, а в публичный канал, то в chat_id указывайте адрс вашего канала, например '@MyTGChannel'.При необходимости отправить сообщение в приватный канал, вам необходимо скопировать ссылку на любое сообщение данного канала, из ссылки получить его идентификатор, и к этому идентификатору добавить -100.Пример ссылки приватного канала: https://t./c/012345678/11Соответвенно, к id 012345678 вам необходимо добавить -100, в таком случае в chat_id надо указать -100012345678.Основы форматирования Markdown разметки:Жирный шрифт выделяется с помощью знака *:\nпример: *жирный шритф*\nрезультат: жирный шритф\nпример: *жирный шритф*результат: жирный шритфКурсив задаётся нижним подчёркиванием:\nпример: _курсив_\nрезультат: курсив\nпример: _курсив_результат: курсивМоноширинный шрифт, которым обычно выделяется программный код, задаётся с помощью апострофов:\nпример: `моноширинный шрифт`\nрезультат: моноширинный шрифт\nпример: `моноширинный шрифт`результат: моноширинный шрифтОсновы форматирования HTML разметки:В HTML вы заворачиваете часть текста, которую надо выделать, в теги, пример <тег>текст<\/тег>.<тег> - открывающий тег<\/тег> - закрывающий тегТеги HTML разметки<b> - жирный шрифт\nпример: <b>жирный шрифт<\/b>\nрезультат жирный шрифт\nпример: <b>жирный шрифт<\/b>результат жирный шрифт<> - курсив\nпример: <>курсив<\/>\nрезультат: курсив\nпример: <>курсив<\/>результат: курсив<code> - моноширинный шрифт\nпример: <code\\>моноширинный шрифт<\/code\\>\nрезультат: моноширинный шрифт\nпример: <code\\>моноширинный шрифт<\/code\\>результат: моноширинный шрифтПомимо текста вы можете отправлять и другой контент используя специальные методы:Т.е. например с помощью метода sendPhoto() вы можете отправить сохранённый в виде изображения график, который вы построили с помощью пакета ggplot2.Помимо отправки данных бот имеет и ряд других методов:deleteMessage() - Удалить сообщениеeditMessageText() - Редактирвать текст сообщенияeditMessageCaption() - Редактировать описание изображения, файла и т.д.forwardMessage() - Переслать сообщениеgetFile() - Подготовка файла к скачиваниюgetMe() - Получить информацию о ботеgetUpdates() - Получить список обновлений ботаgetUserProfilePhotos() - Получить аватар пользователяleaveChat() - Выйти из группыclean_updates() - Очистить очередь обновлений","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр бота\nbot <- Bot(token = \"123456789:abcdefghijklmnopqrstuvwxyz\")\n\n# Запрашиваем информацию о боте\nprint(bot$getMe())\n\n# Получаем обновления бота, т.е. список отправленных ему сообщений\nupdates <- bot$getUpdates()\n\n# Запрашиваем идентификатор чата\n# Примечание: перед запросом обновлений вы должны отправить боту сообщение\nchat_id <- updates[[1L]]$from_chat_id()R_TELEGRAM_BOT_ИМЯ_ВАШЕГО_БОТА=123456789:abcdefghijklmnopqrstuvwxyz\nbot <- Bot(token = bot_token(\"My Test Bot\"))\nupdates[[1L]]$message$from$id\n[1] 000000000\n\n$is_bot\n[1] FALSE\n\n$first_name\n[1] \"Alexey\"\n\n$last_name\n[1] \"Seleznev\"\n\n$username\n[1] \"AlexeySeleznev\"\n\n$language_code\n[1] \"ru\"\n# Отправка сообщения\nbot$sendMessage(chat_id,\n                text = \"Привет, *жирный текст* _курсив_\",\n                parse_mode = \"Markdown\"\n)\n# Отправить изображение\nbot$sendPhoto(chat_id,\n  photo = \"https://telegram.org/img/t_logo.png\"\n)\n\n# Отправка голосового сообщения\nbot$sendAudio(chat_id,\n  audio = \"http://www.largesound.com/ashborytour/sound/brobob.mp3\"\n)\n\n# Отправить документ\nbot$sendDocument(chat_id,\n  document = \"https://github.com/ebeneditos/telegram.bot/raw/gh-pages/docs/telegram.bot.pdf\"\n)\n\n# Отправить стикер\nbot$sendSticker(chat_id,\n  sticker = \"https://www.gstatic.com/webp/gallery/1.webp\"\n)\n\n# Отправить видео\nbot$sendVideo(chat_id,\n  video = \"http://techslides.com/demos/sample-videos/small.mp4\"\n)\n\n# Отправить gif анимацию\nbot$sendAnimation(chat_id,\n  animation = \"https://media.giphy.com/media/sIIhZliB2McAo/giphy.gif\"\n)\n\n# Отправить локацию\nbot$sendLocation(chat_id,\n  latitude = 51.521727,\n  longitude = -0.117255\n)\n\n# Имитация действия в чате\nbot$sendChatAction(chat_id,\n  action = \"typing\"\n)"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"как-отправить-в-telegram-таблицу","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.4 Как отправить в telegram таблицу","text":"К сожалению на момент написания книги telegram не поддерживает полноценные таблицы в HTML или Markdown, но вы можете иметировать подобие таблицы. Для этого воспользуйтесь кодом представленной ниже функции to_tg_table():С помощью этой функци вы можете преобразовать любой data.frame и отправить в telegram:У функции to_tg_table() есть несколько дополнительных аргументов:align - выравнивнивание столбцов, тектовая строка, каждая буква соответвует одному столбцу, пример 'llrrc':\nl - выравнивание по левой стороне\nr - выравнивание по правой стороне\nc - выравнивание по центру\nl - выравнивание по левой сторонеr - выравнивание по правой сторонеc - выравнивание по центруindents - количество пробелов для разделения столбцов.parse_mode - разметка сообщения, Markdown или HTML.Пример с выравниванием столбцов:","code":"\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringr)\n\n# функция для перевода data.frame в telegram таблицу \nto_tg_table <- function( table, align = NULL, indents = 3, parse_mode = 'Markdown' ) {\n  \n  # если выравнивание не задано то выравниваем по левому краю\n  if ( is.null(align) ) {\n    \n    col_num <- length(table)\n    align   <- str_c( rep('l', col_num), collapse = '' )\n  \n  }\n  \n  # проверяем правильно ли заданно выравнивание\n  if ( length(table) != nchar(align) ) {\n    \n    align <- NULL\n    \n  }\n  \n  # новое выравнивание столбцов \n  side <- sapply(1:nchar(align), \n         function(x) { \n           letter <- substr(align, x, x)\n           switch (letter,\n                   'l' = 'right',\n                   'r' = 'left',\n                   'c' = 'both',\n                   'left'\n           )\n  })\n  \n  # сохраняем имена\n  t_names      <- names(table)\n\n  # вычисляем ширину столбцов\n  names_length <- sapply(t_names, nchar) \n  value_length <- sapply(table, function(x) max(nchar(as.character(x))))\n  max_length   <- ifelse(value_length > names_length, value_length, names_length)\n  \n  # подгоняем размер имён столбцов под их ширину + указанное в indents к-во пробелов \n  t_names <- mapply(str_pad, \n                    string = t_names, \n                    width  = max_length + indents, \n                    side   = side)\n  \n  # объединяем названия столбцов\n  str_names <- str_c(t_names, collapse = '')\n  \n  # аргументы для фукнции str_pad\n  rules <- list(string = table, width = max_length + indents, side = side)\n\n  # поочереди переводим каждый столбец к нужному виду\n  t_str <-   pmap_df( rules, str_pad )%>%\n              unite(\"data\", everything(), remove = TRUE, sep = '') %>%\n              unlist(data) %>%\n              str_c(collapse = '\\n') \n  \n  # если таблица занимает более 4096 символов обрезаем её\n  if ( nchar(t_str) >= 4021 ) {\n    \n    warning('Таблица составляет более 4096 символов!')\n    t_str <- substr(t_str, 1, 4021)\n    \n  }\n  \n  # символы выделения блока кода согласно выбранной разметке\n  code_block <- switch(parse_mode, \n                       'Markdown' = c('```', '```'),\n                       'HTML' = c('<code>', '<\/code>'))\n           \n  # переводим в code\n  res <- str_c(code_block[1], str_names, t_str, code_block[2], sep = '\\n')\n  \n  return(res)\n}\n# преобразуем таблицу iris \ntg_table <- to_tg_table( head(iris, 15) )\n\n# отправляем таблицу в telegram\nbot$sendMessage(194336771, \n                tg_table,\n                \"Markdown\")\n# преобразуем таблицу iris \ntg_table <- to_tg_table( head(iris, 15), \n                         align = 'llccr')\n\n# отправляем таблицу в telegram\nbot$sendMessage(194336771, \n                tg_table,\n                \"Markdown\")"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"как-добавить-в-сообщение-emoji","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.5 Как добавить в сообщение Emoji","text":"Требования к телеграм ботам могут быть разные, в том числе заказчик может попросить вас добавить в сообщения бота какие то Emoji.Получить полный список доступных смайлов можно по этой ссылке.Из таблицы нас интересует поле Unicode. Скопиройте код нужного вам смайла, и замените U+ на \\U000. Т.е. если вам необходимо отправить смайл, код котого в таблице U+1F601, то в коде на R вам необходимо добавить его в текст сообщения вот так - \\U0001F601.Пример:","code":"\nbot$sendMessage(chat_id, \n                'Сообщение со смайлом \\U0001F601 код которого в таблице U+1F601')"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"проверка-планировщика-задач-windows-и-отправка-уведомления-о-задачах-работа-которых-была-завершена-аварийно","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.6 Проверка планировщика задач Windows, и отправка уведомления о задачах, работа которых была завершена аварийно","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"видео-урок-о-разработке-бота-для-контроля-планировщика-заданий","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.6.1 Видео урок о разработке бота для контроля планировщика заданий","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"конспект-о-разработке-бота-для-контроля-планировщика-заданий","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.6.2 Конспект о разработке бота для контроля планировщика заданий","text":"Для работы с планировщиком заданий Windows вам необходимо установить пакет taskscheduleR, и для удобства работы с данными установим пакет dplyr.Далее с помощью функции taskscheduler_ls() мы запрашиваем информацию о задачах из нашего планировщика. С помощью функции filter() из пакета dplyr мы убираем из списка задач те, которые были успешно выполненны и имеют статус последнего результата 0, и те, которые ещё ни разу не запускались и имеют статус 267011, выключенные задачи, и задачи которые выполняются в данный момент.В объекте task у нас теперь список задач, работа которых завершилась ошибкой, этот список нам надо отправить в Telegram.Если рассмотреть каждую команду подробнее, то:filter() - фильтрует список задач, по описанным выше условиямselect() - оставляет в таблице только одно поле с названием задачunique() - убирает дубли названийunlist() - переводит выбранный столбец таблицы в векторpaste0() - соединяет названия задач в одну строку, и ставит в качестве разделителя знак перевода строки, т.е. \\n.Всё что нам остаётся - отправить этот результат в телеграм.Итак, на данный момент код бота выглядит вот так:При использовании приведённого выше примера подставьте в код токен вашего бота и ваш идентификатор чата.Вы можете добавлять условия фильтрации задач, например проверяя только те задачи, которые были созданны вами, исключая системные.Так же вы можете вынести различные настройки в отдельный файл конфигурации, и хранить в нём id чата и токен. Читать конфиг можно например с помощью пакета configr.","code":"\n# Установка пакетов\ninstall.packages(c('taskscheduleR', 'dplyr'))\n# Подключение пакетов\nlibrary(taskscheduleR)\nlibrary(dplyr)\n# запрашиваем список задач\ntask <- task <- taskscheduler_ls() %>%\n        filter(! `Last Result`  %in% c(\"0\", \"267011\") & \n               `Scheduled Task State` == \"Enabled\" & \n               Status != \"Running\") %>%\n        select(TaskName) %>%\n        unique() %>%\n        unlist() %>%\n        paste0(., collapse = \"\\n\")\nbot$sendMessage(chat_id,\n                text = task,\n                parse_mode = \"Markdown\"\n)\n# Подключение пакета\nlibrary(telegram.bot)\nlibrary(taskscheduleR)\nlibrary(dplyr)\n\n# инициализируем бота\nbot <- Bot(token = \"123456789:abcdefghijklmnopqrstuvwxyz\")\n\n# идентификатор чата\nchat_id <- 123456789\n\n# запрашиваем список задач\ntask <- taskscheduler_ls() %>%\n        filter(! `Last Result`  %in% c(\"0\", \"267011\")  &\n               `Scheduled Task State` == \"Enabled\" & \n               Status != \"Running\") %>%\n        select(TaskName) %>%\n        unique() %>%\n        unlist() %>%\n        paste0(., collapse = \"\\n\")\n\n# если есть проблемные задачи отправляем сообщение\nif ( task != \"\" ) {\n\n  bot$sendMessage(chat_id,\n                  text = task,\n                  parse_mode = \"Markdown\"\n  )\n\n}[telegram_bot]\n;настройки телеграм бота и чата, в который будут приходить уведомления\nchat_id=12345678\nbot_token=123456789:abcdefghijklmnopqrstuvwxyz\"\nlibrary(configr)\n\n# чтение конфина\nconfig <- read.config('C:/путь_к_конфигу/config.cfg', rcmd.parse = TRUE)\n\nbot_token <- config$telegram_bot$bot_token\nchat_id     <- config$telegram_bot$chat_id"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"настраиваем-расписание-запуска-проверки-задач","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.7 Настраиваем расписание запуска проверки задач","text":"Наиболее подробно процесс настройки запуска скриптов по расписанию описан в этой статье.Тут я лишь опишу шаги, которые для этого необходимо выполнить. Если какой-то из шагов вам не понятен, то обратитесь к статье на которую я указал ссылку.Предположим, что мы сохранили код нашего бота в файл check_bot.R. Для того, что бы запланировать регулярный запуск этого файла выполните следующие шаги:Пропишите в системную переменную Path путь к папке в которой установлен R, в Windows путь будет примерно таким: C:\\Program Files\\R\\R-4.0.2\\bin.Создайте исполняемый bat файл, в котором будет всего одна строка R CMD BATCH C:\\rscripts\\check_bot\\check_bot.R. Замените C:\\rscripts\\check_bot\\check_bot.R на полный путь к вашему R файлу.Далее настройте с помощью планировщика задач Windows расписание запуска, например на каждые пол часа.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"настраиваем-запуск-расписания-отправки-сообщения-с-помощью-github-actions","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8 Настраиваем запуск расписания отправки сообщения с помощью GitHub Actions","text":"Прошлый пример запускал скрипт отправки сообщения с вашего ноутбука, ПК или сервера на Windows. Т.к. сам бот которого мы рассматривал мониторил планировщик заданий на том ПК на котором запускался, то это пожалуй был единственный способ настроить расписание его автоматического запуска. Но зачастую вам необходима будет отправка данных не вашего ПК, а полученных из каких то внешних источников, например API. А рассписание запуска настроенное на вашем ноутбуке будет отрабатывать только в том случае если сам ноутбук включён и имеет доступ к интернету, но нам хотелось бы иметь альтернативный способ запуска скриптов по рассписанию, и желательно бесплатный.Давайте рассмотрим ещё один пример бота, данный бот будет запрашивать курсы валют и отправлять их в telegram чат. Но настраивать автоматизацию его запуска мы будем с помощью сервиса GitHub Actions.Для выполнения описанных в этом разделе действий вам необходимо предварительно установить Git на вашу операционную систему.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"видео-по-настройке-запуска-скриптов-с-помощью-github-actions","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.1 Видео по настройке запуска скриптов с помощью GitHub Actions","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"что-такое-cicd","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.2 Что такое CI/CD","text":"CI/CD — это методология и набор практик для автоматизации процессов разработки, тестирования и развертывания программного обеспечения. CI/CD расшифровывается как Continuous Integration (непрерывная интеграция) и Continuous Deployment (непрерывное развертывание) или Continuous Delivery (непрерывная доставка).Непрерывная интеграция (CI) — это практика частого слияния изменений в основной кодовой базе. Основные принципы CI:Разработчики регулярно интегрируют свои изменения в основной репозиторий.После каждого слияния запускаются автоматические тесты, чтобы убедиться, что изменения не ломают существующий код.Выявленные ошибки устраняются сразу.Continuous Deployment (непрерывное развертывание) и Continuous Delivery (непрерывная доставка) — это методы автоматического развертывания и доставки изменений в продакшн.Continuous Delivery: Изменения автоматически тестируются и подготавливаются к развертыванию, но финальное развертывание может требовать ручного подтверждения.Continuous Deployment: Все изменения, прошедшие автоматическое тестирование, автоматически развертываются в производственной среде.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"что-такое-github-actions","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.3 Что такое GitHub Actions","text":"GitHub Actions — это платформа для автоматизации процессов в рамках репозитория GitHub. Она позволяет создавать и запускать рабочие процессы (workflows), которые автоматически выполняются при наступлении определенных событий в репозитории.Основные компоненты GitHub Actions:Workflow (рабочий процесс): YAML-файл, который описывает автоматизируемый процесс.Job (задача): Определенная часть рабочего процесса, которая выполняется на виртуальной машине.Step (шаг): Отдельные шаги внутри задачи, которые могут включать команды или действия (actions).Action (действие): Повторно используемый блок, который выполняет одну конкретную задачу, например, установка зависимостей, запуск тестов и т.д.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"обзор-рабочего-процесса","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.4 Обзор рабочего процесса","text":"Рабочий процесс выглядит следующим образом:Создание репозитория на GitHubСоздание R-скриптаНастройка GitHub ActionsСоздание переменных среды в репозитории GitHubCommit и Push изменений","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"создание-репозитория","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.5 Создание репозитория","text":"Создайте новый репозиторий на GitHub или используйте уже существующий.Добавьте ваш код на языке R в репозиторий.Скопируйте URL для клонирования репозиторияОткройте RStudio: File -> New Project -> Version Control -> Git — > Вставить скопированный URL в поле Repository URL. Необходим установленный Git.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"добавляем-в-проект-r-скрипт","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.6 Добавляем в проект R скрипт","text":"Теперь создайте в проекте папку R, и в ней файл с будущим скриптом бота currency_rate_sender.R. Для удобства я использую функцию usethis::use_r('currency_rate_sender'), она создаст каталог R, и в нём файл скрипта.Листинг нашего кода:Данный код запрашивает по API курсы валют, после чего отправляет их в Telegram Чат. Для того что бы использовать этот же код вам необходимо получить к API ключ на сайте https://www.exchangerate-api.com/.","code":"\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(telegram.bot)\n\n# Функция для получения курса валют\nget_exchange_rate <- function(api_key, currency) {\n  url <- paste0(\"https://api.exchangerate-api.com/v4/latest/USD?apikey=\", api_key)\n  response <- GET(url)\n  data <- fromJSON(content(response, \"text\"))\n  return(data$rates[[currency]])\n}\n\n# Функция для отправки сообщения в Telegram\nsend_telegram_message <- function(bot_token, chat_id, message) {\n  bot <- Bot(token = bot_token)\n  bot$sendMessage(chat_id = chat_id, text = message)\n}\n\n# Получение переменных среды\napi_key   <- Sys.getenv(\"EXCHANGE_RATE_API_KEY\")\nbot_token <- Sys.getenv(\"TELEGRAM_BOT_TOKEN\")\nchat_id   <- Sys.getenv(\"TELEGRAM_CHAT_ID\")\ncurrency  <- \"EUR\"\n\n# Получение курса валют и отправка сообщения\nexchange_rate <- get_exchange_rate(api_key, currency)\nmessage <- paste(\"Курс\", currency, \"к USD:\", exchange_rate)\nsend_telegram_message(bot_token, chat_id, message)"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"настройка-github-actions","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.7 Настройка GitHub Actions","text":"Теперь необходимо создать конфигурацию для нашего рабочего процесса, это делается с помощью yaml файла.Используйте функцию use_github_action(‘currency_rate_sender’). Работа функции закончится ошибкой, но она создаст необходимую нам структуру папок .github/workflows.Далее создайте в проекте, в папке workflows текстовый файл currency_rate_sender.yaml. И добавьте в него следующие команды:Давайте рассмотрим все эти команды подробнее:Задаёт название рабочего процессаБлок определяет, какие события в репозитории запускают workflow. В нем можно указать различные события, такие как push, pull_request, schedule и другие. Рассмотрим некоторые из них:События push и pull_request — Эти события запускают workflow при выполнении push или создании pull request соответственно.Событие schedule позволяет запускать workflow по расписанию, используя синтаксис cron. Cron выражения состоят из пяти полей, каждое из которых задает единицу времени:\nМинуты (0-59)\nЧасы (0-23)\nДень месяца (1-31)\nМесяц (1-12)\nДень недели (0-6, где 0 — воскресенье)\nМинуты (0-59)Часы (0-23)День месяца (1-31)Месяц (1-12)День недели (0-6, где 0 — воскресенье)Событие workflow_dispatch позволяет вручную запускать workflow через интерфейс GitHub.Событие release запускает workflow при создании релиза.Событие issue_comment запускает workflow при добавлении комментария к issue.Когда используется запуск GitHub Action через schedule необходимо учитывать следующие нюансы. Описанные в справке GitHub:Событие schedule может быть отложено в периоды высокой нагрузки при выполнении рабочего процесса GitHub Actions. Время высокой загрузки включает начало каждого часа. Если нагрузка достаточно высока, некоторые задания в очереди могут быть удалены. Чтобы уменьшить вероятность задержки, запланируйте выполнение рабочего процесса в другое время часа.В общедоступном репозитории запланированные рабочие процессы автоматически отключаются, если в течение 60 дней не происходит никаких действий с репозиторием.Создаёт виртуальную машину на ubuntu, можно создать и на Windows.Копирует в виртуальную машину всё содержимое репозитория.Устанавливает указанную версию R.Устанавливает на Linux специальный программный пакет, необходимый для установки R пакета httr и telegram.bot.Устанавливает на виртуальную машину необходимые пакеты.Считывает переменные среды из репозитория, и запускает выполнение R скрипта.","code":"name: Run R script daily\n\non:\n  schedule:\n    - cron: '0 10 * * *'  # Ежедневно в 10:00 UTC\n    - cron: '51 17 * * *'  # Ежедневно в 19:00 по Каирскому времени\n  workflow_dispatch:\n\njobs:\n  run-r-script:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n      \n    - name: Set timezone to Cairo\n      uses: szenius/set-timezone@v2.0\n      with:\n        timezoneLinux: \"Africa/Cairo\"\n        \n    - name: Log current time\n      run: date\n\n    - name: Set up R\n      uses: r-lib/actions/setup-r@v2\n      with:\n        r-version: '4.0.3'\n        \n    - name: Install Linux package\n      run: |\n        sudo apt-get install libcurl4-openssl-dev\n\n    - name: Install R packages\n      run: |\n        Rscript -e 'install.packages(c(\"curl\", \"httr\", \"jsonlite\", \"telegram.bot\"), repos=\"https://cran.rstudio.com/\")'\n\n    - name: Run R script\n      env:\n        EXCHANGE_RATE_API_KEY: ${{ secrets.EXCHANGE_RATE_API_KEY }}\n        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}\n        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}\n      run: |\n        Rscript R/currency_rate_sender.Rname: Run R script dailyon:\n  schedule:\n    - cron: '0 10 * * *'  # Ежедневно в 10:00 UTC\n    - cron: '51 17 * * *'  # Ежедневно в 19:00 по Каирскому времени\n  workflow_dispatch:jobs:\n  run-r-script:\n    runs-on: ubuntu-lateststeps:\n    - name: Checkout repository\n      uses: actions/checkout@v2\n- name: Set up R\n      uses: r-lib/actions/setup-r@v2\n      with:\n        r-version: '4.0.3'- name: Install Linux package\n      run: |\n        sudo apt-get install libcurl4-openssl-dev- name: Install R packages\n      run: |\n        Rscript -e 'install.packages(c(\"httr\", \"jsonlite\", \"telegram.bot\"), repos=\"https://cran.rstudio.com/\")'- name: Run R script\n      env:\n        EXCHANGE_RATE_API_KEY: ${{ secrets.EXCHANGE_RATE_API_KEY }}\n        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}\n        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}\n      run: |\n        Rscript R/currency_rate_sender.R"},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"создание-переменныз-среды-в-github-репозитоории","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.8 Создание переменныз среды в GitHub репозитоории","text":"Перейдите в ваш репозиторий на GitHub.Перейдите в раздел Settings.В левом меню выберите Secrets variables -> Actions.Нажмите на кнопку New repository secret и создайте следующие переменные:Создайте все необходимые вам переменные среды.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"публикация-на-github","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.9 Публикация на GitHub","text":"Теперь отправьте всё, что мы сделали коммитом на GitHub.В RStudio откройте вкладку GitВыделите все файлы галочкамиНажмите кнопку CommitНапишите комментарийНажмите кнопку CommitНажмите кнопку PushТеперь вы опубликовали ваш проект на GitHub.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"тестирование-рабочего-процесса-на-github","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.8.10 Тестирование рабочего процесса на GitHub","text":"Всё готово. Теперь вернитесь в свой репозиторий на GitHub, перейдите в Actions.Если тест пройдёт успешно то в следующий раз скрипт запустится автоматически по указанному вами рассписанию.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"заключение","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.9 Заключение","text":"Поздравляю с успешным завершением первой главы! Мы начали наше путешествие в мир Telegram-ботов, настроив базовый бот и изучив основы взаимодействия с API Telegram. Теперь у вас есть все необходимое для создания простого бота, и вы готовы перейти к более сложным аспектам разработки. В следующей главе мы углубимся в добавление команд и фильтров, чтобы ваш бот мог выполнять более специфические задачи и обрабатывать сообщения более эффективно.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"тесты-и-задания","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.10 Тесты и задания","text":"","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"тесты","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.10.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"создаём-бота-и-отправляем-с-его-помощью-сообщения-в-telegram.html","id":"задания","chapter":"Глава 1 Создаём бота, и отправляем с его помощью сообщения в telegram","heading":"1.10.2 Задания","text":"Создайте с помощью BotFather бота.Перейдите к диалогу с ботом, и узнайте идентификатор вашего с ботом чата.Отправьте с помощью созданного бота в telegram первые 20 строк из встроенного в R набора данных ToothGrowth.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","text":"Во второй главе нашего руководства мы продолжим развитие вашего Telegram-бота, сосредоточив внимание на добавлении команд и фильтров сообщений. Вы узнаете, как реализовать команды, которые пользователи могут отправлять боту, и как обрабатывать их с помощью пакета telegram.bot.Мы рассмотрим, как настроить обработку команд для выполнения различных действий и внедрить фильтры для управления типами сообщений. Эти инструменты позволят вашему боту стать более интерактивным и удобным для пользователей.Эта глава предоставит вам знания и навыки, необходимые для создания более функционального и адаптивного бота, который сможет эффективно взаимодействовать с аудиторией. Надеюсь, что изучение этих возможностей вдохновит вас на создание уникальных и полезных решений.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"видео-по-добавлению-боту-поддержки-команд","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.1 Видео по добавлению боту поддержки команд","text":"","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"класс-updater","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.2 Класс Updater","text":"Updater - это класс, который упрощает вам разработку телеграм бота, и использует под капотом класс Dispetcher. Назначение класса Updater заключается в том, что бы получить обновления от бота (в предыдущей главе мы использовали для этой цели метод getUpdates()), и передать их далее в Dispetcher.В свою очередь Dispetcher содержит в себе созданные вами обработчики, т.е. объекты класса Handler.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"handlers---обработчики","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.3 Handlers - обработчики","text":"С помощью обработчиков вы добавляете в Dispetcher реакции бота на различные события. На момент написания книги в telegram.bot добавлены следующие типы обработчиков:MessageHandler - Обработчик сообщенийCommandHandler - Обработчик командCallbackQueryHandler - Обработчик данных отправляемых из Inline клавиатурErrorHandler - Обработчик ошибок при запросе обновлений от бота","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"добавляем-первую-команду-боту-обработчик-команд","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.4 Добавляем первую команду боту, обработчик команд","text":"Если вы никогда ранее не использовали ботов, и не в курсе, что такое команда, то команды боту необходимо отправлять с помощью прямого слеша / в качестве префикса.Начнём мы с простых команд, т.е. научим нашего бота здороваться по команде /hi.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Метод start_polling() класса Updater, который используется в конце кода, запускает бесконечный цикл запроса и обработки обновлений от бота.Мы написали боту метод say_hello(). Методами бота являются функции с двумя обязательными аргументами:bot - объект бота, с помощью которого вы можете выполнять любые, доступные боту операции: отправлять сообщения, удалять сообщения, и так далее.update - полученное от пользоватя сообщение (обновление бота).Внутри кода метода вы можете обращаться и к боту, и к обновлению. С методами бота мы познакомились в первой главе, теперь давайте я вкратце опишу методы, доступные в приходящих обновлениях:from_chat_id() - получить идентификатор чата, из которого боту было отправлено сообщениеfrom_user_id() - получить идентификатор пользователя, который отправил боту сообщениеeffective_chat() - получить подробную информацию о чате, из которого бот получил сообщениеeffective_message() - получить подробную информацию о сообщение, включая текс, вложения и т.д.effective_user() - получить подробную информацию о пользователе, который отправил сообщениеТеперь откроем телеграм, и напишем нашему боту первую команду /hi.Теперь наш бот понимает команду /hi, и умеет с нами здороваться.Схематически процесс построения такого простейшего бота можно изобразить следующим образом.Создаём экземпляр класса Updater;Создаём методы, т.е. функции которые будет выполнять наш бот. В примере кода это функция say_hello(). Функции, которые вами будут использоваться как методы бота должны иметь два обязательных аргумента - bot и update, и один необязательный - args. Аргумент bot, это и есть ваш бот, с его помощью вы можете отвечать на сообщения, отправлять сообщения, или использовать любые другие доступные боту методы. Аргумент update это то, что бот получил от пользователя, по сути, то что в первой главе мы получали методом getUpdates(). Аргумент args позволяет вам обрабатывать дополнительные данные отправленные пользователем вместе с командой, к этой теме мы ещё вернёмся немного позже;Создаём обработчики, т.е. связываем какие-то действия пользователя с созданными на прошлом шаге методами. По сути обработчик это триггер, событие которое вызывает какую-то функцию бота. В нашем примере таким триггером является отправка команды /hi, и реализуется командой hi_hendler <- CommandHandler('hi', say_hello). Первый аргумент функции CommandHandler() позволяет вам задать команду, в нашем случае hi, на которую будет реагировать бот. Второй аргумент позволяет указать метод бота, мы будем вызывать метод say_hello, который будет выполняться если пользователь вызвал указанную в первом аргументе команду;Далее добавляем созданный обработчик в диспетчер нашего экземпляра класса Updater. Добавлять обработчики можно несколькими способами, в примере выше я использовал простейший, с помощью знака +, т.е. updater <- updater + hi_hendler. То же самое можно сделать с помощью метода add_handler(), который относится к классу Dispatcher, найти этот метод можно так: updater$dispatcher$add_handler();Запускаем бота с помощью команды start_polling().","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\nsay_hello <- function(bot, update) {\n\n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n\n  # Отправка приветственного сообщения\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\")\n\n}\n\n# создаём обработчик\nhi_hendler <- CommandHandler('hi', say_hello)\n\n# добаляем обработчик в диспетчер\nupdater <- updater + hi_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"обработчик-текстовых-сообщений-и-фильтры","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.5 Обработчик текстовых сообщений и фильтры","text":"Как отправлять боту команды мы разобрались, но иногда нам требуется, что бы бот реагировал не только на команды, но и на какие-то обычные, текстовые сообщения. Для этого необходимо использовать обработчики сообщений - MessageHandler.Обычный MessageHandler будет реагировать на абсолютно все входящие сообщения. Поэтому зачастую обработчики сообщений используются вместе с фильтрами. Давайте научим бота здороваться не только по команде /hi, но и всегда, когда в сообщении отправленном боту встречается одно из следующих слов: привет, здравствуй, салют, хай, бонжур.Пока мы не будем писать какие-то новые методы, т.к. у нас уже есть метод с помощью которого бот с нами здоровается. От нас требуется только создать нужный фильтр и обработчик сообщений.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Итак, в первую очередь мы научили бота не просто здороваться, а отвечать на приветствие. Сделали мы это с помощью аргумента reply_to_message_id, который доступен в методе sendMessage(), в который необходимо передать id сообщения на которое требуется ответить. Получить id сообщения можно вот так: update$message$message_id.Но главное, что мы сделали - добавили боту фильтр с помощью функции BaseFilter():Как вы могли заметить, фильтры необходимо добавлять в объект MessageFilters, в котором изначально уже есть небольшой набор готовых фильтров. В нашем примере в объект MessageFilters мы добавили элемент hi, это новый фильтр.В функцию BaseFilter() вам необходимо передать фильтрующую функцию. По сути, фильтр - это просто функция, которая получает экземпляр сообщения и возвращает TRUE или FALSE. В нашем примере, мы написали простейшую функцию, которая с помощью базовой функции grepl() проверяет текст сообщения, и если он соответствует регулярному выражению привет|здравствуй|салют|хай|бонжур возвращает TRUE.Далее мы создаём обработчик сообщений hi_txt_hnd <- MessageHandler(say_hello, filters = MessageFilters$hi). Первый аргумент функции MessageHandler() - метод, который будет вызывать обработчик, а второй аргумент - это фильтр по которому он будет вызываться. В нашем случае это созданный нами фильтр MessageFilters$hi.Ну и в итоге, мы добавляем в диспетчер созданный только, что обработчик hi_txt_hnd.Как я уже писал выше, в пакете telegram.bot и объекте MessageFilters уже есть набор встроенных фильтров, которые вы можете использовать:- Все сообщенияtext - Текстовые сообщенияcommand - Команды, т.е. сообщения которые начинаются на /reply - Сообщения, которые являются ответом на другое сообщениеaudio - Сообщения в которых содержится аудио файлdocument - Сообщения с отправленным документомphoto - Сообщения с отправленными изображениямиsticker - Сообщения с отправленным стикеромvideo - Сообщения с видеоvoice - Голосовые сообщенияcontact - Сообщения в которых содержится контант телеграм пользователяlocation - Сообщения с геолокациейvenue - Пересылаемые сообщенияgame - ИгрыЕсли вы хотите совместить некоторые фильтры в одном обработчике просто используйте знак | - в качестве логического ИЛИ, и знак & в качестве логического И. Например, если вы хотите что бы бот вызывал один и тот же метод когда он получает видео, изображение или документ используйте следующий пример создания обработчика сообщений:","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветвия\nsay_hello <- function(bot, update) {\n\n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n\n  # Отправляем приветсвенное сообщение\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\",\n                  reply_to_message_id = update$message$message_id)\n\n}\n\n# создаём фильтры\nMessageFilters$hi <- BaseFilter(function(message) {\n\n  # проверяем, встречается ли в тексте сообщения слова: привет, здравствуй, салют, хай, бонжур\n  grepl(x           = message$text,\n        pattern     = 'привет|здравствуй|салют|хай|бонжур',\n        ignore.case = TRUE)\n  }\n)\n\n# создаём обработчик\nhi_hendler <- CommandHandler('hi', say_hello) # обработчик команды hi\nhi_txt_hnd <- MessageHandler(say_hello, filters = MessageFilters$hi)\n\n# добаляем обработчики в диспетчер\nupdater <- updater +\n             hi_hendler +\n             hi_txt_hnd\n\n# запускаем бота\nupdater$start_polling()\n# создаём фильтры\nMessageFilters$hi <- BaseFilter(\n\n  # анонимная фильтрующая функция\n  function(message) {\n\n    # проверяем, встречается ли в тексте сообщения слова приветствия\n    grepl(x           = message$text,\n          pattern     = 'привет|здравствуй|салют|хай|бонжур',\n          ignore.case = TRUE)\n  }\n\n)\nupdater <- updater +\n             hi_hendler +\n             hi_txt_hnd\nhandler <- MessageHandler(callback,\n  MessageFilters$video | MessageFilters$photo | MessageFilters$document\n)"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"добавление-команд-с-параметрами","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.6 Добавление команд с параметрами","text":"Мы уже знаем, что такое команды, как их создавать и как заставить бота выполнить нужную команду. Но в некоторых случаях помимо названия команды, нам необходимо передать некоторые данные для её выполнения.Ниже пример бота, который по заданной дате и стране возвращает вам тип дня из производственного календаря.Приведённый ниже бот использует API производственного календаря isdayoff.ru.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Мы создали бота, который в арсенале имеет всего один метод check_date, данный метод вызывается одноимённой командой.Но, помимо имени команды, данный метод ждёт от вас введения двух параметров, код страны и дату. Далее бот проверяется, является ли заданный день в указанной стране выходным, сокращённым или рабочим согласно официального производственного календаря.Что бы создаваемый нами метод принимал дополнительные параметры вместе с командой, используйте аргумент pass_args = TRUE в функции CommandHandler(), и при создании метода, помимо обязательных аргументов bot, update создайте опциональный - args. Созданный таким образом метод будет принимать параметры, которые вы передаёте боту после названия команды. Параметры необходимо между собой разделять пробелом, в метод они поступят в виде текстового вектора.Давайте запустим, и протестируем нашего бота.","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветвия\ncheck_date <- function(bot, update, args) {\n\n  # входящие данные\n  day     <- args[1]  # дата\n  country <- args[2]  # страна\n\n  # проверка введённых параметров\n  if ( !grepl('\\\\d{4}-\\\\d{2}-\\\\d{2}', day) ) {\n\n    # Send Custom Keyboard\n    bot$sendMessage(update$from_chat_id(),\n                    text = paste0(day, \" - некорреткная дата, введите дату в формате ГГГГ-ММ-ДД\"),\n                    parse_mode = \"Markdown\")\n\n  } else {\n    day <- as.Date(day)\n    # переводим в формат POSIXtl\n    y <- format(day, \"%Y\")\n    m <- format(day, \"%m\")\n    d <- format(day, \"%d\")\n\n  }\n\n  # страна для проверки\n  ## проверяем задана ли страна\n  ## если не задана устанавливаем ru\n  if ( ! country %in% c('ru', 'ua', 'by', 'kz', 'us') ) {\n\n    # Send Custom Keyboard\n    bot$sendMessage(update$from_chat_id(),\n                    text = paste0(country, \" - некорретктный код страны, возможнные значения: ru, by, kz, ua, us. Запрошены данные по России.\"),\n                    parse_mode = \"Markdown\")\n\n    country <- 'ru'\n\n  }\n\n  # запрос данных из API\n  # компоновка HTTP запроса\n  url <- paste0(\"https://isdayoff.ru/api/getdata?\",\n                \"year=\",  y, \"&\",\n                \"month=\", m, \"&\",\n                \"day=\",   d, \"&\",\n                \"cc=\",    country, \"&\",\n                \"pre=1&\",\n                \"covid=1\")\n\n  # получаем ответ\n  res <- readLines(url)\n\n  # интрепретация ответа\n  out <- switch(res,\n                \"0\"   = \"Рабочий день\",\n                \"1\"   = \"Нерабочий день\",\n                \"2\"   = \"Сокращённый рабочий день\",\n                \"4\"   = \"covid-19\",\n                \"100\" = \"Ошибка в дате\",\n                \"101\" = \"Данные не найдены\",\n                \"199\" = \"Ошибка сервиса\")\n\n  # отправляем сообщение\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(day, \" - \", out),\n                  parse_mode = \"Markdown\")\n\n}\n\n# создаём обработчик\ndate_hendler <- CommandHandler('check_date', check_date, pass_args = TRUE)\n\n# добаляем обработчик в диспетчер\nupdater <- updater + date_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"запускаем-бота-в-фоновом-режиме","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.7 Запускаем бота в фоновом режиме","text":"Последний шаг который нам осталось выполнить - запустить бота в фоновом режиме.Для этого следуйте по описанному ниже алгоритму:Сохраните код бота в файл с расширением R. При работе в RStudio это делается через меню File, командой Save ….Добавьте путь к папке bin, которая в свою очередь находится в папке в которую вы установили язык R в переменную Path, инструкция тут.Создайте обычный текстовый файл, в котором пропишите 1 строку: R CMD BATCH C:\\Users\\Alsey\\Documents\\my_bot.R. Вместо *C:_bot.R* пропишите путь к своему скрипту бота. При этом важно, что бы в пути не встречалась кириллица и пробелы, т.к. это может вызвать проблемы при запуске бота. Сохраните его, и замените его расширение с txt на bat.Откройте планировщик заданий Windows, есть множество способов это сделать, например откройте любую папку и в адресс введите %windir%\\system32\\taskschd.msc /s. Другие способы запуска можно найти тут.В верхнем правом меню планировщика нажмите “Создать задачу…”.На вкладке “Общие” задайте произвольное имя вашей задаче, и переключатель перевидите в состояние “Выполнять для всех пользователей”.Перейдите на вкладку “Действия”, нажмите “Создать”. В поле “Программа или сценарий” нажмите “Обзор”, найдите созданный на втором шаге bat файл, и нажмите ОК.Жмём ОК, при необходимости вводим пароль от вашей учётной записи операционной системы.Находим в планировщике созданную задачу, выделяем и в нижнем правом углу жмём кнопку “Выполнить”.Наш бот запущен в фоновом режиме, и будет работать до тех пор, пока вы не остановите задачу, или не выключите ваш ПК или сервер на котором его запустили.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"обработка-голосовых-сообщений.-переводим-голосовое-сообщение-в-текст","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.8 Обработка голосовых сообщений. Переводим голосовое сообщение в текст","text":"давайте разберём ещё один довольно полезный пример, напишем бота, который будет принимать голосовые сообщение, при чём эти голосовые сообщения можно пересылать из любого другого чата, а на выходе давать вам его текстовую расшифровку.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"функция-для-преобразования-голоса-в-текст","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.8.1 Функция для преобразования голоса в текст","text":"Для начала нам необходимо разработать основу, т.е. функцию, которая на вход получит аудио файл, и преобразует его в текст. Для этого можно использовать Google Speech--Text API. Это условно бесплатный сервис, бесплатно вы можете в месяц конвертировать до 60 минут аудиоо в текст. Этот лимит в будущем возможно будет изменён.Прежде всего, нам нужно настроить проект в Google Cloud:Зайдите на console.cloud.google.com и создайте новый проект.Включите API Speech--Text в разделе “APIs & Services”.Создайте учетные данные (Service Account Key) для доступа к API:\n3.1. Перейдите в “APIs & Services” > “Credentials”\n3.2. Нажмите “Create Credentials” > “Service Account Key”\n3.3. Выберите роль “Project” > “Owner”\n3.4. Скачайте JSON файл с ключомТеперь установим пакеты, которые нам понадобятся:Теперь рассмотрим сам код функции, которая ляжет в основу нашего будущего бота:Голосовые сообщения в telegram хранятся в ogg формате, который данная функция успешно преобразовывает в текст. Для теста можете скачать voice.ogg файл и протестировать работу описанной выше функции.Перед запуском не забудьте заменить “path///google_cloud_credentials.json” на путь к скачанному вами из Google Cloud ключу сервисного аккаунта.На выходе получите следующий текст:","code":"\ninstall.packages(c(\"tuneR\", \"seewave\", \"googledrive\", \"googleAuthR\", \"googleLanguageR\", \"av\"))\nlibrary(tuneR)\nlibrary(seewave)\nlibrary(googledrive)\nlibrary(googleAuthR)\nlibrary(googleLanguageR)\nlibrary(av)\n\nspeech_to_text_from_audio <- function(audio_file_path) {\n  # Определяем расширение файла\n  file_ext <- tolower(tools::file_ext(audio_file_path))\n  \n  # Создаем временный WAV файл\n  temp_wav_file <- tempfile(fileext = \".wav\")\n  \n  # Обработка в зависимости от типа файла\n  if (file_ext == \"mp3\") {\n    audio <- readMP3(audio_file_path)\n  } else if (file_ext == \"wav\") {\n    audio <- readWave(audio_file_path)\n  } else if (file_ext == \"ogg\") {\n    # Конвертируем OGG в WAV\n    av_audio_convert(audio_file_path, temp_wav_file)\n    audio <- readWave(temp_wav_file)\n  } else {\n    stop(\"Неподдерживаемый формат файла. Поддерживаются только MP3, WAV и OGG.\")\n  }\n  \n  # Если аудио стерео, конвертируем в моно\n  if (audio@stereo) {\n    audio <- mono(audio, \"both\")\n  }\n  \n  # Изменяем частоту дискретизации на 16000 Гц, только если текущая частота отличается\n  if (audio@samp.rate != 16000) {\n    audio_resampled <- resamp(audio, g = 16000, output = \"Wave\")\n  } else {\n    audio_resampled <- audio\n  }\n  \n  # Записываем обработанное аудио во временный WAV файл\n  writeWave(audio_resampled, temp_wav_file)\n  \n  # Выполняем распознавание речи\n  result <- tryCatch({\n    gl_speech(temp_wav_file, \n              languageCode = \"ru-RU\",\n              sampleRateHertz = 16000)$transcript\n  }, error = function(e) {\n    return(paste(\"Ошибка при распознавании речи:\", e$message))\n  })\n  \n  # Удаляем временный WAV файл\n  file.remove(temp_wav_file)\n  \n  # Возвращаем результат\n  return(result$transcript)\n}\n# Пример использования:\n# Не забудьте аутентифицироваться перед использованием функции\ngl_auth(\"path/to/your/google_cloud_credentials.json\")\n\n# Теперь вы можете использовать функцию так:\nogg_file <- \"path/to/your/voice.ogg\"\n\ntranscript_ogg <- speech_to_text_from_audio(ogg_file)небольшая начитка для тестирования преобразования голоса в текст с помощью языка R"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"код-бота-преобразуещего-голосовое-сообщение-в-текст","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.8.2 Код бота преобразуещего голосовое сообщение в текст","text":"Теперь давайте напишем бота, в основе которого будет лежать данная функция, он будет получать любое голосовое сообщение, переводить его в текстовый формат и отправлять в виде текстового сообщения.Примечание! Для того, что бы приведённый ниже код работал вам необходимо заранее сохранить токен бота в переменную среды, и заменить “my_bot” на указанное в названии переменной среды имя вашего бота. Так же необходимо заменить “path///google_cloud_credentials.json” на путь к скачанному вами из Google Cloud ключу сервисного аккаунта.","code":"\nlibrary(telegram.bot)\nlibrary(tuneR)\nlibrary(seewave)\nlibrary(googledrive)\nlibrary(googleAuthR)\nlibrary(googleLanguageR)\nlibrary(av)\n\n# Функция для преобразования аудио в текст (используем ранее созданную функцию)\nspeech_to_text_from_audio <- function(audio_file_path) {\n  # Определяем расширение файла\n  file_ext <- tolower(tools::file_ext(audio_file_path))\n  \n  # Создаем временный WAV файл\n  temp_wav_file <- tempfile(fileext = \".wav\")\n  \n  # Обработка в зависимости от типа файла\n  if (file_ext == \"mp3\") {\n    audio <- readMP3(audio_file_path)\n  } else if (file_ext == \"wav\") {\n    audio <- readWave(audio_file_path)\n  } else if (file_ext == \"ogg\") {\n    # Конвертируем OGG в WAV\n    av_audio_convert(audio_file_path, temp_wav_file)\n    audio <- readWave(temp_wav_file)\n  } else {\n    stop(\"Неподдерживаемый формат файла. Поддерживаются только MP3, WAV и OGG.\")\n  }\n  \n  # Если аудио стерео, конвертируем в моно\n  if (audio@stereo) {\n    audio <- mono(audio, \"both\")\n  }\n  \n  # Изменяем частоту дискретизации на 16000 Гц, только если текущая частота отличается\n  if (audio@samp.rate != 16000) {\n    audio_resampled <- resamp(audio, g = 16000, output = \"Wave\")\n  } else {\n    audio_resampled <- audio\n  }\n  \n  # Записываем обработанное аудио во временный WAV файл\n  writeWave(audio_resampled, temp_wav_file)\n  \n  # Выполняем распознавание речи\n  result <- tryCatch({\n    gl_speech(temp_wav_file, \n              languageCode = \"ru-RU\",\n              sampleRateHertz = 16000)$transcript\n  }, error = function(e) {\n    return(paste(\"Ошибка при распознавании речи:\", e$message))\n  })\n  \n  # Удаляем временный WAV файл\n  file.remove(temp_wav_file)\n  \n  # Возвращаем результат\n  return(result$transcript)\n}\n\n# Аутентификация в Google Cloud (делаем это перед запуском бота)\n# Не забудьте аутентифицироваться в Google Cloud перед запуском бота\ngl_auth(\"path/to/your/google_cloud_credentials.json\")\n\n# Функция для обработки голосовых сообщений\nhandle_voice <- function(bot, update) {\n  # Получаем информацию о голосовом сообщении\n  voice <- update$message$voice\n  \n  # Получаем файл\n  file <- bot$getFile(voice$file_id)\n  \n  # Создаем временный файл для сохранения голосового сообщения\n  temp_file <- tempfile(fileext = \".ogg\")\n  \n  # Получаем полный URL для скачивания файла\n  file_url  <- paste0(\"https://api.telegram.org/file/bot\", bot_token('my_bot'), \"/\", file$file_path)\n  \n  # Скачиваем файл\n  download.file(file_url, temp_file, mode = \"wb\")\n  \n  # Преобразуем голосовое сообщение в текст\n  text <- speech_to_text_from_audio(temp_file)\n  \n  # Отправляем текст обратно пользователю\n  bot$sendMessage(chat_id = update$message$chat_id,\n                  text = paste(\"Расшифровка вашего голосового сообщения:\\n\\n\", text))\n  \n  # Удаляем временный файл\n  file.remove(temp_file)\n}\n\n# Функция для обработки текстовых сообщений\nhandle_text <- function(bot, update) {\n  bot$sendMessage(chat_id = update$message$chat_id,\n                  text = \"Пожалуйста, отправьте голосовое сообщение для расшифровки.\")\n}\n\n# Создание и настройка updater\nupdater <- Updater(bot_token('my_bot'))\n\n# Добавляем обработчики с правильными фильтрами\nupdater <- updater + CommandHandler(\"start\", handle_text)\nupdater <- updater + MessageHandler(handle_voice, MessageFilters$voice)\nupdater <- updater + MessageHandler(handle_text, MessageFilters$text)\n\n# Запуск бота\nupdater$start_polling()"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"бот-для-сбора-статистики-из-telegram-чатов","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.9 Бот для сбора статистики из Telegram чатов","text":"Боты довольно функциональны, в том числе они могут быть модераторами чатов, или просто собирать статистику по активности в группах. В этом разделе я приведу пример бота, который собирает во внутреннюю базу данных статистику о сообщениях и новых учатсниках чатов, в которые он добавлен в роли администратора. Так же мы добавим боту команду, которая будет выводить статистику за любой указанный период.Что бы бот мог собирать статистику из чата, или быть его модератором, у него обязательно должны быть в этом чате админские права.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"как-добавить-бота-в-группу","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.9.1 Как добавить бота в группу","text":"Для того, что бы использовать бота в публичных или закрытых группах, изначально проверьте соответвующую настройку в BotFather. По умолчанию эта настройка должна быть включена. Находится она тут: /mybots -> @bot_username -> Bot Settings -> Allow Groups?. Если настройка включена то вы увидите следующее сообщение:Далее добааляете бота в нужные группы и используете его через команды. Если вам необходимо сделать так, что бы бот прослушивал не только команды, но и все сообщения в группе, то вам необходимо назначить его администратором, посе чего вы увидите что бот имеет доступ ко всем сообщениям.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"подготовка-базы-данных-для-хранения-статистики","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.9.2 Подготовка базы данных для хранения статистики","text":"Ранее в этой книге мы рассматривали ботов, которые получают с данными полученными на лету, т.е. данные которые в моменте запрашиваются, используются и далее они нам не нужны. В данном случае задача в том, что бы собирать статистику из чатов, и потом при необходимости её запрашивать, поэтому для начала нам надо развернуть базу данных.В нашем случае в базе будет всего 2 таблицы, в одну мы будем собирать данные о сообщениях, а в другую о добавленных пользователях. использовать мы будет встраивамаю в нашего бота SQLite базу.Таблица для хранения данных о сообщениях:Таблица для хранения данных о новых участниках:","code":"-- message definition\n\nCREATE TABLE `message` (\n  `chat_id` REAL,\n  `chat_title` TEXT,\n  `msg_id` INTEGER,\n  `timestamp` TEXT,\n  `date` TEXT,\n  `user_id` INTEGER,\n  `user_first_name` TEXT,\n  `user_last_name` TEXT,\n  `tg_username` TEXT,\n  `text` TEXT,\n  `is_link` INTEGER,\n  `links` INTEGER\n);-- new_users definition\n\nCREATE TABLE `new_users` (\n  `chat_id` REAL,\n  `chat_title` TEXT,\n  `msg_id` INTEGER,\n  `timestamp` TEXT,\n  `date` TEXT,\n  `users_add_id` REAL,\n  `users_add_first_name` TEXT,\n  `users_add_last_name` TEXT,\n  `users_add_tg_username` TEXT,\n  `new_user_id` REAL,\n  `new_user_first_name` TEXT,\n  `new_user_last_name` TEXT,\n  `new_user_tg_username` TEXT\n);"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"методы-бота","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.9.3 Методы бота","text":"Для того, что бы код нашего бота был более читаем, код каждого из его методов я разделю на отдельные файлы, зачастую такой способ хранения функций используется при разработке пакетов. В нашем случае у бота будет всего 3 функции, давайте с помощью пакета usethis создадим файлы для этих функций.Функцию to_tg_table() мы с вами рассматривали в первой главе, остальные 3 функции разработаны специально для этого бота. Функция usethis::use_r() создаёт в вашем проекте каталог R, и в нём файлы с заданными в единственном её аргументе названием.теперь приведу пример кода для каждого метода:Данная функция перехватает каждое текстовое сообщение в чате, далее проверяет его на наличие ссылок, и собирает информацию об этом сообщении:Идентификатор чата в котором было перехвачено это сообщениеНазвание чатаИдентификатор сообщенияДата и время когда было отправлено сообщениеДата когда было отправлено сообщениеID пользователя в telegram, который отправил сообщениеИмя пользователя (если указано в telegram)Фамилия пользователя (если указано в telegram)Username в telegramтекст сообщенияесть ли в сообщении хотя бы одна ссылкаПредставленные в сообщение ссылки через запятуюДалее функция записывает собранную информацию в таблицу message нашей базы данных.Данная функция схожа с предыдущей, но она собирает информацию о добавленном участнике чата.Идентификатор чата в котором было перехвачено это сообщениеНазвание чатаИдентификатор сообщениядата и время когда был добавлен пользовательДата когда был добавлен пользовательИдентификатор пользователя, который добавил новго участника в чатИмя пользователя, который добавил новго участника в чат (если указано в telegram)Фамилия пользователя, который добавил новго участника в чат (если указано в telegram)Username в telegram, который добавил новго участника в чатИдентификатор добавленого участникаИмя пользователя, добавленого участника (если указано в telegram)Фамилия пользователя, добавленого участника (если указано в telegram)Username в telegram, добавленого участникаСобранную информацию данный метод дописывает в таблицу new_users.Данная функция запрашивает из базы данных собранную статистику за указанный период, формирует график и таблицу и отправляет вам в telegram.Этот метод позволяет передать аргумент, в качестве аргумента вы моете указать произвольный период, за который зотите получить статистику. В качестве преиода необходимо указать одну из функций пакета timeperiodsR с префиксом previous млм , например this_month, previous_quarter и т.д.Далее запрашивает за указанный период статистику из таблиц message и new_users, на основе статистики строит таблицу и график по 5 наиболее активным пользователям за указанный период. Формирует и отправляет сообщение со статистикой, выглядит в итоге оно примерно так:Эту функцию мы уже разбирали в первой главе книги.","code":"\nusethis::use_r('get_message')  # функция для сбора данных о сообщениях\nusethis::use_r('get_new_user') # функция для сбора данных о новых участниках\nusethis::use_r('chat_stat')    # функция запроса статистики по чатам\nusethis::use_r('to_tg_table')  # Вспомогательная функция приволящая data.frame в формат таблицы для отправки в telegram\nget_message <- function(bot, update) {\n  \n  msg <- update$effective_message()\n  \n  # анализ ссылок в сообщении\n  if (map_lgl(msg$entities, ~ .x$type == \"url\") %>% sum(na.rm = T) %>% .[1] > 0) {\n    is_link <- TRUE\n    link    <- map_chr(\n      msg$entities,\n      ~ str_sub(msg$text, .x$offset, .x$offset + .x$length)\n    ) %>% \n      str_remove_all('\\\\n') %>% \n      str_c(collapse = ', ')\n      \n      str_sub(string = msg$text, msg$entities[[1]]$offset, msg$entities[[1]]$offset + msg$entities[[1]]$length)\n  } else {\n    is_link <- FALSE\n    link    <- NA\n  }\n  \n  msg_info <- tibble(\n    chat_id         = msg$chat$id,\n    chat_title      = msg$chat$title,\n    msg_id          = msg$message_id,\n    timestamp       = as.character(as.POSIXct(msg$date,  origin = \"1970-01-01\")),\n    date            = as.character(as.Date(as.POSIXlt(msg$date,  origin = \"1970-01-01\"))),\n    user_id         = msg$from$id,\n    user_first_name = ifelse(length(gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$first_name)) == 0, NA_character_, gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$first_name)),\n    user_last_name  = ifelse(length(gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$last_name)) == 0, NA_character_, gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$last_name)),\n    tg_username     = msg$from$username,\n    text            = msg$text,\n    is_link         = is_link,\n    links           = link\n  )\n  \n  con <- dbConnect(SQLite(), here(db_name))\n  dbWriteTable(conn = con, name = msg_tbl, value = msg_info, append = TRUE, overwrite = FALSE)\n  dbDisconnect(con)\n  \n}\nget_new_user <- function(bot, update) {\n  \n  msg <- update$effective_message()\n  \n  msg_info <- tibble(\n    chat_id               = msg$chat$id,\n    chat_title            = msg$chat$title,\n    msg_id                = msg$message_id,\n    timestamp             = as.character(as.POSIXct(msg$date,  origin = \"1970-01-01\")),\n    date                  = as.character(as.Date(as.POSIXlt(msg$date,  origin = \"1970-01-01\"))),\n    users_add_id          = msg$from$id,\n    users_add_first_name  = ifelse(length(gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$first_name)) == 0, NA_character_, gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$first_name)),\n    users_add_last_name   = ifelse(length(gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$last_name)) == 0, NA_character_, gsub(\"[^\\x01-\\x7F]\", \"\", msg$from$last_name)),\n    users_add_tg_username = msg$from$username,\n    new_user_id           = msg$new_chat_member$id,\n    new_user_first_name   = ifelse(length(gsub(\"[^\\x01-\\x7F]\", \"\", msg$new_chat_member$first_name)) == 0, NA_character_, gsub(\"[^\\x01-\\x7F]\", \"\", msg$new_chat_member$first_name)),\n    new_user_last_name    = ifelse(length(gsub(\"[^\\x01-\\x7F]\", \"\", msg$new_chat_member$last_name)) == 0, NA_character_, gsub(\"[^\\x01-\\x7F]\", \"\", msg$new_chat_member$last_name)),\n    new_user_tg_username  = msg$new_chat_member$username\n  )\n  \n  con <- dbConnect(SQLite(), here(db_name))\n  dbWriteTable(conn = con, name = new_user_tbl, value = msg_info, append = TRUE, overwrite = FALSE)\n  dbDisconnect(con)\n  \n}\nchat_stat <- function(bot, update, args) {\n  \n  function_list <- ls(\"package:timeperiodsR\") %>% .[grepl(pattern = '^previous|^this', x = .)]\n  func_names <- str_c(ls(\"package:timeperiodsR\") %>% .[grepl(pattern = \"^previous|^this\", x = .)], collapse = \", \")\n  \n  if (is.null(args)) {\n    \n    bot$sendMessage(\n      update$from_chat_id(),\n      text       = str_glue('Вы не указали период за который необходимо получить статистику, доступные периоды: {func_names}. \\n По умолчанию устанавливаю период this_month.'),\n      parse_mode = 'html'\n    )\n    \n    args <- 'this_month'\n  }\n  \n  if (!args[1] %in% function_list) {\n    \n    bot$sendMessage(\n      update$from_chat_id(),\n      text       = str_glue('Вы указали некорректный период ({args}), доступные периоды: {func_names}. \\n По умолчанию устанавливаю период this_month.'),\n      parse_mode = 'html'\n    )\n    args <- 'this_month'\n  }\n  \n  bot$sendChatAction(\n    update$from_chat_id(),\n    action = \"typing\"\n  )\n  \n  period <- do.call(args[1], list(x = Sys.Date()))\n  \n  con <- dbConnect(SQLite(), here(db_name))\n  \n  messages <- dbGetQuery(\n    conn = con, \n    statement = str_glue(\n      'SELECT * \n      FROM message\n      WHERE date(date) BETWEEN \"{period$start}\" AND \"{period$end}\" '\n    ))\n  \n  new_users <- dbGetQuery(\n    conn = con, \n    statement = str_glue(\n      'SELECT * \n      FROM new_users\n      WHERE date(date) BETWEEN \"{period$start}\" AND \"{period$end}\" '\n    ))\n  \n  dbDisconnect(con)\n  \n  chats <- unique(messages$chat_title)\n  \n  for (chat in chats) {\n    \n    chat_msg_data  <- filter(messages, chat_title == chat)\n    chat_new_users <- filter(new_users, chat_title == chat)\n    \n    active_users <- n_distinct(chat_msg_data$user_id)\n    total_msg    <- n_distinct(chat_msg_data$msg_id)\n    events_links <- filter(chat_msg_data, str_detect(links, 'calendar.google.com')) %>% nrow()\n    total_links  <- sum(chat_msg_data$is_link)\n    new_users_n  <- nrow(chat_new_users)\n    \n    top_active_users <- chat_msg_data %>% \n      count(tg_username, user_first_name, user_last_name, sort = T) %>% \n      mutate(user_last_name = replace_na(user_last_name, '')) %>% \n      mutate(tg_username = if_else(is.na(tg_username), str_glue('{user_first_name} {user_last_name}'), tg_username)) %>% \n      select(tg_username, n) %>% \n      slice_head(n = 5) %>% \n      mutate(tg_username = str_to_lower(tg_username)) %>% \n      select('contacts_telegram', 'n') %>% \n      rename( msg = n ) \n    \n    ggplot(top_active_users, aes(y = forcats::fct_reorder(contacts_telegram, msg, median), x = msg)) +\n      geom_col(aes(fill = msg)) +\n      theme(axis.text.y = element_text(size = 8), \n            plot.subtitle = element_text(size = 10)) +\n      scale_fill_gradient(high=hcl(15,100,75), low=hcl(195,100,75)) +\n      xlab(\"Ник\") +\n      ylab('К-во сообщений') +\n      guides(fill=FALSE) +\n      ggtitle(label = chat, subtitle = 'Top 5 участников по активности')\n    \n    ggsave('top5.png', device = 'png', units = 'cm', width = 13, height = 8)\n    \n    top_active_users <- to_tg_table(top_active_users)\n    \n    tg_msg <- str_glue(\n      'Чат *{chat}*',\n      'Период: {format(period$start, \"%d.%m.%Y\")} - {format(period$end, \"%d.%m.%Y\")}',\n      '',\n      'Общая статистика:',\n      'Активных пользователей: {active_users}',\n      'Всего сообщений: {total_msg}',\n      'Сообщений с ссылками: {total_links}',\n      'Новых пользователей: {new_users_n}',\n      '',\n      'Самые активные пользователи:',\n      top_active_users,\n      .sep = '\\n'\n    )\n    \n    bot$sendPhoto(\n      update$from_chat_id(),\n      photo      = 'top5.png',\n      caption    = tg_msg,\n      parse_mode = 'Markdown'\n    )\n    \n    Sys.sleep(1)\n    \n  }\n  \n}\n# функция для перевода data.frame в telegram таблицу \nto_tg_table <- function( table, align = NULL, indents = 3, parse_mode = 'Markdown' ) {\n  \n  # если выравнивание не задано то выравниваем по левому краю\n  if ( is.null(align) ) {\n    \n    col_num <- length(table)\n    align   <- str_c( rep('l', col_num), collapse = '' )\n    \n  }\n  \n  # проверяем правильно ли заданно выравнивание\n  if ( length(table) != nchar(align) ) {\n    \n    align <- NULL\n    \n  }\n  \n  # новое выравнивание столбцов \n  side <- sapply(1:nchar(align), \n                 function(x) { \n                   letter <- substr(align, x, x)\n                   switch (letter,\n                           'l' = 'right',\n                           'r' = 'left',\n                           'c' = 'both',\n                           'left'\n                   )\n                 })\n  \n  # сохраняем имена\n  t_names      <- names(table)\n  \n  # вычисляем ширину столбцов\n  names_length <- sapply(t_names, nchar) \n  value_length <- sapply(table, function(x) max(nchar(as.character(x))))\n  max_length   <- ifelse(value_length > names_length, value_length, names_length)\n  \n  # подгоняем размер имён столбцов под их ширину + указанное в indents к-во пробелов \n  t_names <- mapply(str_pad, \n                    string = t_names, \n                    width  = max_length + indents, \n                    side   = side)\n  \n  # объединяем названия столбцов\n  str_names <- str_c(t_names, collapse = '')\n  \n  # аргументы для фукнции str_pad\n  rules <- list(string = table, width = max_length + indents, side = side)\n  \n  # поочереди переводим каждый столбец к нужному виду\n  t_str <-   pmap_df( rules, str_pad )%>%\n    unite(\"data\", everything(), remove = TRUE, sep = '') %>%\n    unlist(data) %>%\n    str_c(collapse = '\\n') \n  \n  # если таблица занимает более 4096 символов обрезаем её\n  if ( nchar(t_str) >= 4021 ) {\n    \n    warning('Таблица составляет более 4096 символов!')\n    t_str <- substr(t_str, 1, 4021)\n    \n  }\n  \n  # символы выделения блока кода согласно выбранной разметке\n  code_block <- switch(parse_mode, \n                       'Markdown' = c('```', '```'),\n                       'HTML' = c('<code>', '<\/code>'))\n  \n  # переводим в code\n  res <- str_c(code_block[1], str_names, t_str, code_block[2], sep = '\\n')\n  \n  return(res)\n}"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"код-бота-сбора-статистики","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.9.4 Код бота сбора статистики","text":"С методами бота мы разобрались, ниже привожу пример кода самого бота. Не забудьте подставить имя своего бота в функцию bot_token(), или замените её на токен вашего бота.Далее добавляете созданного вами бота в ваши чаты, даёте ему права администратора, и он в фоновом режиме собирает статистику в свою внутреннюю базу. При необходимости можно использовать вместо SQLite какую то клиент серверную или облачную базу, в таком случае на основе собранной статистику без проблем вы сможете строить дашборды в различных BI системах.Боты могут не только собирать статистику по активности в чатах, но так же модерировать их, считать карму её участников, отвечать на какие либо вопросы участников чата.","code":"\nSys.setlocale(locale = 'russian')\n\nlibrary(telegram.bot)\nlibrary(RSQLite)\nlibrary(purrr)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(here)\nlibrary(tidyr)\nlibrary(timeperiodsR)\nlibrary(ggplot2)\n\n# Переменные\ndb_name        <- 'chatstat.db'\nmsg_tbl        <- 'message'\nnew_user_tbl   <- 'new_users'\nbot_start_time <- Sys.time()\n\n# Чтение методов бота из каталога R\nfuncs <- dir(here('R'))\nwalk(here(\"R\", funcs), source)\n\n# Инициализация бота\nupdater <- Updater(bot_token(\"Chat stat bot\"))\nupdater$bot$clean_updates()\n\n# фильтры\n# фильтр для обработки сообщений msg\nMessageFilters$save_msg <- BaseFilter(function(message) {\n  \n  if ( !is.null(message$text) ) {\n    TRUE\n  } else {\n    FALSE\n  }\n}\n\n)\n\n# фильтр для обработки добавленных в чат участников\nMessageFilters$new_users <- BaseFilter(function(message) {\n  \n  if ( !is.null(message$new_chat_member) ) {\n    TRUE\n  } else {\n    FALSE\n  }\n}\n\n)\n\n# обработчики\nh_save_msg <- MessageHandler(get_message, MessageFilters$save_msg & ! MessageFilters$command)\nh_new_user <- MessageHandler(get_new_user, MessageFilters$new_users & ! MessageFilters$command)\nh_stat     <- CommandHandler('chat_stat', chat_stat, pass_args = T)\n\n# диспетчер\nupdater <-\n  updater +\n  h_save_msg +\n  h_new_user +\n  h_stat\n\n# запуск  бота\nupdater$start_polling()"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"как-добавить-описание-команд-в-интерфейс-бота","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.10 Как добавить описание команд в интерфейс бота","text":"Теперь вы умеете создавать полноценных ботов, которых помимо вас могут использовать другие пользователи. Но, для того, что бы облегчить поиск нужных команд вы можете добавить их в интефейс бота.Делается это через BotFather -> @bot_username -> Edit Bot -> Edit Commands. Далее просто передаёте название команды и через тире их описание:","code":"command1 - Description\ncommand2 - Another description"},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"заключение-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.11 Заключение","text":"Отличная работа! Вы освоили настройку команд и фильтров для вашего бота. Это основа для создания более сложных взаимодействий и функций. В следующей главе мы будем работать с клавиатурами — как reply, так и inline, чтобы улучшить пользовательский интерфейс и взаимодействие с вашим ботом. Будьте готовы к тому, чтобы сделать ваш бот более интерактивным и удобным для пользователей.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"тесты-и-задания-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.12 Тесты и задания","text":"","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"тесты-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.12.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"добавляем-боту-поддержку-команд-и-фильтры-сообщений-класс-updater.html","id":"задания-1","chapter":"Глава 2 Добавляем боту поддержку команд и фильтры сообщений, класс Updater","heading":"2.12.2 Задания","text":"Создайте бота, который будет по команде /sum и переданное в качестве дополнительных параметров произвольное количество перечисленных через пробел чисел, возвращать их сумму.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"как-добавить-боту-поддержку-клавиатуры","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"Глава 3 Как добавить боту поддержку клавиатуры","text":"В этой главе мы познакомимся с важным аспектом разработки Telegram-ботов - добавлением поддержки клавиатуры для более удобного взаимодействия пользователей с ботом.Из этой главы вы узнаете:О двух основных типах клавиатур в Telegram: Reply и InlineКак создавать и настраивать Reply-клавиатуру под панелью ввода текстаКак реализовать Inline-клавиатуру, привязанную к конкретным сообщениям ботаКак обрабатывать нажатия на кнопки клавиатур с помощью пакета telegram.bot для RКак структурировать код бота для работы с клавиатурамиПрактические примеры реализации ботов с клавиатурами для различных задачЯ подробно разберу процесс создания обоих типов клавиатур, приведу примеры кода для реализации нескольких полезных ботов. Вы познакомитесь с ботом для экспресс-тестирования на COVID-19, ботом для получения информации о погоде и ботом для вывода списка свежих статей с Хабра.\nЯ дам детальные объяснения структуры кода, функций для создания кнопок и обработки нажатий, а также рекомендации по построению логики работы бота с клавиатурами.Освоив материал этой главы, вы сможете значительно улучшить удобство использования своих Telegram-ботов, сделав взаимодействие с ними более простым и интуитивно понятным для пользователей.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"видео-урок-по-добавлению-боту-клавиатуры","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.1 Видео урок по добавлению боту клавиатуры","text":"","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"какие-типы-клавиатур-поддерживает-телеграм-бот","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.2 Какие типы клавиатур поддерживает телеграм бот","text":"На момент написания книги telegram.bot позволяет вам создать клавиатуры двух типов:Reply - Основная, обычная клавиатура, которая находится под панелью ввода текста сообщения. Такая клавиатура просто отправляет боту текстовое сообщение, и в качестве текста отправит тот текст, который написан на самой кнопке.Inline - Клавиатура привязанная к конкретному сообщению бота. Данная клавиатура отправляет боту данные, привязанные к нажатой кнопке, эти данные могут отличаться от текста, написанного на самой кнопке. И обрабатываются такие кнопки через CallbackQueryHandler.Для того, что бы бот открыл клавиатуру необходимо при отправке сообщения через метод sendMessage(), передать созданную ранее клавиатуру в аргумент reply_markup.Ниже мы разберём несколько примеров.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"reply-клавиатура","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.3 Reply клавиатура","text":"Как я уже писал выше, это основная клавиатура управления ботом.Выше приведён пример из официальной справки пакета telegram.bot. Для создания клавиатуры используется функция ReplyKeyboardMarkup(), которая в свою очередь принимает список списков кнопок, которые создаются функцией KeyboardButton().Почему в ReplyKeyboardMarkup() необходимо передавать не просто список, а список списков? Дело в том, что вы передаёте основной список, и в нём отдельными списками вы задаёте каждый ряд кнопок, т.к. в один ряд можно расположить несколько кнопок.Аргумент resize_keyboard позволяет автоматически подбирать оптимальный размер кнопок клавиатуры, а аргумент one_time_keyboard позволяет скрывать клавиатуру после каждого нажатия на кнопку.Давайте напишем простейшего бота, у которого будет 3 кнопки:\n* Чат ID - Запросить чат ID диалога с ботом\n* Моё имя - Запросить своё имя\n* Мой логин - Запросить своё имя пользователя в телеграмЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.После запуска задайте боту команду /start, т.к. именно её мы определили для запуска клавиатуры.Если на данный момент вам сложно разобрать приведённый пример кода, с созданием методов, фильтров и обработчиков, то следует вернуться к предыдущей главе, в которой я подробно всё это описал.Мы создали 4 метода:start - Запуск клавиатурыchat_id - Запрос идентификатора чатаmy_name - Запрос своего имениmy_username - Запрос своего логинаВ объект MessageFilters добавили 3 фильтра сообщений, по их тексту:chat_id - Сообщения с текстом \"Чат ID\"name - Сообщения с текстом \"Моё имя\"username - Сообщения с текстом \"Мой логин\"И создали 4 обработчика, которые по заданным командам и фильтрам будут выполнять указанные методы.Сама клавиатура создаётся внутри метода start() командой ReplyKeyboardMarkup().В нашем случае все кнопки мы расположили друг под другом, но мы можем расположить их в один ряд, внеся изменения в список списков кнопок. Т.к. один ряд внутри клавиатуры создаётся через вложенный список кнопок, то для того, что бы вывести наши кнопки в один ряд надо переписать часть кода по построению клавиатуры вот так:Отправляется клавиатура в чат методом sendMessage(), в аргументе reply_markup.","code":"\nbot <- Bot(token = \"TOKEN\")\nchat_id <- \"CHAT_ID\"\n\n# Create Custom Keyboard\ntext <- \"Aren't those custom keyboards cool?\"\nRKM <- ReplyKeyboardMarkup(\n  keyboard = list(\n    list(KeyboardButton(\"Yes, they certainly are!\")),\n    list(KeyboardButton(\"I'm not quite sure\")),\n    list(KeyboardButton(\"No...\"))\n  ),\n  resize_keyboard = FALSE,\n  one_time_keyboard = TRUE\n)\n\n# Send Custom Keyboard\nbot$sendMessage(chat_id, text, reply_markup = RKM)library(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# создаём методы\n## метод для запуска клавиатуры\nstart <- function(bot, update) {\n\n  # создаём клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(KeyboardButton(\"Чат ID\")),\n      list(KeyboardButton(\"Моё имя\")),\n      list(KeyboardButton(\"Мой логин\"))\n    ),\n    resize_keyboard = FALSE,\n    one_time_keyboard = TRUE\n  )\n\n  # отправляем клавиатуру\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)\n\n}\n\n## метод возвразающий id чата\nchat_id <- function(bot, update) {\n\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Чат id этого диалога: \", update$from_chat_id()),\n                  parse_mode = \"Markdown\")\n\n}\n\n## метод возвращающий имя\nmy_name <- function(bot, update) {\n\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Вас зовут \", update$effective_user()$first_name),\n                  parse_mode = \"Markdown\")\n\n}\n\n## метод возвращающий логин\nmy_username <- function(bot, update) {\n\n  bot$sendMessage(update$from_chat_id(),\n                  text = paste0(\"Ваш логин \", update$effective_user()$username),\n                  parse_mode = \"Markdown\")\n\n}\n\n# создаём фильтры\n## сообщения с текстом Чат ID\nMessageFilters$chat_id <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Чат ID\"\n\n}\n)\n\n## сообщения с текстом Моё имя\nMessageFilters$name <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Моё имя\"\n\n}\n)\n\n## сообщения с текстом Мой логин\nMessageFilters$username <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Мой логин\"\n)\n\n# создаём обработчики\nh_start    <- CommandHandler('start', start)\nh_chat_id  <- MessageHandler(chat_id, filters = MessageFilters$chat_id)\nh_name     <- MessageHandler(my_name, filters = MessageFilters$name)\nh_username <- MessageHandler(my_username, filters = MessageFilters$username)\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n            h_start +\n            h_chat_id +\n            h_name +\n            h_username\n\n# запускаем бота\nupdater$start_polling()\n# создаём обработчики\nh_start    <- CommandHandler('start', start)\nh_chat_id  <- MessageHandler(chat_id, filters = MessageFilters$chat_id)\nh_name     <- MessageHandler(my_name, filters = MessageFilters$name)\nh_username <- MessageHandler(my_username, filters = MessageFilters$username)\nRKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(KeyboardButton(\"Чат ID\")),\n      list(KeyboardButton(\"Моё имя\")),\n      list(KeyboardButton(\"Мой логин\"))\n    ),\n    resize_keyboard = FALSE,\n    one_time_keyboard = TRUE\n)\nRKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n          KeyboardButton(\"Чат ID\"),\n          KeyboardButton(\"Моё имя\"),\n          KeyboardButton(\"Мой логин\")\n     )\n    ),\n    resize_keyboard = FALSE,\n    one_time_keyboard = TRUE\n)\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"как-запросить-у-пользователя-номер-телефона-и-локацию","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.3.1 Как запросить у пользователя номер телефона и локацию","text":"При создании кнопок Reply клавиатуры мы используем функцию KeyboardButton(), у которой доступны 2 дополнительные аргумента:request_contact - Запросить номер телефона пользователяrequest_location - Запросить локацию пользователяКогда пользователь поделиться с ботом контактами, то в принятом от бота обновлении, в сообщении будет раздел contact со следующими данными:phone_number - номер телефона в международном форматеfirst_name - Имяlast_name - Фамилияuser_id - Внутренний идентификатор пользователя в telegramКогда пользователь делиться местонахождением то в сообщении полученного ответа будет раздел location с информацией о координатах местонахождения пользователя, т.е. широта и долгота.","code":"\nbot <- Bot(token = \"ТОКЕН ВАШЕГО БОТА\")\n\nchat_id <- \"ID ВАШЕГО ЧАТА\"\n\n# Create Custom Keyboard\ntext <- \"Поделитесь своими данными\"\n\nRKM <- ReplyKeyboardMarkup(\n  keyboard = list(\n    list(KeyboardButton(\"Поделиться номером телефона\", request_contact = TRUE)),\n    list(KeyboardButton(\"Поделиться местонахождением\", request_location = TRUE))\n  ),\n  resize_keyboard = FALSE,\n  one_time_keyboard = TRUE\n)\n\n# Send Custom Keyboard\nbot$sendMessage(chat_id, text, reply_markup = RKM)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"inline-клавиатура","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.4 Inline клавиатура","text":"Как я уже писал выше, Inline клавиатура привязана к конкретному сообщению. С ней работать несколько сложнее чем с основной клавиатурой.Изначально вам необходимо добавить боту метод, для вызова Inline клавиатуры.Для ответа на нажатие Inline кнопки также можно использовать метод бота answerCallbackQuery(), который может вывести уведомление в интерфейсе telegram, пользователю нажавшему Inline кнопку.Данные отправленные с Inline кнопки не являются текстом, поэтому для их обработки необходимо создать специальный обработчик с помощью команды CallbackQueryHandler().Код построения Inline клавиатуры который приводится в официальной справке пакета telegram.bot.Строить Inline клавиатуру необходимо с помощью команды InlineKeyboardMarkup(), по такому же принципу, как и Reply клавиатуру. В InlineKeyboardMarkup() необходимо передать список, списков Inline кнопок, каждая отдельная кнопка создаётся функцией InlineKeyboardButton().Inline кнопка может либо передавать боту какие-то данные с помощью аргумента callback_data, либо открывать какую-либо HTML страницу, заданную с помощью аргумента url.В результате будет список, в котором каждый элемент так же является списком Inline кнопок, которые необходимо объединить в один ряд.Далее мы рассмотрим несколько примеров ботов с Inline кнопками.","code":"\n# Initialize bot\nbot <- Bot(token = \"TOKEN\")\nchat_id <- \"CHAT_ID\"\n\n# Create Inline Keyboard\ntext <- \"Could you type their phone number, please?\"\nIKM <- InlineKeyboardMarkup(\n  inline_keyboard = list(\n    list(\n      InlineKeyboardButton(1),\n      InlineKeyboardButton(2),\n      InlineKeyboardButton(3)\n    ),\n    list(\n      InlineKeyboardButton(4),\n      InlineKeyboardButton(5),\n      InlineKeyboardButton(6)\n    ),\n    list(\n      InlineKeyboardButton(7),\n      InlineKeyboardButton(8),\n      InlineKeyboardButton(9)\n    ),\n    list(\n      InlineKeyboardButton(\"*\"),\n      InlineKeyboardButton(0),\n      InlineKeyboardButton(\"#\")\n    )\n  )\n)\n\n# Send Inline Keyboard\nbot$sendMessage(chat_id, text, reply_markup = IKM)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"пример-простейшего-бота-с-поддержкой-inline-кнопок","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.4.1 Пример простейшего бота с поддержкой InLine кнопок","text":"Для начала мы напишем бота для экспресс тестирования на covid-19. По команде /test, он будет отправлять вам клавиатуру с двумя кнопками, в зависимости от нажатой кнопки он будет присылать вам сообщение с результатами вашего тестирования.Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Мы создали два метода:test - Для отправки в чат Inline клавиатурыanswer_cb - Для обработки отправленных с клавиатуры данных.Данные, которые будут отправлены с каждой кнопки задаются в аргументе callback_data, при создании кнопки. Получить отправленные с кнопки данные можно с помощью конструкции update$callback_query$data, внутри метода answer_cb.Что бы бот реагировал на Inline клавиатуру, метод answer_cb обрабатывается специальным обработчиком: CallbackQueryHandler(answer_cb). Который запускает указанный метод по нажатию Inline кнопки. Обработчик CallbackQueryHandler принимает два аргумента:callback - Метод который необходимо запуститьpattern - Фильтр по данным, которые привязаны к кнопке с помощью аргумента callback_data.Соответвенно с помощью аргумента pattern мы можем под нажатие каждой кнопки написать отдельный метод:Запустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Теперь мы написали 2 отдельных метода, т.е. по одному методу, под нажатие каждой кнопки, и использовали аргумент pattern, при создании их обработчиков:Заканчивается код метода answer_cb командой bot$answerCallbackQuery(callback_query_id = update$callback_query$id), которая сообщает боту, что данные с inline клавиатуры получены.","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# метод для отправки InLine клавиатуры\ntest <- function(bot, update) {\n\n\n  # создаём InLine клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(\"Да\", callback_data = 'yes'),\n        InlineKeyboardButton(\"Нет\", callback_data = 'no')\n      )\n    )\n  )\n\n  # Отправляем клавиатуру в чат\n  bot$sendMessage(update$from_chat_id(),\n                  text = \"Вы болете коронавирусом?\",\n                  reply_markup = IKM)\n}\n\n# метод для обработки нажатия кнопки\nanswer_cb <- function(bot, update) {\n\n  # полученные данные с кнопки\n  data <- update$callback_query$data\n\n  # получаем имя пользователя, нажавшего кнопку\n  uname <- update$effective_user()$first_name\n\n  # обработка результата\n  if ( data == 'no' ) {\n\n    msg <- paste0(uname, \", поздравляю, ваш тест на covid-19 отрицательный.\")\n\n  } else {\n\n    msg <- paste0(uname, \", к сожалени ваш тест на covid-19 положительный.\")\n\n  }\n\n\n  # Отправка сообщения\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = msg)\n\n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# создаём обработчики\ninline_h      <- CommandHandler('test', test)\nquery_handler <- CallbackQueryHandler(answer_cb)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + inline_h + query_handler\n\n# запускаем бота\nupdater$start_polling()\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# метод для отправки InLine клавиатуры\ntest <- function(bot, update) {\n\n  # создаём InLine клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(\"Да\", callback_data = 'yes'),\n        InlineKeyboardButton(\"Нет\", callback_data = 'no')\n      )\n    )\n  )\n\n  # Отправляем клавиатуру в чат\n  bot$sendMessage(update$from_chat_id(),\n                  text = \"Вы болете коронавирусом?\",\n                  reply_markup = IKM)\n}\n\n# метод для обработки нажатия кнопки Да\nanswer_cb_yes <- function(bot, update) {\n\n  # получаем имя пользователя, нажавшего кнопку\n  uname <- update$effective_user()$first_name\n\n  # обработка результата\n  msg <- paste0(uname, \", к сожалени ваш текст на covid-19 положительный.\")\n\n  # Отправка сообщения\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = msg)\n\n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# метод для обработки нажатия кнопки Нет\nanswer_cb_no <- function(bot, update) {\n\n  # получаем имя пользователя, нажавшего кнопку\n  uname <- update$effective_user()$first_name\n\n  msg <- paste0(uname, \", поздравляю, ваш текст на covid-19 отрицательный.\")\n\n  # Отправка сообщения\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = msg)\n\n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# создаём обработчики\ninline_h          <- CommandHandler('test', test)\nquery_handler_yes <- CallbackQueryHandler(answer_cb_yes, pattern = 'yes')\nquery_handler_no  <- CallbackQueryHandler(answer_cb_no, pattern = 'no')\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n            inline_h +\n            query_handler_yes +\n            query_handler_no\n\n# запускаем бота\nupdater$start_polling()\nquery_handler_yes <- CallbackQueryHandler(answer_cb_yes, pattern = 'yes')\nquery_handler_no  <- CallbackQueryHandler(answer_cb_no, pattern = 'no')"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"пример-бота-который-сообщает-текущую-погоду-по-выбранному-городу","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.4.2 Пример бота, который сообщает текущую погоду по выбранному городу","text":"Давайте попробуем написать бота, который запрашивает данные о погоде.Логика его работы будет следующая. Изначально командой /start вы вызываете основную клавиатуру, в которой присутствует всего одна кнопка “Погода”. Нажав на эту кнопку вы получаете сообщение с Inline клавиатурой, для выбора города, по которому требуется узнать текущую погоду. Выбираете один из городов, и получаете текущую погоду.В этом примере кода мы будем использовать несколько дополнительных пакетов:httr - пакет для работы с HTTP запросами, на основе которых построена работа с любым API. В нашем случае мы будем использовать бесплатный API openweathermap.org.stringr - пакет для работы с текстом, в нашем случае мы будем его использовать для формирования сообщения о погоде в выбранном городе.Код бота, который сообщает текущую погоду по выбранному городуЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Мы создали 3 метода, доступные внутри нашего погодного бота:start - Запуск основной клавиатуры ботаweather - Запуск Inline клавиатуры для выбора городаanswer_cb - Основной метод, который по заданному городу запрашивает в API погоду, и отправляет её в чат.Метод start у нас запускается командой /start, что реализовано обработчиком CommandHandler('start', start).Для запуска метода weather мы создали одноимённый фильтр:И вызываем этот метод следующим обработчиком сообщений: MessageHandler(weather, filters = MessageFilters$weather).И в конце концов, основной наш метод answer_cb реагирует на нажатие Inline кнопок, что реализовано специальным обработчиком: CallbackQueryHandler(answer_cb).Внутри метода answer_cb, мы считываем отправленные с клавиатуры данные и записываем их в переменную city: city <- update$callback_query$data. После чего запрашиваем из API данные о погоде, формируем и отправляем сообщение, и в конце концов используем метод answerCallbackQuery для того, что бы сообщить боту, о том, что мы обработали нажатие Inline кнопки.","code":"\nlibrary(telegram.bot)\nlibrary(httr)\nlibrary(stringr)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# создаём методы\n## метод для запуска основной клавиатуры\nstart <- function(bot, update) {\n\n  # создаём клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n        KeyboardButton(\"Погода\")\n      )\n    ),\n    resize_keyboard = TRUE,\n    one_time_keyboard = TRUE\n  )\n\n  # отправляем клавиатуру\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)\n\n}\n\n## Метод вызова Inine клавиатуры\nweather <- function(bot, update) {\n\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(text = 'Москва', callback_data = 'New York,us'),\n        InlineKeyboardButton(text = 'Санкт-Петербург', callback_data = 'Saint Petersburg'),\n        InlineKeyboardButton(text = 'Нью-Йорк', callback_data = 'New York')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Екатеринбург', callback_data = 'Yekaterinburg,ru'),\n        InlineKeyboardButton(text = 'Берлин', callback_data = 'Berlin,de'),\n        InlineKeyboardButton(text = 'Париж', callback_data = 'Paris,fr')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Рим', callback_data = 'Rome,it'),\n        InlineKeyboardButton(text = 'Одесса', callback_data = 'Odessa,ua'),\n        InlineKeyboardButton(text = 'Киев', callback_data = 'Kyiv,ua')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Токио', callback_data = 'Tokyo'),\n        InlineKeyboardButton(text = 'Амстердам', callback_data = 'Amsterdam,nl'),\n        InlineKeyboardButton(text = 'Вашингтон', callback_data = 'Washington,us')\n      )\n    )\n  )\n\n  # Send Inline Keyboard\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = \"Выберите город\",\n                  reply_markup = IKM)\n}\n\n# метод для сообщения погоды\nanswer_cb <- function(bot, update) {\n\n  # получаем из сообщения город\n  city <- update$callback_query$data\n\n  # отправляем запрос\n  ans <- GET('https://api.openweathermap.org/data/2.5/weather',\n             query = list(q     = city,\n                          lang  = 'ru',\n                          units = 'metric',\n                          appid = '4776568ccea136ffe4cda9f1969af340'))\n\n  # парсим ответ\n  result <- content(ans)\n\n  # формируем сообщение\n  msg <- str_glue(\"{result$name} погода:\\n\",\n                  \"Текущая температура: {result$main$temp}\\n\",\n                  \"Скорость ветра: {result$wind$speed}\\n\",\n                  \"Описание: {result$weather[[1]]$description}\")\n\n  # отправляем информацию о погоде\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text    = msg)\n\n\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id)\n}\n\n# создаём фильтры\n## сообщения с текстом Погода\nMessageFilters$weather <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Погода\"\n\n}\n)\n\n# создаём обработчики\nh_start         <- CommandHandler('start', start)\nh_weather       <- MessageHandler(weather, filters = MessageFilters$weather)\nh_query_handler <- CallbackQueryHandler(answer_cb)\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n              h_start +\n              h_weather +\n              h_query_handler\n\n# запускаем бота\nupdater$start_polling()\n# создаём фильтры\n## сообщения с текстом Погода\nMessageFilters$weather <- BaseFilter(function(message) {\n\n  # проверяем текст сообщения\n  message$text == \"Погода\"\n\n}\n)"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"пример-бота-который-выводит-список-самых-свежих-статей-со-ссылками-по-указанному-хабу-из-habr.com","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.4.3 Пример бота, который выводит список самых свежих статей со ссылками по-указанному Хабу из habr.com","text":"Данного бота я привожу для того, что бы показать вам, как вывести Inline кнопки которые ведут на веб страницы.Логика данного бота схожа с предыдущим, изначально мы запускаем основную клавиатуру командой /start. Далее бот даёт нам на выбор список из 6 хабов, мы выбираем интересующий нас хаб, и получаем 5 самых свежих публикаций из выбранного Хаба.Как вы понимаете, в данном случае нам необходимо получить список статей, и для этого мы будем использовать пакет tidyRSS, который позволяет вам получать RSS feed (ленту) сайта в виде обычного дата фрейма в R, к счастью Хабр предоставляет RSS фид под каждый отдельный хаб.RSS — это файл в формате .XML или .RSS, который используют сайты, чтобы передавать пользователю информацию об обновлениях.Для начала установим пакет tidyRSS.Получить RRS Feed по какому то хабу можно примерно так:Теперь рассмотрим код построения описанного выше бота:Код бот который выводит список наиболее свежих статей по выбранному ХабуЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather.Список доступных для выбора Хабов мы вбили хардкодом, в методе habs:Список статей из указанного Хаба мы получаем командой tidyfeed(), из пакета tidyRSS. Из полученной таблицы с помощью команды head() оставляем только 5 самых верхних, которые и являются самыми свежими статьями.Логика очень схожа с предыдущим ботом, но в данном случае Inline клавиатуру со списком статей мы генерируем динамически с помощью функции lapply().В текст кнопки мы подставляем название статьи posts$item_title[x], а в аргумент url ссылку на статью: url = posts$item_link[x].Далее, создаём фильтр, обработчики и запускаем нашего бота.","code":"\ninstall.packages('`tidyRSS`')\nlibrary(tidyRSS)\nurl <- 'https://habr.com/ru/rss/hub/r/'\nrss_fead <- tidyfeed(url)\nlibrary(telegram.bot)\nlibrary(tidyRSS)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# создаём методы\n## метод для запуска основной клавиатуры\nstart <- function(bot, update) {\n  \n  # создаём клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n        KeyboardButton(\"Список статей\")\n      )\n    ),\n    resize_keyboard = TRUE,\n    one_time_keyboard = TRUE\n  )\n  \n  # отправляем клавиатуру\n  bot$sendMessage(update$from_chat_id(),\n                  text = 'Выберите команду',\n                  reply_markup = RKM)\n  \n}\n\n## Метод вызова Inine клавиатуры\nhabs <- function(bot, update) {\n  \n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(text = 'R', callback_data = 'r'),\n        InlineKeyboardButton(text = 'Data Mining', callback_data = 'data_mining'),\n        InlineKeyboardButton(text = 'Data Engineering', callback_data = 'data_engineering')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Big Data', callback_data = 'bigdata'),\n        InlineKeyboardButton(text = 'Python', callback_data = 'python'),\n        InlineKeyboardButton(text = 'Визуализация данных', callback_data = 'data_visualization')\n      )\n    )\n  )\n  \n  # Send Inline Keyboard\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text = \"Выберите Хаб\",\n                  reply_markup = IKM)\n}\n\n# метод для сообщения погоды\nanswer_cb <- function(bot, update) {\n  \n  # получаем из сообщения название хаба\n  hub <- update$callback_query$data\n  \n  # сообщение о том, что данные по кнопке получены\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id,\n                          text = 'Подождите несколько минут, запрос обрабатывается')\n  \n  # сообщение о том, что надо подождать пока бот получит данные\n  mid <- bot$sendMessage(chat_id = update$from_chat_id(),\n                         text    = \"Подождите несколько минут пока, я соберу данные по выбранному Хабу\")\n  \n  # запрашиваем RSS Feed по Хабу\n  url   <- paste0('https://habr.com/ru/rss/hub/', hub, '/')\n  posts <- head(tidyfeed(url), 5)\n  \n  # удаляем сообщение о том, что надо подождать\n  bot$deleteMessage(update$from_chat_id(), mid$message_id)\n  \n  # формируем список кнопок\n  keys <- lapply(1:5, function(x) list(InlineKeyboardButton(posts$item_title[x], url = posts$item_link[x])))\n  \n  # формируем клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard =  keys\n  )\n  \n  # отправляем информацию о погоде\n  bot$sendMessage(chat_id = update$from_chat_id(),\n                  text    = paste0(\"5 наиболее свежих статей из Хаба \", hub),\n                  reply_markup = IKM)\n  \n}\n\n# создаём фильтры\n## сообщения с текстом Погода\nMessageFilters$hubs <- BaseFilter(function(message) {\n  \n  # проверяем текст сообщения\n  message$text == \"Список статей\"\n  \n}\n)\n\n# создаём обработчики\nh_start         <- CommandHandler('start', start)\nh_hubs          <- MessageHandler(habs, filters = MessageFilters$hubs)\nh_query_handler <- CallbackQueryHandler(answer_cb)\n\n# добавляем обработчики в диспетчер\nupdater <- updater +\n  h_start +\n  h_hubs  +\n  h_query_handler\n\n# запускаем бота\nupdater$start_polling()\n## Метод вызова Inine клавиатуры\nhabs <- function(bot, update) {\n\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard = list(\n      list(\n        InlineKeyboardButton(text = 'R', callback_data = 'r'),\n        InlineKeyboardButton(text = 'Data Mining', callback_data = 'data_mining'),\n        InlineKeyboardButton(text = 'Data Engineering', callback_data = 'data_engineering')\n      ),\n      list(\n        InlineKeyboardButton(text = 'Big Data', callback_data = 'bigdata'),\n        InlineKeyboardButton(text = 'Python', callback_data = 'python'),\n        InlineKeyboardButton(text = 'Визуализация данных', callback_data = 'data_visualization')\n      )\n    )\n  )\n\n  # Send Inline Keyboard\n  bot$sendMessage(chat_id = update$message$chat_id,\n                  text = \"Выберите Хаб\",\n                  reply_markup = IKM)\n}\n  # получаем из сообщения название хаба\n  hub <- update$callback_query$data\n  \n  # запрашиваем RSS Feed по Хабу\n  url   <- paste0('https://habr.com/ru/rss/hub/', hub, '/')\n  posts <- head(tidyfeed(url), 5)\n  # формируем список кнопок\n  keys <- lapply(1:5, function(x) list(InlineKeyboardButton(posts$item_title[x], url = posts$item_link[x])))\n\n  # формируем клавиатуру\n  IKM <- InlineKeyboardMarkup(\n    inline_keyboard =  keys\n    )"},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"заключение-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.5 Заключение","text":"Вы сделали отличную работу, научившись настраивать клавиатуры для вашего бота. Теперь ваш бот может предлагать пользователям удобные варианты для взаимодействия. В следующей главе мы перейдем к построению диалогов, чтобы создать более сложные и естественные взаимодействия между пользователями и вашим ботом. Приготовьтесь углубиться в детали создания диалоговых последовательностей!","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"тесты-и-задания-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.6 Тесты и задания","text":"","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"тесты-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.6.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"как-добавить-боту-поддержку-клавиатуры.html","id":"задания-2","chapter":"Глава 3 Как добавить боту поддержку клавиатуры","heading":"3.6.2 Задания","text":"Создайте бота, который будет поддерживать Reply клавиатуру. На Reply клавиатуре будет всего одна кнопка “Время”. По нажатию на неё будет появляться Inline клавиатура с выбором из 6 часовых поясов.Africa/CairoAmerica/ChicagoEurope/MoscowAsia/BangkokEurope/KievAustralia/SydneyКнопки Inline клавиатуры необходимо расположить по 2 в ряд, соответвенно в три ряда.По нажатию на одну из кнопки Inline клавиатуры бот будет запрашивать информацию по текущему времени из API worldtimeapi.org.Формат запроса к API: http://worldtimeapi.org/api/timezone/{area}/:{location}.Где area это континент, например Europe, а {location} это город, например Kiev. Дату и время надо брать в ответе из компонента datetime.Если вы всё сделали правильно результат будет такой:","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"построение-последовательного-логического-диалога-с-ботом","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"Глава 4 Построение последовательного, логического диалога с ботом","text":"В четвертой главе нашего руководства мы сосредоточимся на создании сложных и последовательных диалогов с вашим Telegram-ботом. Вы узнаете, как строить логические диалоги, которые позволят вашему боту взаимодействовать с пользователями более эффективно и естественно.Мы рассмотрим, как организовать диалоговую логику, чтобы бот мог поддерживать связные и осмысленные беседы. Вы изучите методы управления состоянием диалога и обработки различных этапов общения, что сделает взаимодействие более плавным и интуитивно понятным.Эта глава предоставит вам необходимые инструменты для создания интеллектуальных диалогов, улучшая опыт общения с вашим ботом. Надеюсь, что полученные знания помогут вам реализовать свои идеи и сделать ваш проект более успешным.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"видео-урок-по-разработке-последовательного-диалога-с-ботом","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.1 Видео урок по разработке последовательного диалога с ботом","text":"","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"конспект-по-разработке-логического-диалога-с-ботом","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2 Конспект по разработке логического диалога с ботом","text":"","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"введение-1","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.1 Введение","text":"Для того, что бы бот мог запрашивать от вас данные, и ждать ввод какой-либо информации вам потребуется фиксировать текущее состояние диалога. Лучший способ это делать, использовать какую нибудь встраиваемую базу данных, например SQLite.Т.е. логика будет следующей. Мы вызываем метод бота, и бот последовательно запрашивает у нас какую-то информацию, при этом на каждом шаге он ждёт ввод этой информации, и может осуществлять её проверку.Мы напишем максимально простого бота, сначала он будет спрашивать ваше имя, потом возраст, полученные данные будет сохранять в базу данных. При запросе возраста будет проверять, что бы введённые данные были числом, а не текстом.Такой простой диалог будет иметь всего три состояния:\n1. start - обычное состояние бота, в котором он не ждёт от вас никакой информации\n2. wait_name - состояние, при котором бот ожидает ввод имени\n3. wait_age - состояние, при котором бот ожидает ввод вашего возраста, количество полных лет.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"процесс-построения-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.2 Процесс построения бота","text":"Создаём конфиг бота, в котором будем хранить некоторые настройки. В нашем случае токен бота, и путь к файлу базы данных.Создаём переменную среды, в которой будет хранится путь к проекту с ботом.Создаём саму базу данных, и ряд функций для того, что бы бот мог взаимодействовать с ней.Пишем методы бота, т.е. функции которые он будет выполнять.Добавляем фильтры сообщений. С помощью которых бот будет обращаться к нужным методам, в зависимости от текущего состояния чата.Добавляем обработчики, которые свяжут команды и сообщения с нужными методами бота.Запускаем бота.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"структура-проекта-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.3 Структура проекта бота","text":"Для удобства мы разобъём код нашего бота, и прочие связанные с ним файлы на следующую структуру.bot.R - основной код нашего ботаdb_bot_function.R - блок кода с функциями для работы с базой данныхbot_methods.R - код методов ботаmessage_filters.R - фильтры сообщенийhandlers.R - обработчикиconfig.cfg - конфиг ботаcreate_db_data.sql - SQL скрипт создания таблицы с данными чата в базе данныхcreate_db_state.sql - SQL скрипт создания таблицы текущего состояния чата в базе данныхbot.db - база данных ботаВесь проект бота можно посмотреть, или скачать из моего репозитория на GitHub.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"конфиг-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.4 Конфиг бота","text":"В качестве конфига мы будем использовать обычный ini файл, следующего вида:В конфиг мы записываем токен бота, и путь к базе данных, т.е. к файлу bot.db, сам файл мы будем создавать на следующем шаге.Для более сложных ботов можно создавать и более сложные конфиги, к тому же необязательно писать именно ini конфиг, можете использовать любой другой формат включая JSON.","code":"[bot_settings]\nbot_token=ТОКЕН_ВАШЕГО_БОТА\n\n[db_settings]\ndb_path=C:/ПУТЬ/К/ПАПКЕ/ПРОЕКТА/bot.db"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"создаём-переменную-среды","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.5 Создаём переменную среды","text":"На каждом ПК папка с проектом бота может располагаться в разных директориях, и на разных дисках, поэтому в коде путь к папке проекта будет задан через переменную среды TG_BOT_PATH.Создать переменную среды можно несколькими способами, наиболее простой - прописать её в файле .Renviron.Создать, или редактировать данный файл можно с помощью команды file.edit(path.expand(file.path(\"~\", \".Renviron\"))). Выполните её и добавьте в файл одну строку:Далее сохраните файл .Renviron и перезапустите RStudio.","code":"TG_BOT_PATH=C:/ПУТЬ/К/ВАШЕМУ/ПРОЕКТУ"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"создаём-базу-данных","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.6 Создаём базу данных","text":"Следующий шаг - создание базы данных. Нам понадобится 2 таблицы:chat_data - данные которые бот запросил у пользователяchat_state - текущее состояние всех чатовСоздать эти таблицы можно с помощью следующего SQL запроса:Если вы скачали проект бота с GitHub, то для создания базы можете воспользоваться следующим кодом на языке R.","code":"CREATE TABLE chat_data (\n    chat_id BIGINT  PRIMARY KEY\n                    UNIQUE,\n    name    TEXT,\n    age     INTEGER\n);\n\nCREATE TABLE chat_state (\n    chat_id BIGINT PRIMARY KEY\n                   UNIQUE,\n    state   TEXT\n);\n# Скрипт создания базы данных\nlibrary(DBI)     # интерфейс для работы с СУБД\nlibrary(configr) # чтение конфига\nlibrary(readr)   # чтение текстовых SQL файлов\nlibrary(RSQLite) # драйвер для подключения к SQLite\n\n# директория проекта\nsetwd(Sys.getenv('TG_BOT_PATH'))\n\n# чтение конфига\ncfg <- read.config('config.cfg')\n\n# подключение к SQLite\ncon <- dbConnect(SQLite(), cfg$db_settings$db_path)\n\n# Создание таблиц в базе\ndbExecute(con, statement = read_file('create_db_data.sql'))\ndbExecute(con, statement = read_file('create_db_state.sql'))"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"пишем-функции-для-работы-с-базой-данных","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.7 Пишем функции для работы с базой данных","text":"У нас уже готов файл конфигурации и создана база данных. Теперь необходимо написать функции для чтения и записи данных в эту базу.Если вы скачали проект из GitHub, то функции вы можете найти в файле db_bot_function.R.Мы создали 4 простые функции:\n* get_state() - получить текущее состояние чата из БД\n* set_state() - записать текущее состояние чата в БД\n* get_chat_data() - получить данные отправленные пользователем\n* set_chat_data() - записать данные полученные от пользователяВсе функции достаточно простые, они либо читают данные из базы с помощью команды dbGetQuery(), либо совершают UPSERT операцию (изменение существующих данных или запись новых данных в БД), с помощью функции dbExecute().Синтаксис UPSERT операции выглядит следующим образом:Т.е. в наших таблицах поле chat_id имеет ограничение по уникальности и является первичным ключом таблиц. Изначально мы пробуем добавить информацию в таблицу, и получаем ошибку если данные по текущему чату уже присутствуют, в таком случае мы просто обновляем информацию по данному чату.Далее эти функции мы будем использовать в методах и фильтрах бота.","code":"\n# ###########################################################\n# Function for work bot with database\n\n# получить текущее состояние чата\nget_state <- function(chat_id) {\n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  chat_state <- dbGetQuery(con, str_interp(\"SELECT state FROM chat_state WHERE chat_id == ${chat_id}\"))$state\n  \n  return(unlist(chat_state))\n  \n  dbDisconnect(con)\n}\n\n# установить текущее состояние чата\nset_state <- function(chat_id, state) {\n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  # upsert состояние чата\n  dbExecute(con, \n            str_interp(\"\n            INSERT INTO chat_state (chat_id, state)\n                VALUES(${chat_id}, '${state}') \n                ON CONFLICT(chat_id) \n                DO UPDATE SET state='${state}';\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n}\n\n# запись полученных данных в базу\nset_chat_data <- function(chat_id, field, value) {\n  \n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  # upsert состояние чата\n  dbExecute(con, \n            str_interp(\"\n            INSERT INTO chat_data (chat_id, ${field})\n                VALUES(${chat_id}, '${value}') \n                ON CONFLICT(chat_id) \n                DO UPDATE SET ${field}='${value}';\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n}\n\n# read chat data\nget_chat_data <- function(chat_id, field) {\n  \n  \n  con <- dbConnect(SQLite(), cfg$db_settings$db_path)\n  \n  # upsert состояние чата\n  data <- dbGetQuery(con, \n                     str_interp(\"\n            SELECT ${field}\n            FROM chat_data\n            WHERE chat_id = ${chat_id};\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n  return(data[[field]])\n  \n}INSERT INTO chat_data (chat_id, ${field})\nVALUES(${chat_id}, '${value}') \nON CONFLICT(chat_id) \nDO UPDATE SET ${field}='${value}';"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"методы-бота-1","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.8 Методы бота","text":"Следующим шагом в построении нашего бота будет создание методов. Если вы скачали проект с GitHub, то все методы находятся в файле bot_methods.R.Мы создали 5 методов:start - Запуск диалогаstate - Получить текущее состояние чатаreset - Сбросить текущее состояние чатаenter_name - Бот запрашивает ваше имяenter_age - Бот запрашивает ваш возрастМетод start запрашивает ваше имя, и переводит состояние чата в wait_name, т.е. в режим ожидания ввода вашего имени.Далее, вы отправляете имя и оно обрабатывается методом enter_name, бот с вами здоровается, записывает полученное имя в базу, и переводит чат в состояние wait_age.На этом этапе бот ждёт от вас ввода вашего возраста. Вы отправляете ваш возраст, бот проверяет сообщение, если вы вместо числа отправили какой-то текст он скажет: Ты ввёл некорректные данные, введи число, и будет ждать от вас повторного ввода данных. В случае если вы отправили число, бот сообщит о том, что он принял ваш возраст, запишет полученные данные в базу, сообщит все полученные от вас данные и переведёт состояние чата в исходное положение, т.е. в start.Вызвав метод state вы в любой момент можете запросить текущее состояние чата, а методом reset перевести чат в исходное состояние.","code":"\n# ###########################################################\n# bot methods\n\n# start dialog\nstart <- function(bot, update) {\n  \n  # \n  \n  # Send query\n  bot$sendMessage(update$from_chat_id(), \n                  text = \"Введи своё имя\")\n  \n  # переключаем состояние диалога в режим ожидания ввода имени\n  set_state(chat_id = update$from_chat_id(), state = 'wait_name')\n  \n}\n\n# get current chat state\nstate <- function(bot, update) {\n  \n  chat_state <- get_state(update$from_chat_id())\n  \n  # Send state\n  bot$sendMessage(update$from_chat_id(), \n                  text = unlist(chat_state))\n  \n}\n\n# reset dialog state\nreset <- function(bot, update) {\n  \n  set_state(chat_id = update$from_chat_id(), state = 'start')\n  \n}\n\n# enter username\nenter_name <- function(bot, update) {\n  \n  uname <- update$message$text\n  \n  # Send message with name\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(uname, \", приятно познакомится, я бот!\"))\n  \n  # Записываем имя в глобальную переменную\n  #username <<- uname\n  set_chat_data(update$from_chat_id(), 'name', uname) \n  \n  # Справшиваем возраст\n  bot$sendMessage(update$from_chat_id(), \n                  text = \"Сколько тебе лет?\")\n  \n  # Меняем состояние на ожидание ввода имени\n  set_state(chat_id = update$from_chat_id(), state = 'wait_age')\n  \n}\n\n# enter user age\nenter_age <- function(bot, update) {\n  \n  uage <- as.numeric(update$effective_message()$text)\n  \n  # проверяем было введено число или нет\n  if ( is.na(uage) ) {\n    \n    # если введено не число то переспрашиваем возраст\n    bot$sendMessage(update$from_chat_id(), \n                    text = \"Ты ввёл некорректные данные, введи число\")\n    \n  } else {\n    \n    # если введено число сообщаем что возраст принят\n    bot$sendMessage(update$from_chat_id(), \n                    text = \"ОК, возраст принят\")\n    \n    # записываем глобальную переменную с возрастом\n    #userage <<- uage\n    set_chat_data(update$from_chat_id(), 'age', uage) \n    \n    # сообщаем какие данные были собраны\n    username <- get_chat_data(update$from_chat_id(), 'name')\n    userage  <- get_chat_data(update$from_chat_id(), 'age')\n    \n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Тебя зовут \", username, \" и тебе \", userage, \" лет. Будем знакомы\"))\n    \n    # возвращаем диалог в исходное состояние\n    set_state(chat_id = update$from_chat_id(), state = 'start')\n  }\n  \n}"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"фильтры-сообщений","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.9 Фильтры сообщений","text":"В нашем случае это одна из наиболее важных частей в построении бота. Именно с помощью фильтров сообщений бот будет понимать какую информацию он от вас ждёт, и как её надо обрабатывать.В проекте на GitHub фильтры прописаны в файле message_filters.R.Код фильтров сообщений:В фильтрах мы используем написанную ранее функцию get_state(), для того, что бы запрашивать текущее состояние чата. Данна функция требует всего 1 аргумент, id чата.Далее фильтр wait_name обрабатывает сообщения когда чат находится в состоянии wait_name, и соответственно фильтр wait_age обрабатывает сообщения когда чат находится в состоянии wait_age.","code":"\n# ###########################################################\n# message state filters\n\n# фильтр сообщений в состоянии ожидания имени\nMessageFilters$wait_name <- BaseFilter(function(message) {\n  get_state( message$chat_id )  == \"wait_name\"\n}\n)\n\n# фильтр сообщений в состоянии ожидания возраста\nMessageFilters$wait_age <- BaseFilter(function(message) {\n  get_state( message$chat_id )   == \"wait_age\"\n}\n)"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"обработчики","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.10 Обработчики","text":"Файл с обработчиками называется handlers.R, и имеет следующий код:Сначала мы создаём обработчики команд, которые позволят вам запускать методы для начала диалога, его сброса, и запроса текущего состояния.Далее мы создаём 2 обработчика сообщений с использованием созданных на прошлом шаге фильтров, и добавляем к ним фильтр !MessageFilters$command, для того, что бы мы в любом состоянии чата могли использовать команды.","code":"\n# ###########################################################\n# handlers\n\n# command handlers\nstart_h <- CommandHandler('start', start)\nstate_h <- CommandHandler('state', state)\nreset_h <- CommandHandler('reset', reset)\n\n# message handlers\n## !MessageFilters$command - означает что команды данные обработчики не обрабатывают, \n## только текстовые сообщения\nwait_age_h  <- MessageHandler(enter_age,  MessageFilters$wait_age  & !MessageFilters$command)\nwait_name_h <- MessageHandler(enter_name, MessageFilters$wait_name & !MessageFilters$command)"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"код-запуска-бота","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.2.11 Код запуска бота","text":"Теперь у нас всё готово к запуску, основной код запуска бота находится в файле bot.R.В любой момент с помощью команды /state мы можем запрашивать текущее состояние чата, а с помощью команды /reset переводить чат в исходное состояние и начинать диалог заново.","code":"\nlibrary(telegram.bot)\nlibrary(tidyverse)\nlibrary(RSQLite)\nlibrary(DBI)\nlibrary(configr)\n\n# переходим в папку проекта\nsetwd(Sys.getenv('TG_BOT_PATH'))\n\n# читаем конфиг\ncfg <- read.config('config.cfg')\n\n# создаём экземпляр бота\nupdater <- Updater(cfg$bot_settings$bot_token)\n\n# Загрузка компонентов бота\nsource('db_bot_function.R') # функции для работы с БД\nsource('bot_methods.R')     # методы бота\nsource('message_filters.R') # фильтры сообщений\nsource('handlers.R') # обработчики сообщений\n\n# Добавляем обработчики в диспетчер\nupdater <- updater +\n  start_h +\n  wait_age_h +\n  wait_name_h +\n  state_h +\n  reset_h\n\n# Запускаем бота\nupdater$start_polling()"},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"заключение-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.3 Заключение","text":"Поздравляю с завершением работы над логическими диалогами! Ваш бот теперь способен проводить сложные и логически последовательные беседы с пользователями. В следующей главе мы сосредоточимся на управлении правами пользователей, что позволит вам контролировать доступ и функции вашего бота в зависимости от ролей и уровней доступа.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"тесты-и-задания-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.4 Тесты и задания","text":"","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"тесты-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.4.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"построение-последовательного-логического-диалога-с-ботом.html","id":"задания-3","chapter":"Глава 4 Построение последовательного, логического диалога с ботом","heading":"4.4.2 Задания","text":"Постройте бота который будет поддерживать игру угадай число. Т.е. по команде /start бот будет загадывать число от 1 до 50. Далее у вас будет 5 попыток угадать это число.Вы по очереди в каждой из попыток вводите числа, если введённое число меньше чем то, которое загадал бот то бот пишет “моё число больше”, иначе бот пишет “моё число меньше”. Если вы ввели правильное число то бот пишет что вы выйграли, и переводит диалог в исходное состояние.Если вы всё сделали правильно, бот будет выглядеть так:Победа с 5 попытки:Пройгрыш\n","code":""},{"path":"управление-правами-пользователей-бота.html","id":"управление-правами-пользователей-бота","chapter":"Глава 5 Управление правами пользователей бота","heading":"Глава 5 Управление правами пользователей бота","text":"В пятой главе нашего руководства мы сосредоточимся на управлении правами пользователей вашего Telegram-бота. Вы узнаете, как настраивать и контролировать доступ к различным функциям, чтобы сделать ваш бот более гибким и безопасным.Мы изучим, как реализовать систему управления правами, которая позволит вам назначать разные уровни доступа для пользователей. Вы научитесь ограничивать или предоставлять доступ к определенным функциям в зависимости от их ролей, что поможет вам создать более структурированное и безопасное взаимодействие.Эта глава предоставит вам инструменты для тонкой настройки доступа и управления пользователями, что сделает ваш бот более эффективным и удобным. Надеюсь, что эти знания помогут вам реализовать проект на новом уровне, обеспечивая лучшее взаимодействие с вашими пользователями.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"введение-2","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.1 Введение","text":"Ваш бот может выполнять совершенно любые задачи, и автоматизировать как некоторые внутренние процессы, так и наладить коммуникации с клиентами.Т.е. бот может использоваться в многопользовательском режиме. При этом, вам может понадобиться разграничить права на использование бота. Например, некоторые пользователи смогут использовать абсолютно все возможности бота, а некоторым вы предоставите ограниченные права.Ограничить права можно не только на уровне пользователя, но и на уровне отдельных чатов.Мы создадим простейшего бота, у которого в арсенале будет всего 2 метода:say_hello - команда приветствияwhat_time - команда, по которой бот сообщает текущую дату и времяЗапустите приведённый выше пример кода, предварительно заменив ‘ТОКЕН ВАШЕГО БОТА’ на реальный токен, который вы получили при создании бота через BotFather (о создании бота я рассказывал в первой статье).В данной главе мы разберёмся с тем, как разными способами, и на разных уровнях ограничить использование методов этого бота.","code":"\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\",\n                  reply_to_message_id = update$effective_message()$message_id)\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # Запрашиваем текущее время\n  cur_time <- as.character(Sys.time())\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Текущее время, \", cur_time),\n                                parse_mode = \"Markdown\",\n                                reply_to_message_id = update$effective_message()$message_id)\n                  \n  \n}\n\n# обработчики\nh_hello <- CommandHandler('say_hello', say_hello)\nh_time  <- CommandHandler('what_time', what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-пользователя-с-помощью-фильтров-сообщений","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.2 Ограничиваем права пользователя с помощью фильтров сообщений","text":"Из предыдущих публикаций мы уже разобрались с тем, что такое фильтры сообщений. Но ранее мы использовали их в основном для, того, что бы вызывать какие-то методы бота через обычное сообщение, а не команду и для прослушиваний сообщений в определённом состоянии чата.В этот раз мы научимся с помощью фильтров ограничивать возможности по использованию методов бота, на разных уровнях.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-имени-пользователя","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.2.1 Ограничиваем права на уровне имени пользователя","text":"Для создания собственных фильтров вам необходимо с помощью функции BaseFilter() добавить новый элемент в объект MessageFilters. Более подробно об этом я рассказывал во второй статье из данной серии.В анонимную функцию, которую вы прописываете внутри BaseFilter() передаётся всего один аргумент - message. Это сообщение которое вы, или другой пользователей отправляет боту, со всеми его метаданными. Данный объект имеет следующую структуру:Более подробно описание ответа и всех его компонентов можно узнать из официальной документации:User - Этот объект представляет бота или пользователя Telegram.Chat - Этот объект представляет собой чат.Message - Этот объект представляет собой сообщение.Соответственно вы можете разделять права пользователей бота, и его методов используя любую, отправляемую с сообщением информацию, т.е. любые элементы объекта message. Для того, что бы ограничить круг пользователей которые могут использовать методы вашего бота достаточно создать фильтр:Где c('AlexeySeleznev', 'user1', 'user2') - вектор, с именами пользователей, которые могут использовать все функции бота. Далее этот фильтр мы используем при создании обработчиков.Теперь нашего бота могут использовать пользователи с логинами AlexeySeleznev, user1, user2. На сообщения отправленные боту другими пользователями он никак не будет реагировать.Изменённый код нашего бота на данный момент выглядит вот так:","code":"$message_id\n[1] 1174\n\n$from\n$from$id\n[1] 194336771\n\n$from$is_bot\n[1] FALSE\n\n$from$first_name\n[1] \"Alexey\"\n\n$from$last_name\n[1] \"Seleznev\"\n\n$from$username\n[1] \"AlexeySeleznev\"\n\n$from$language_code\n[1] \"ru\"\n\n\n$chat\n$chat$id\n[1] 194336771\n\n$chat$first_name\n[1] \"Alexey\"\n\n$chat$last_name\n[1] \"Seleznev\"\n\n$chat$username\n[1] \"AlexeySeleznev\"\n\n$chat$type\n[1] \"private\"\n\n\n$date\n[1] 1601295189\n\n$text\n[1] \"отправленный пользователем текст\"\n\n$chat_id\n[1] 194336771\n\n$from_user\n[1] 194336771\n## список пользователей, с полными правами\nMessageFilters$admins <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$effective_user()$username %in% c('AlexeySeleznev', 'user1', 'user2')\n    \n }\n)\n## фильтр для вызова команды say_hello\nMessageFilters$say_hello <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/say_hallo'\n    \n  }\n)\n\n## фильтр для вызова команды what_time\nMessageFilters$what_time <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/what_time'\n    \n  }\n)\n\n\n# обработчики\nh_hello <- MessageHandler(say_hello, MessageFilters$admins & MessageFilters$say_hello)\nh_time  <- MessageHandler(what_time, MessageFilters$admins & MessageFilters$what_time)\nlibrary(telegram.bot)\n\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$first_name\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                  parse_mode = \"Markdown\",\n                  reply_to_message_id = update$effective_message()$message_id)\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # Запрашиваем текущее время\n  cur_time <- as.character(Sys.time())\n  \n  # Отправка сообщения\n  bot$sendMessage(update$from_chat_id(), \n                  text = paste0(\"Текущее время, \", cur_time),\n                                parse_mode = \"Markdown\",\n                                reply_to_message_id = update$effective_message()$message_id)\n                  \n  \n}\n\n# фильтры\n## список пользователей, с полными правами\nMessageFilters$admins <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$from$username %in% c('AlexeySeleznev', 'user1', 'user2')\n    \n }\n)\n\n## фильтр для вызова команды say_hello\nMessageFilters$say_hello <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/say_hallo'\n    \n  }\n)\n\n## фильтр для вызова команды what_time\nMessageFilters$what_time <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/what_time'\n    \n  }\n)\n\n\n# обработчики\nh_hello <- MessageHandler(say_hello, MessageFilters$admins & MessageFilters$say_hello)\nh_time  <- MessageHandler(what_time, MessageFilters$admins & MessageFilters$what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-чата","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.2.2 Ограничиваем права на уровне чата","text":"Тем же способом мы можем создать фильтр не только по списку пользователей, но и по конкретному чату. Для этого достаточно создать ещё один фильтр:","code":"\n## список чатов в которых разрешено использовать бота\nMessageFilters$chats <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$chat_id %in% c(194336771, 0, 1)\n    \n  }\n)\n\n\n## фильтр для вызова команды say_hello\nMessageFilters$say_hello <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/say_hallo'\n    \n  }\n)\n\n## фильтр для вызова команды what_time\nMessageFilters$what_time <- BaseFilter(\n  function(message) {\n    \n    # проверяем от кого отправлено сообщение\n    message$text == '/what_time'\n    \n  }\n)\n\n\n# обработчики\nh_hello <- MessageHandler(say_hello, MessageFilters$admins & MessageFilters$chats & MessageFilters$say_hello)\nh_time  <- MessageHandler(what_time, MessageFilters$admins & MessageFilters$chats & MessageFilters$what_time)"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-пользователя-внутри-кода-методов","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.3 Ограничиваем права пользователя внутри кода методов","text":"Так же вы можете ограничить использование методов не прибегая к созданию дополнительных фильтров, а прописав все условия внутри каждого метода.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-имени-пользователя-1","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.3.1 Ограничиваем права на уровне имени пользователя","text":"Давайте создадим функцию, которая будет принимать данные для проверки имени пользователя.В аргумент admins далее нам надо передавать список пользователей, которым разрешено использовать данный метод, а в аргумент username имя пользователя, которого надо проверить в списке.Далее в каждый метод, который мы хотим защитить с помощью конструкции добавляем проверку, разрешено пользователю использовать данный метод или нет. В случае если у пользователя нет таких прав бот будет сообщать об этом в чате.Давайте, для примера, я исключу себя из списка пользователей, которым разрешено использовать метод what_time.Результат будет следующим:Теперь бот не просто игнорирует сообщения от обычных пользователей, а сообщает им, что у них недостаточно прав использовать какой либо метод.","code":"\n# функция для проверки прав пользователя\nbot_check_usernames <- \n  function(admins, username) {\n  \n   username %in% admins \n  \n}\nlibrary(telegram.bot)\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$effective_user()$username\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('AlexeySeleznev', 'user1', 'user2'), user_name) ) {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n      \n  } else {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('user1', 'user2'), update$effective_user()$username) ) {\n      \n    # Запрашиваем текущее время\n    cur_time <- as.character(Sys.time())\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$message$chat_id, \n                    text = paste0(\"Текущее время, \", cur_time),\n                                  parse_mode = \"Markdown\",\n                                  reply_to_message_id = update$effective_message()$message_id)\n  } else {\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$message$chat_id, \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n                  \n  \n}\n\n# обработчики\nh_hello <- CommandHandler('say_hello', say_hello)\nh_time  <- CommandHandler('what_time', what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"ограничиваем-права-на-уровне-чата-1","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.3.2 Ограничиваем права на уровне чата","text":"Думаю у вас уже не возникнет трудностей при доработке ваших методов, таким образом, что бы их можно было использовать только в определённых чатах, тем не менее приведу пример.Напишем функцию, которая будет проверять входит ли текущий чат в список разрешенных.Далее используем эту функции внутри наших методов:","code":"\nbot_check_chat_id <- \n  function(allowed_chats, current_chat) {\n\n     current_chat %in% allowed_chats \n    \n}\nlibrary(telegram.bot)\n\n\n# создаём экземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Пишем метод для приветсвия\n## команда приветствия\nsay_hello <- function(bot, update) {\n  \n  # Имя пользователя с которым надо поздароваться\n  user_name <- update$message$from$username\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('AlexeySeleznev', 'user1', 'user2'), user_name) \n       &\n       bot_check_chat_id(c(194336771, 1, 2), update$from_chat_id())) {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Моё почтение, \", user_name, \"!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n      \n  } else {\n    \n    # Отправка сообщения\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n\n}\n\n## команда по которой бот возвращает системную дату и время\nwhat_time <- function(bot, update) {\n  \n  # проверяем разрешено ли использовать данному пользователю этот метод\n  if ( bot_check_usernames(c('AlexeySeleznev', 'user1', 'user2'), update$message$from$username)\n       &\n       bot_check_chat_id(c(194336771, 1, 2), update$message$chat_id)) {\n      \n    # Запрашиваем текущее время\n    cur_time <- as.character(Sys.time())\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"Текущее время, \", cur_time),\n                                  parse_mode = \"Markdown\",\n                                  reply_to_message_id = update$effective_message()$message_id)\n  } else {\n    \n    # Отправка сообщения о том что у пользователя не достаточно прав\n    bot$sendMessage(update$from_chat_id(), \n                    text = paste0(\"У вас нет прав для использования этого метода!\"),\n                    parse_mode = \"Markdown\",\n                    reply_to_message_id = update$effective_message()$message_id)\n    \n  }\n                  \n  \n}\n\n# обработчики\nh_hello <- CommandHandler('say_hello', say_hello)\nh_time  <- CommandHandler('what_time', what_time)\n\n# добавляем обработчики в диспетчер\nupdater <- updater + h_hello + h_time\n\n# запускаем бота \nupdater$start_polling()"},{"path":"управление-правами-пользователей-бота.html","id":"заключение-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.4 Заключение","text":"Вы успешно освоили управление правами пользователей, что значительно расширяет возможности вашего бота. В следующей главе мы сосредоточимся на повышении стабильности работы бота, что поможет вам обеспечить надежность и эффективность его работы в различных условиях и нагрузках.Успехов вам в ботостроении. В комментариях можете написать примеры ваших ботов, и как вы их на практике используете.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"тесты-и-задания-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.5 Тесты и задания","text":"","code":""},{"path":"управление-правами-пользователей-бота.html","id":"тесты-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.5.1 Тесты","text":"Для закрепления материла рекомендую вам пройти тест доступный по ссылке.","code":""},{"path":"управление-правами-пользователей-бота.html","id":"задания-4","chapter":"Глава 5 Управление правами пользователей бота","heading":"5.5.2 Задания","text":"Возьмите задачу из второй главы, и ограничьте использование единственного метода, доступного в созданном боте, так, что бы он работал только когда его запрашиваете вы.","code":""},{"path":"повышаем-стабильность-работы-бота.html","id":"повышаем-стабильность-работы-бота","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"Глава 6 Повышаем стабильность работы бота","text":"В шестой главе нашего руководства мы сосредоточимся на повышении стабильности работы вашего Telegram-бота. Здесь вы узнаете, как обеспечить надежную и бесперебойную работу бота, предотвращая сбои и улучшая его производительность.Мы рассмотрим стратегии мониторинга и поддержки стабильности, включая методы отладки и устранения ошибок. Вы изучите, как настроить системы для автоматического обнаружения и исправления проблем, что поможет вашему боту функционировать эффективно даже в сложных условиях.Эта глава даст вам ключевые инструменты и техники для поддержания высокого уровня надежности вашего бота. Надеюсь, что эти рекомендации помогут вам создать более устойчивый и высококачественный продукт.","code":""},{"path":"повышаем-стабильность-работы-бота.html","id":"конструкция-trycatch","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.1 Конструкция tryCatch()","text":"Повысить работоспособность вашего бота поможет конструкция tryCatch(). Данная конструкция имеет следующий синтаксис:","code":"tryCatch(expr = {\n  \n    ~ Тут код который будет выполняться ~\n  \n}, \n  error = function(err) {\n    \n    ~ код который будет выполняться в случае возникновения ошибки в блоке expr ~\n    \n  }, \n  finally = {\n    \n    ~ Код который будет выполняться в любом случае, не зависимо от того закончилось выражение expr ошибкой или нет ~\n    \n  })"},{"path":"повышаем-стабильность-работы-бота.html","id":"логика-работы-конструкции-trycatch","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.2 Логика работы конструкции tryCatch()","text":"Из описанного синтаксиса понятно, что вам необходимо завернуть выражение в фигурные скобки в аргументе expr. Это выражение будет выполняться либо до тех пор, пока не встретится ошибка, либо если ошибки нет, оно будет выполнено полностью.Если в выражении переданном в expr встречается ошибка, то конструкция tryCath() запустит анонимную функцию, которую вы передали в блоке error.В любом случае, не зависимо от того, встретилась в выражении expr ошибка или нет, в завершении выполнения будет выполнен код, переданный в аргумент finally.Если вы хотите более подробно узнать про конструкцию tryCatch() посмотрите этот видео урок.","code":""},{"path":"повышаем-стабильность-работы-бота.html","id":"используем-trycatch-внутри-бота","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.3 Используем tryCatch() внутри бота","text":"По большому счёту вы можете использовать tryCatch() внутри каждой функции вашего бота. Но можно убить всех зайцев одним выстрелом.В разработке ботов слабым местом является пуллинг, т.е. метод updater$start_polling(). Пуллинг - это бесконечный цикл, именно он выполняется всё время работы бота, и даёт сбой если пользователь неправильно использовал бота, или API Telegram не отправил вам ответ. Соответственно если завернуть пуллинг в tryCatch(), и перезапускать вашего бота в бота в блоке finally то при любой ошибке он будет самостоятельно перезапускаться.Перед перезапуском бота не забывайте очистить его апдейты, что бы избавиться от ошибки, которая вызвала падение бота.Выглядеть такой пуллинг будет следующим образом:В приведённом выше коде вам необходимо подставить токен созданного вами бота, и указать ID чата, в который бот будет отправлять уведомление о падении пуллинга.В блок expr мы завернули процесс пуллинга, таким образом он постоянно контролируется конструкцией tryCatch.Далее в блок error мы передали безымянную функцию, которая принимает всего один аргумент err, т.е. саму ошибку. Сообщение об ошибке мы получаем через err$message, и отправляем в указанный чат. С помощью updater$bot$clean_updates() мы очищаем очередь апдейтов бота, т.к. последний апдейт вызвал ошибку и падение нашего бота.В блоке finally мы останавливаем пуллинг, и командой source('C:\\\\telegram_bot\\\\my_bot.R') занова запускаем скрипт с ботом.Такая схема позволяет боту очищаться и подниматься при любой ошибке пуллинга.Очищать апдейты бота с помощью комманды updater$bot$clean_updates() можно так же и при запуске бота, указав эту команду сразу, после инициализации объекта бота.","code":"\ntryCatch(\n  \n  # запускаем пуллинг\n  expr = updater$start_polling(), \n  \n  # действия при ошибке пуллинга\n  error = function(err) {\n    \n    # бот для оповещения\n    bot <- Bot(token = bot_token(\"Токен вашего бота\"))\n    \n    # чат для оповещения\n    chat_id <- \"Идентификатор чата в который необходимо отправить сообщение\"\n    \n    # сообщение\n    msg <- str_glue(\"*Бот упал*: Ошибка (_{err$message}_).\")\n    \n    bot$sendMessage(chat_id = chat_id, \n                    text = msg,\n                    parse_mode = 'Markdown')\n    \n    # очищаем полученный апдейт бота, который вызвал ошибку\n    updater$bot$clean_updates()\n    \n    # информация о том, что бот будет перезапущен\n    bot$sendMessage(chat_id = chat_id, \n                    text = str_glue('*Перезапускаю бота* в {Sys.time()}'),\n                    parse_mode = 'Markdown')\n\n    \n  }, \n  # действия которые будут выполненны в любом случае\n  finally = {\n    \n    # останавливаем пулинг\n    updater$stop_polling()\n        \n    # перезапускаем скрипт бота\n    source('C:\\\\telegram_bot\\\\my_bot.R') \n\n  }\n)"},{"path":"повышаем-стабильность-работы-бота.html","id":"заключение-5","chapter":"Глава 6 Повышаем стабильность работы бота","heading":"6.4 Заключение","text":"Отлично! Вы повысили стабильность работы вашего бота и теперь можете уверенно справляться с потенциальными проблемами. В следующей главе мы внедрим асинхронные операции, чтобы улучшить производительность вашего бота и сделать его более масштабируемым. Подготовьтесь к погружению в мир асинхронного программирования!","code":""},{"path":"добавляем-боту-асинхронность.html","id":"добавляем-боту-асинхронность","chapter":"Глава 7 Добавляем боту асинхронность","heading":"Глава 7 Добавляем боту асинхронность","text":"В седьмой главе нашего руководства мы сосредоточимся на внедрении асинхронности в работу вашего Telegram-бота. Вы узнаете, как применять асинхронные методы для улучшения производительности и реактивности бота, чтобы он мог более эффективно справляться с различными задачами.Мы подробно рассмотрим, как интегрировать асинхронные операции для обработки запросов и выполнения фоновых задач, что позволит вашему боту работать быстрее и более плавно. Вы освоите техники асинхронного программирования на языке R, которые помогут вашему боту эффективно управлять несколькими задачами одновременно.Эта глава даст вам ключевые знания и навыки для создания более отзывчивого и высокопроизводительного бота. Надеюсь, что полученные рекомендации помогут вам значительно улучшить функциональность вашего проекта.","code":""},{"path":"добавляем-боту-асинхронность.html","id":"что-такое-асинхронное-программирование","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.1 Что такое асинхронное программирование","text":"По умолчанию созданные вами боты работают в параллельном, однопоточном режиме. Т.е. они выполняют заданные команды последовательно. Это не доставит никаких дополнительных трудностей если:ваш бот выполняет простейшие команды длительность работы которых не превышает 1 секунды;вашего бота использует всего несколько пользователей, и редко используют его одновременно.Асинхронность в программировании — выполнение процесса в неблокирующем режиме системного вызова, что позволяет потоку программы продолжить обработку.– tproger.ru","code":""},{"path":"добавляем-боту-асинхронность.html","id":"пример-последовательного-бота-с-поддержкой-длительных-команд","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.2 Пример последовательного бота с поддержкой длительных команд","text":"В этом разделе мы разберёмся с тем, как сделать нашего бота асинхронным, т.е. способным обрабатывать одновременно несколько команд, таким образом, что бы одна длительная команда, не блокировала работу боту на время её выполнения. Для демонстрации примера мы создадим бота с двумя простейшими командами:fast - быстрая команда, время выполнение которой менее 1 секунды.slow - команда, на выполнение которой боту требуется некоторое время, в нашем случае более 10 секунд.Для создания бота выполните приведённый ниже код:В многофункциональных ботах также можно разделить все команды на быстрые и медленные. Команды, которые бот выполняет мгновенно не требуют асинхронности, а вот команды реализующие длительные, дорогие вычисления, например запросы к API, лучше выполнять в параллельном, фоновом процессе не блокируя на период вычислений работу бота.Для демонстрации проблемы давайте попробуем запустить бота, по приведённому выше примеру кода.Изначально мы запустили медленную команду /slow, и не дожидаясь её выполнения отправили быструю команду /fast. Но, к выполнению команды /fast бот приступил только после того, как выполнил длительную команду /slow. Это видно из диалога, т.к. после того, как боту была отправлена команда /fast, он завершил работу команды /slow, сообщил нам “Медленная функция выполнена! ID процесса: 868”. Только после этого приступил к выполнению быстрой функции, сообщив “Быстрая функция, выполняется последовательный режим!ID процесса: 868”.Представьте ситуацию, если у вас одновременно 5 пользователей отправят вперемешку быстрые и длительные команды. В качестве эксперимента давайте отправим боту очередь команд:/slow/slow/fast/slow/fastВ данном случае не важно, эти команды запустил один пользователь или 5, выполняться они будут последовательно. Несмотря на то, что 5ая команда является быстрой, пользователю, который её отправил придётся ждать выполнения всех 4ёх, предыдущих команд. Если изобразить этот процесс схематически, и допустить, что быстрая команда выполняется за 1 секунду, а медленная за 10, то получится следующее:В последовательном режиме выполнения, несмотря на то, что 5ая по счёту команда требует всего 1 секунду на вычисления, она 31 секунду находится в ожидании, пока будут выполнены 4 предыдущие операции.","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\n\nupdater <- Updater(\"Токен вашего бота\")\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  # Сообщение о том, что начата работа длительного вычисления\n  bot$sendMessage(\n      update$message$chat_id,\n      text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n      parse_mode = \"Markdown\"\n  )\n  \n  # Добавляем паузу, для того, что бы исскусственно сделать функцию длительной\n  Sys.sleep(10)\n  \n  # Сообщаем о том, что все вычисления выполнены\n  bot$sendMessage(update$message$chat_id,\n      text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n      parse_mode = \"Markdown\")\n\n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# создаём обработчики\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + slow_hendler + fast_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-асинхронность.html","id":"многопоточность-в-r","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.3 Многопоточность в R","text":"В языке R есть множество реализаций многопоточности:foreachparallelfutureЭто далеко не полный перечень пакетов, которые позволяют вам производить вычисления в многопоточном режиме используя язык R. Для реализации многопоточности при разработке telegram ботов наиболее удобным является пакет future, о котором я подробно рассказывал в уроке “Пакет future” курса “Циклы и функционалы в языке R”. Крайне рекомендую пройти весь курс “Циклы и функционалы в языке R” для большего погружения в тему многопоточности. Т.к. в данном курсе мы не будет подробно рассматривать параллельное программирование.Пакет future позволяет вам, выполнять вычисления как в последовательном (обычном) режиме, так и в многопоточном. При этом данный пакет поддерживает несколько различных многопоточных режима:Изменять план выполнения вычислений можно с помощью future::plan(). Наиболее простым, и удобным для использования при построении telegram ботов многопоточный план вычислений - multisession. Данный план позволяет запускать на вашем локальном ПК параллельные R сеансы в фоновом режиме, после выполнения вычислений их результат импортируется в основной R сеанс.Далее, после переопределения плана вычислений, запустить вычисление в многопоточном режиме можно с помощью одноимённой функции future().","code":""},{"path":"добавляем-боту-асинхронность.html","id":"используем-future-для-построения-асинхронного-бота","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.4 Используем future для построения асинхронного бота","text":"Хочу обратить ваше внимание, когда мы в начале этого урока запустили бота в последовательном режиме, он с помощью функции Sys.getpid() получал, и выводил в сообщении идентификатор R сеанса, в ходе которого выполнялись все вычисления бота. Во всех представленных выше сообщение идентификатор процесса был одинаковым - 868. Это связано с тем, что все вычисления производились последовательно в рамках одного R сеанса.Ниже я приведу пример, доработанного бота, таким образом, что бы функция /slow запускалась в фоновом, параллельном R сеансе, и не блокировала работу бота. При этом функцию /fast мы оставим без изменений, т.к. она выполняется ботом достаточно быстро, и скорее всего накладные расходы на создание фонового сеанса будут больше, чем вычисление самой функции.Что мы изменили в коде бота:\n1. В начале скрипта, командой future::plan('multisession') мы переопределили план вычислений с последовательного на многопоточный. На самом деле весь код будет выполняться последовательно, кроме кода используемого внутри функции future().\n2. Весь код внутри функции бота slow_fun() мы завернули в future::future(), таким образом, при запуске медленной функции будет запускаться параллельный фоновый R процесс, и все вычисления данной функции будут выполняться там, не блокируя основной сеанс.Теперь давайте попробуем в параллельном режиме запустить такую же очередь команд, как и в предыдущем последовательном примере:Обратите внимание на то, что вычисление всех долгих команд /slow выполняются в разных процессах, бот выводит в каждом сообщение информацию “ID процесса: XX”. При этом вычисление быстрой команды /fast оба раза выполнялись в корневом процессе с id 868.Схематически весь процесс обработки команд, даже при одновременном их запуске, теперь выглядит так:В последовательном режиме выполнение всех команд заняло 32 секунды (10 + 10 + 1 + 10 + 1), в многопоточном всего 10 секунд. При этом даже в течении этих 10 секунд основной сеанс практически не был заблокирован, только на первые две секунды, когда в нём происходили вычисления быстрых команд /fast в последовательном режиме.","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\n\n# Включаем параллельный план вычислений\nfuture::plan('multisession')\n\nupdater <- Updater(\"Токен вашего бота\")\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  # Запускаем выполнение кода в параллельной сессии\n  future::future(\n    {\n      # Сообщение о том, что начата работа длительного вычисления\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n      \n      # Добавляем паузу, для того, что бы исскусственно сделать функцию длительной\n      Sys.sleep(10)\n      \n      # Сообщаем о том, что все вычисления выполнены\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n    }\n  )\n  \n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  \n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# создаём обработчик\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + slow_hendler + fast_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-асинхронность.html","id":"управление-количеством-потоков","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.5 Управление количеством потоков","text":"По умолчанию функция future::plan() при изменении плана с последовательного на многопоточный автоматически определяет оптимальное количество потоков, т.е. фоновых процессов, которые будут доступны в фоновом режиме. По умолчанию будет создано столько процессов, сколько ядер доступно в процессоре вашего ПК. Программно можно посмотреть количество доступных ядер следующим образом:В моём случае одновременно будет доступно 8 фоновых R сеансов. Для большинства задач этого будет достаточно, но в функции future::plan() доступен аргумент workers, который позволяет самостоятельно задать необходимое количество фоновых процессов.Приведённый выше код демонстрирует сокращение количества доступных процессов до 4ёх.","code":"\nfuture::availableCores()## system \n##      8\nfuture::plan('multisession', workers = 4)"},{"path":"добавляем-боту-асинхронность.html","id":"функция-promisesfuture_promise","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.6 Функция promises::future_promise()","text":"Пакет promises часто используется в связке с future органично дополняя его.В приведённых выше практических примерах нам было достаточно количества созданных фоновых потоков. Но всегда есть вероятность того, что все потоки будут заняты. Например, мы включили мультисессионый режим вычислений с двумя потоками (workers = 4) и бот получил практически одновременно 3 команды /slow. В таком случае первые две команды уйдут выполняться в фоновые процессы, а третья, и последующие встанут в очередь ожидания свободного процесса, заняв при этом основной процесс. В такой ситуации до тех пор, пока не появится свободный процесс, основной процесс будет заблокирован, и даже при попытке отправить быструю функцию /fast, она будет также поставлена в очередь.Решить эту проблему можно с помощью функции promises::future_promise(). Преимущество promises::future_promise() перед future::future(), заключается в том, что даже если нет свободных потоков, созданная очередь не будет блокировать основной поток, она будет создана так же в фоновом потоке. Для доработки приведенного ранее примера достаточно просто заменить в коде функции slow() функцию future::future() на promises::future_promise().","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\n\n# Включаем параллельный план вычислений\nfuture::plan('multisession')\n\nupdater <- Updater(\"Токен вашего бота\")\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  # Запускаем выполнение кода в параллельной сессии\n  promises::future_promise(\n    {\n      # Сообщение о том, что начата работа длительного вычисления\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n      \n      # Добавляем паузу, для того, что бы исскусственно сделать функцию длительной\n      Sys.sleep(10)\n      \n      # Сообщаем о том, что все вычисления выполнены\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n    }\n  )\n  \n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  \n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# создаём обработчик\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\n\n# добаляем добавляем в диспетчер\nupdater <- updater + slow_hendler + fast_hendler\n\n# запускаем бота\nupdater$start_polling()"},{"path":"добавляем-боту-асинхронность.html","id":"заключение-6","chapter":"Глава 7 Добавляем боту асинхронность","heading":"7.7 Заключение","text":"Итак, для того, что бы ваш бот умел одновременно обрабатывать входящие команды необходимо:Выявить список команд, требующих длительных вычислений.В начале скрипта добавить команду future::plan('multisession'), для того, что бы у вас была возможность запускать вычисление длительных операций в фоновых, параллельных R сеансах.Код методов бота, которые требуют длительных вычислений заворачиваем в future::future().Улучшить многопоточность бота можно заменив функцию future::future() на promises::future_promise(), которая оставляет свободным основной поток R, даже если все фоновые потоки заняты.Вы освоили асинхронное программирование, что значительно повысило производительность вашего бота. В следующей главе мы научимся упаковывать бота в Docker-контейнер, что упростит его развертывание и управление окружением. Приготовьтесь к следующему шагу в создании гибкой и переносимой инфраструктуры для вашего бота.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"упаковываем-бота-в-docker-контейнер","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"Глава 8 Упаковываем бота в Docker контейнер","text":"В восьмой главе нашего руководства мы сосредоточимся на упаковке вашего Telegram-бота в Docker-контейнер. Вы узнаете, как создать и настроить Docker-образ для вашего бота, что позволит вам легко развертывать его в различных средах и на разных платформах.Мы подробно рассмотрим процесс создания контейнера, включая написание Dockerfile, сборку образа и настройку контейнера. Вы увидите, как Docker упрощает управление зависимостями и окружением, обеспечивая согласованность и переносимость вашего проекта.Эта глава даст вам все необходимые инструменты для эффективного использования Docker, улучшая гибкость и удобство развертывания вашего бота. Надеюсь, что полученные знания помогут вам оптимизировать процесс разработки и управления проектом.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"что-такое-докер","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.1 Что такое докер","text":"Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений. Позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер.Docker предназначен для заключения сред внутри образа/контейнера. Это позволяет, например, иметь компьютер с Linux на Windows или компьютер с R 3.3, когда на вашем основном компьютере установлен R 3.5. Кроме того, это означает, что вы можете использовать более старые версии пакета для конкретной задачи, сохраняя при этом пакет на вашем компьютере в актуальном состоянии.Т.е. вы можете запустить бота в абсолютно изолированной среде, на которой будет предустановлены всё необходимое ПО, настроены переменные окружения, и она никак не будет зависеть от внешних настроек вашей операционной системы. Соответственно, при запуске контейнера по созданному образу на любой другой машине, вам не придётся её каким либо образом предварительно настраивать, прописывать переменные среды, устанавливать нужные пакеты, устанавливать сам язык R и т.д.В этом учебнике мы не будем подробно изучать сам Docker, т.к. это отдельная большая тема, а учебник у нас по разработке telegram ботов, а не работе с Docker. Но в интернете вы без проблем найдёте огромное количество статей и видео уроков, которые помогут вам глубже погрузиться в изучение возможностей Docker, несколько полезных ссылок я приведу в завершении данной главы. Здесь же мы лишь рассмотрим рабочий процесс упаковки и запуска бота написанного на языке R. В нашем случае мы рассмотрим рабочий процесс упаковки на примере ОС Windows 10 Home, но на других ОС процесс будет отличаться не значительно.Описанные в этой главе приёмы универсальны, по такому же принципу можно упаковать в Docker и запустить любой R скрипт.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"установка-docker","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.2 Установка Docker","text":"Для начала вам необходимо скачать и установить Docker на свой ПК. Тут есть некоторый нюанс, дело в том, что для Windows есть два варианта Docker:Docker WindowsDocker Toolbox WindowsКакую версию выбрать вам:Если у вас Windows 10 x64 Pro, Enterprise или Education то включаем службу Hyper-V и ставим Docker Windows.Если же у вас другая версия Windows(7 Pro, 8, 8.1, 10 Home) то ставим Virtual Box и Docker Toolbox Windows.У меня Windows 10 Home, если у вас тоже то перейдите по ссылке, скачайте инсталлятор для своей операционной системы и запустите процесс установки.У меня никаких дополнительных манипуляций процесс установки не потребовал, но в случае возникновения каких либо сложностей, я рекомендую найти на YouTube урок по установке Docker на вашу операционную систему. Например, в этом видео рассматривается процесс установки как Docker Windows, так и Docker Toolbox Windows.Все приведённые ниже примеры использовались с Docker Toolbox Windows.По завершению установки запустите Docker Quickstart Terminal, ярлык вы найдёте на рабочем столе.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"создаём-проект-в-rstudio","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.3 Создаём проект в RStudio","text":"Для удобства работы я рекомендую создать проект.Открываем RStudio и создаём новый проект. Перейдите в меню file -> New Project....Далее выбираем “New project” и указываем имя проекта.","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"код-бота","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.4 Код бота","text":"В данном случае нам не особо важен функционал нашего бота, поэтому мы просто возьмём код асинхронного бота из 7ой главы этого учебника, но предварительно немного его доработали:Мы добавили команду очистки очереди бота от старых сообщений, сразу после его инициализации.Добавили боту две новые команды:\n/stop - Команда остановки бота.\n/crush - Команда с ошибкой, имитирующая падение бота.\n/stop - Команда остановки бота./crush - Команда с ошибкой, имитирующая падение бота.Добавили боту процесс логирования его работы в обычный текстовый файл bot.log.Все эти доработки нам потребовались для демонстрации некоторых дополнительных возможностей, которые даёт Docker.Меню file -> New file -> R script (или сочетание клавиш Ctrl+Shift+N). Далее скопируйте приведённый ниже код бота, и сохраните его с именем bot.R.Обратите внимание, я явно указал количество потоков future::plan('multisession', workers = 4), т.к. в контейнере по умолчанию функция plan() определит всего 1 ядро, и соответственно бот будет запущен в последовательном режиме работы.","code":"\nlibrary(telegram.bot)\nlibrary(stringr)\nlibrary(lgr)\n\n# Включаем логгер\nlg <- get_logger()\nlg$set_appenders(AppenderFile$new(file = 'log/bot.log'))\nlg$info('Bot start')\n\n# Включаем параллельный план вычислений\nlg$info('Run multisession mode')\nfuture::plan('multisession', workers = 4)\n\n# Инициализируем бота\nlg$info('Make updater')\nupdater <-  Updater(bot_token('botname'))\n# Очищаем очередь бота от старых сообщений\nlg$info('Clean update queue')\nupdater$bot$clean_updates()\n\n# Функция с длительным временем вычислений\nslow_fun <- function(bot, update) {\n  \n  lg$info('Run slow command')\n  # Запускаем выполнение кода в параллельной сессии\n  promises::future_promise(\n    {\n      # Сообщение о том, что начата работа длительного вычисления\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция, начало работы!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n      \n      # Добавляем паузу, для того, что бы искусственно сделать функцию длительной\n      Sys.sleep(10)\n      \n      # Сообщаем о том, что все вычисления выполнены\n      bot$sendMessage(update$message$chat_id,\n        text = str_glue(\"Медленная функция выполнена!\\nID процесса: {Sys.getpid()}\"),\n        parse_mode = \"Markdown\")\n    }\n  )\n  \n}\n\n# Функция с коротким временем вычислений\nfast_fun <- function(bot, update) {\n  \n  lg$info('Run fast command')\n  # Просто отправляем сообщение\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Быстрая функция, выполняется последовательный режим!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n}\n\n# Остановка пуллинга\nstop <- function(bot, update) {\n  \n  lg$info('Bot stop')\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Останавливаю работу бота!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  # Просто отправляем сообщение\n  updater$stop_polling()\n  \n}\n\n# Функция с ошибкой, имитирующая падение бота\ncrush <- function(bot, update) {\n  \n  lg$info('Crush command')\n  bot$sendMessage(update$message$chat_id,\n    text = str_glue(\"Функция с ошибкой, сбой в работе бота!\\nID процесса: {Sys.getpid()}\"),\n    parse_mode = \"Markdown\")\n  \n  stop(\"Ошибка, сбой бота!\")\n  \n}\n\n# создаём обработчик\nlg$info('Make handlers')\nslow_hendler <- CommandHandler('slow', slow_fun)\nfast_hendler <- CommandHandler('fast', fast_fun)\nstop_hendler <- CommandHandler('stop', stop)\ncrush_hendler <- CommandHandler('crush', crush)\n\n# добавляем в диспетчер\nlg$info('Add handlers to dispatcher')\nupdater <- updater + slow_hendler + fast_hendler + stop_hendler + crush_hendler\n\n# запускаем бота\nlg$info('Run polling')\nupdater$start_polling()"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"образы-и-контейнеры","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.5 Образы и контейнеры","text":"В основе работы Docker лежат образы и созданные из них контейнеры. Образы — это описание среды и её настроек, необходимых для работы вашего бота (R, пакеты, переменные среды), а контейнеры — это фактически запущенные экземпляры образов. Образ создаётся один раз, а контейнеры будут запускаться всякий раз, когда вам необходимо запустить бота. И, конечно же, одновременно можно запускать несколько контейнеров с одними и теми же образами.Применительно к R, это тот же принцип, что установка и загрузка пакета. Для начала вам необходимо один раз установить пакет командой install.packages(), а потом подключать его командой library() каждый раз, когда вам требуется его функционал. И пакет можно легко запустить в нескольких сеансах R одновременно.Продолжая аналогию с пакетами, создание образа по смыслу схоже на команду install.packages(), а запуск контейнера на основе образа по смыслу близко к команде library().","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"создание-dockerfile","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.6 Создание Dockerfile","text":"Docker образ создаётся из Dockerfile. По сути это обычный текстовый файл, без расширения, в котором вы прописываете команды для развёртывания нужной для запуска вашего бота среды.Теперь необходимо создать в рабочей директории проекта обычный текстовый файл, и дать ему имя Dockerfile.Докер файл будет содержать следующие команды:Тут давайте остановимся и разберём отдельно каждую команду:rocker/r-ver:4.2.1, создаёт среду с установленным R 4.2.1, вы можете указать любую, нужную вам версию R.RUN mkdir /home/bot и RUN mkdir /home/bot/log создаёт в контейнере папку bot, и папку log внутри неё.ENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА эта команда создаёт переменную среды R_TELEGRAM_BOT_botname внутри контейнера. В данную переменную передайте токен вашего бота.COPY bot.R /home/bot/bot.R копирует скрипт с кодом нашего бота в контейнер.RUN R -e \"install.packages(c('telegram.bot', 'stringr', 'future', 'promises','fastmap', 'lgr'))\", конструкция RUN R -e \"код на R\" позволяет запускать внутри контейнера R команды. В данном случае мы устанавливаем все, нужные нам пакеты.CMD cd /home/bot, команда, которая переключает рабочую директорию на /home/bot. Команда CMD запускается каждый раз, при запуске контейнера.&& R -e \"source('/home/analysis/bot.R')\", объединяется с предыдущей командой, и запускает скрипт бота.Если вам необходимы определённые версии используемых пакетов то вы можете заменить команду из 5 пункта на:Или установить пакет из снимка MRAN на определённую дату:","code":"FROM rocker/r-ver:4.2.1\n\nRUN mkdir /home/bot\nRUN mkdir /home/bot/log\n\nENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА\n\nCOPY bot.R /home/bot/bot.R\n\nRUN R -e \"install.packages(c('telegram.bot', 'stringr', 'future', 'promises','fastmap', 'lgr'))\"\n\nCMD cd /home/bot \\\n  &&  R -e \"source('/home/bot/bot.R')\"RUN R -e \"install.packages('remotes'); \\\n  remotes::install_version('package_name', '0.1.2')\"RUN R -e \"options(repos = \\\n  list(CRAN = 'http://mran.revolutionanalytics.com/snapshot/2022-08-01/')); \\\n  install.packages('package_name')\""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"создание-образа","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.7 Создание образа","text":"Теперь нам необходимо перейти в терминал, и запустить команду создания образа docker build. Данная команда требует от вас передачи нескольких параметров:-t - позволяет задать тег вашего образа;вторым параметром является путь к папке с Dockerfile, если вы создали Dockerfile в текущем рабочем каталоге проекта, то просто в качестве этого параметра передайте точку.Т.е. для создания образа перейдите в терминал (найти терминал можно на соседней вкладке с консолью в RStudio) и запустите в терминале (не в консоли RStudio, а именно в терминале!) следующую команду:","code":"docker build -t rbot ."},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"запуск-контейнера","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.8 Запуск контейнера","text":"Итак, теперь у нас уже есть собранный Docker образ с нашим ботом, и нам остаётся запустить его командой docker run. При запуске контейнера вам необходимо указать следующие параметры:--name позволяет задать название контейнера-d флаг, который запускает контейнер в фоновом режиме, не блокируя терминалпоследним параметром мы задаём имя образа, на основе которого будет запущен контейнер.Дополнительно мы могли указать флаг --rm, который автоматически удалит контейнер после его остановки.","code":"docker run --name my_bot -d rbotdocker run --name my_bot -d --rm rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"прокидываем-токен-бота-в-контейнер-при-его-запуске","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.9 Прокидываем токен бота в контейнер при его запуске","text":"В примере выше мы указывали токен нашего бота непосредственно в Dockerfile с помощью команды ENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА. Это не всегда удобно, например, вам может понадобиться возможность указывать токен бота непосредственно при запуске контейнера и вам не хочется постоянно редактировать Dockerfile. В таком случае вы можете прокидывать переменные среды при запуске контейнера используя флаг -e.Вы можете удалить из Dockerfile команду ENV R_TELEGRAM_BOT_botname ТОКЕН_ВАШЕГО_БОТА, и прокинуть эту же переменную непосредственно при запуске контейнера.","code":"docker run --name my_bot -d --rm -e R_TELEGRAM_BOT_botname=\"ТОКЕН_ВАШЕГО_БОТА\" rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"политика-перезапуска-бота","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.10 Политика перезапуска бота","text":"В главе “Повышаем стабильность работы бота” мы разобрались, как написать бота, который автоматически перезапускается в случае падения.При запуске бота через docker контейнер, у вас есть отдельная опция --restart, которая позволяет более гибко управлять перезапуском вашего бота. Данная опция принимает одно из следующих значений:- Не перезапускать контейнер после завершения. Это значение по умолчанию.-failure[:max-retries] - Перезапускает контейнер если он завершился с не нулевым статусом (т.е. завершился с ошибкой). Опционально можно указать количество попыток перезапуска. Это наиболее подходящая опция для работы бота, т.к. вы можете добавить боту метод остановки пуллинга, и он при запуске команды остановки успешно выключиться, а в случае аварийной остановки - будет перезапущен.always - Всегда перезапускает контейнер в не зависимости от статуса завершения. Когда вы выбираете данный вариант, Docker демон будет пытаться перезапустить контейнер бесконечное число раз. Также контейнер будет всегда запускаться при запуске демона, не зависимо от текущего состояния контейнера. В данном случае у вас не будет возможности остановить бота.unless-stopped - Всегда перезапускает контейнер не зависимо от статуса завершения, но контейнер не будет запускаться при запуске демона, если контейнер до этого был остановлен вручную.Т.е. следующая команда позволяет запустить бота, который автоматически будет перезапуска в случае ошибки, но при этом, вы в любой момент сможете остановить его любой командой.Давайте протестируем команду /crush и /stop, как я уже писал ранее, первая имитирует ошибку в работе бота, вторая же корректно останавливает его работу.Из скрина видно, что даже при выполнении команды /crush вызывающую критическую ошибку и падение бота, сам бот автоматически перезапускается, очищает очередь команд, и продолжает работу.Команда /stop при этом корректно останавливает работу бота.","code":"docker run --name my_bot -d --rm -e --restart=on-failure rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"просмотр-списка-запущенных-контейнеров","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.11 Просмотр списка запущенных контейнеров","text":"Команда docker ps позволяет посмотреть список запущенных в данный момент контейнеров.","code":"docker ps"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"остановка-контейнера","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.12 Остановка контейнера","text":"Для остановки контейнера используйте команду docker stop, передав в качестве единственного аргумента либо id, либо название контейнера, который необходимо остановить, в моём случае равнозначными будет две следующее команды:","code":"docker stop my_botdocker stop d06f8cebe987"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"удаление-контейнера","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.13 Удаление контейнера","text":"После остановки контейнера с ботом вы можете его удалить командой docker rm передав ей имя контейнера.","code":"docker rm my_bot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"публикация-образа-в-docker-hub","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.14 Публикация образа в Docker hub","text":"На данном этапе мы уже разобрались с тем, как устроен Docker, и узнали его основные команды. Но пока мы работали с образами, и запускали контейнеры локально, на ПК на котором мы эти образы собирали. Вся мощь Docker заключается в том, что собранные образы очень легко можно переносить на любой другой ПК, единственное требование - наличие на нём установленного Docker.Для такого переноса удобно использовать docker-hub, для начала перейдите по ссылке и зарегистрируйтесь там.Далее возвращаемся в терминал RStudio, логинимся в Docker-hub.Далее введите свой логин и пароль, или ключ API вместо пароля. Теперь нам необходимо добавить нужный тег нашему образу для его публикации. Команда tag принимает два аргумента, имя образа, которому надо присвоить тег, и сам тег. Присваиваемый тег должен иметь следующий вид username/repository, т.е. имя пользователя на Docker-hub и название репозитория, куда вы хотите опубликовать образ.Следующая команда позволяет опубликовать образ на Docker-hub:Теперь вы можете загрузить опубликованный ранее образ на любой ПК, независимо от того, какая на нём установлена операционная система, главное предварительно установите на него сам Docker. Используйте следующую команду, что бы забрать образ из Docker-hub:После чего образ будет загружен в ваш локальный реестр образов, убедиться в этом можно с помощью команды docker images. Процесс запуска контейнера из загруженного образа ничем не отличается от описанного выше в этой главе.Обратите внимание, если вы планируете опубликовать образ с публичным доступом, то не включайте в Dockerfile секретные данные, такие как токен бота или пароли. Рекомендованным способом передачи секретных данных в контейнер является прокинуть необходимые переменные с этими данными непосредственно при запуске контейнера как описано в разделе Прокидываем токен бота в контейнер при его запуске.","code":"docker logindocker tag rbot username/rbotdocker push username/rbotdocker pull username/rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"как-создать-общую-папку-для-хранения-файлов","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.15 Как создать общую папку для хранения файлов","text":"По умолчанию контейнер является полностью изолированным, т.е. все файлы, которые создаются внутри контейнера, удаляются после его запуска, и все данные которые были в эти файлы записаны, также удаляются.В ходе работы нашего бота пишется лог, сам файл лога bot.log создаётся внутри контейнера в папке log, и за пределами самого контейнера он не доступен. В коде нашего бота за создание лога отвечает следующие команды:Если вы до этого момента не знакомы с процессом логирования, то рекомендую либо ознакомиться со статьёй “Логирование выполнения скриптов на языке R, пакет lgr”, либо видео уроком “Логирование процесса выполнения скриптов на языке R (пакеты lgr / lgrExtra)”.В данном случае лог пишется в обычный текстовый файл. Но функционал может быть гораздо шире, чем в рассматриваемом нами примере, бот может работать с базой данных, может принимать какие-то файлы. И нам может потребоваться получить доступ к этим данным.Для того, что бы организовать на вашем ПК общую с каким либо контейнером папку в Docker есть понятие томов - volume. Но при работе на Windows требуется некоторая предварительная подготовка.Вместе с Docker toolbox вы установили несколько программ, включая Oracle VM Virtual Box. Запустите её, если у вас возникает ошибка при запуске VirtualBox, то скорее всего вам необходимо перейти по ссылке, и скачать наиболее актуальную версию.В Virtual Box выберите дефолтную машину и нажмите “Настроить”:Перейдите в меню “Общие папки” и создайте новую общую папку прописав ей путь и дав имя. В моём случае сама папка находится по пути D:\\packlab\\docker_bot\\log, и имя для неё я задал d/packlab/docker_bot/log:Теперь вернитесь в терминал RStudio и перезапустите виртуальную машину командой docker-machine restart.Теперь вернитесь в терминал RStudio и перезапустите виртуальную машину командой docker-machine restart.После перезагрузки, при запуске контейнера используйте флаг -v и укажите через двоеточие соответствие папки на локальном компьютере с папкой в контейнере. В нашем случае папка на локальном компьютере d/packlab/docker_bot/log должна быть связана с папкой /home/bot/log в контейнере. Команда будет выглядеть следующим образом:После перезагрузки, при запуске контейнера используйте флаг -v и укажите через двоеточие соответствие папки на локальном компьютере с папкой в контейнере. В нашем случае папка на локальном компьютере d/packlab/docker_bot/log должна быть связана с папкой /home/bot/log в контейнере. Команда будет выглядеть следующим образом:Обратите внимание, я указал двойной слеш // перед именем папки на локальном компьютере, без этого иногда при запуске контейнера возникает ошибка invalid value \"C:\\\\...\" flag -v: ...:... absolute path.Сразу после запуска у меня в локальной папке \"D:\\packlab\\docker_bot\\log\" создаётся файл bot.log, в котором в реальном времени пишется лог работы бота, давайте в этом убедимся:Содержание локального файла bot.log:Отставание на 4 часа между временем в telegram, и файлом лога объясняется тем, что в контейнере по умолчанию установлен другой часовой пояс - UTC.","code":"\nlibrary(lgr)\n\n# Включаем логгер\nlg <- get_logger()\nlg$set_appenders(AppenderFile$new(file = 'log/bot.log'))\nlg$info('Bot start')docker run --rm --name my_bot -v //d/packlab/docker_bot/log:/home/bot/log rbot"},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"полезные-ссылки","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.16 Полезные ссылки","text":"Как я уже писал в начале главы, в интернете полно информации по работе с Docker, тем не менее тут я приведу небольшую подборку ссылок, которые помогут вам получше с ним разобраться:Основы Docker. Большой практический выпускAn Introduction Docker R Users (англ.)Docker под Windows для разработки, разбор подводных камней","code":""},{"path":"упаковываем-бота-в-docker-контейнер.html","id":"заключение-7","chapter":"Глава 8 Упаковываем бота в Docker контейнер","heading":"8.17 Заключение","text":"Теперь мы умеем упаковывать telegram ботов в контейнер, что даёт несколько следующих преимуществ:Вы легко можете перенести вашего бота с ноутбука на сервер, или переносить его между серверами, весь процесс займёт пару минут. Никакой предварительной настройки среды для запуска бота теперь не потребуется.У вас появляется более гибкая возможность управления политикой перезапуска бота.Основные команды docker и их параметры, которые вам понадобятся в ходе упаковки, запуска, публикации и загрузки бота:docker build - создать образ:\n-t - тег образа;\nвторой аргумент - путь к папке с Dockerfile.\n-t - тег образа;второй аргумент - путь к папке с Dockerfile.docker run - запуск контейнера:\n--name - имя контейнера;\n-d - запускает контейнер в фоновом режиме;\n--rm - автоматически удаляет контейнер после его остановки;\n-e - создаёт переменную окружения при запуске контейнера;\n--restart - управление политикой перезапуска контейнера;\n-v позволяет прикрепить к контейнеру физическую папку на вашем локальном ПК;\nпоследний аргумент - имя образа на основе которого будет запущен контейнер.\n--name - имя контейнера;-d - запускает контейнер в фоновом режиме;--rm - автоматически удаляет контейнер после его остановки;-e - создаёт переменную окружения при запуске контейнера;--restart - управление политикой перезапуска контейнера;-v позволяет прикрепить к контейнеру физическую папку на вашем локальном ПК;последний аргумент - имя образа на основе которого будет запущен контейнер.docker ps - просмотр списка запущенных контейнеров:\n-выводит список всех контейнеров, включая остановленные.\n-выводит список всех контейнеров, включая остановленные.docker stop - остановка контейнера:\nв качестве параметра необходимо передать имя или id контейнера.\nв качестве параметра необходимо передать имя или id контейнера.docker rm - удаление контейнера:\nв качестве параметра необходимо передать имя или id контейнера.\nв качестве параметра необходимо передать имя или id контейнера.docker login - авторизация в Docker-hub.docker tag - добавить тег образу:\nлокальное название образа, которому надо присвоить тег;\nназвание образа в docker-hub по шаблону username/repository.\nлокальное название образа, которому надо присвоить тег;название образа в docker-hub по шаблону username/repository.docker push - опубликовать образ в docker-hub:\nназвание образа в docker-hub по шаблону username/repository.\nназвание образа в docker-hub по шаблону username/repository.docker pull - забрать образ из docker-hub:\nназвание образа в docker-hub по шаблону username/repository.\nназвание образа в docker-hub по шаблону username/repository.Отличная работа по упаковке бота в Docker-контейнер! Вы научились использовать Docker для удобного управления и развертывания вашего бота. В последней главе мы развернем бота на Google Cloud Run, чтобы обеспечить его масштабируемость и доступность. Это финальный шаг в нашем путешествии, и вы скоро увидите, как все ваши знания и навыки воплотятся в рабочем облачном решении.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"разворачиваем-бота-в-облачных-сервисах","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"Глава 9 Разворачиваем бота в облачных сервисах","text":"Поздравляю с завершением предыдущих этапов! Мы подходим к финальной части нашего путешествия, и в этой главе мы сосредоточимся на важном шаге — развертывании вашего бота на Google Cloud Run. Это позволит вашему боту работать в облаке, обеспечивая масштабируемость и надежность.Важной частью этого процесса является настройка технологии Webhook, которая позволяет вашему боту получать обновления в реальном времени. Мы подробно рассмотрим, как настроить Webhook для вашего бота, чтобы он мог эффективно обрабатывать входящие сообщения и команды от пользователей. Эта технология обеспечивает мгновенную доставку данных и позволяет вашему боту реагировать на события практически моментально.Мы также изучим, как использовать Google Cloud Run для размещения вашего бота, рассмотрим его настройку и управление окружением. Это обеспечит надежную работу вашего бота и упростит его масштабирование при необходимости.В завершение главы вы будете готовы запустить своего бота в облаке, и все ваши знания и навыки будут полностью реализованы в рабочем решении.Для того что бы повторить действия описанные в этой главе вам понадобится установить следующее ПО:Docker DesktopGitGoogle Cloud SDK ShellHeroku CLIПосле установки Docker Desktop перезагрузите ПК,и запуститье эту программу.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"google-cloud-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1 Google Cloud Run","text":"","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"условные-обозначения","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.1 Условные обозначения","text":"В этой главе мы много будем работать с командной сторокой, и облачными сервисами. В примерах команд, которые мы будем использовать вы увидите специальные обозначения =, они будут выделены квадратными скобками, и написаны большими буквами. Эти значения необходимо заменить на ваши:[PROJECT ID] - Id проекта в Google Cloud[IMAGE NAME] - Название Docker образа[CONTAINER NAME] - Название Docker контейнера[JOB NAME] - Название задания в Google Cloud Run[SCHEDULER JOB NAME] - Название триггера в Google Cloud Run Job[SERVICE NAME] - Название сервиса в Google Cloud RunТ.е. если вы решили назвать Docker образ “-bot”, а идентификатор вашего проекта в Google Cloud “tg-bot-091276”. То следующую команду:Необходимо заменить на:","code":"docker push gcr.io/[PROJECT ID]/[IMAGE NAME]docker push gcr.io/tg-bot-091276/my-bot"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"введение-в-google-cloude-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.2 Введение в Google Cloude Run","text":"Google Cloud Run — это полностью управляемый сервис от Google Cloud, который позволяет развёртывать и масштабировать контейнерные приложения. Он предназначен для запуска HTTP-приложений и других серверных функций без необходимости управления серверной инфраструктурой. Основные преимущества Cloud Run включают автоматическое масштабирование, оплату только за фактическое использование и интеграцию с другими сервисами Google Cloud.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"services-и-jobs-в-google-cloud-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.2.1 Services и Jobs в Google Cloud Run","text":"Google Cloud Run позволяет вам создать 2 типа заданий:Jobs (Задачи):\nCloud Run Jobs предназначены для выполнения одноразовых или периодических задач, которые не требуют HTTP-запросов. Это может быть полезно для различных сценариев, таких как обработка данных, резервное копирование, пакетная обработка и т. д. Ключевые характеристики задач:Ограниченное выполнение: Задачи запускаются по требованию и выполняются один раз.Асинхронные операции: Задачи могут выполняться в фоновом режиме, не требуя взаимодействия с пользователем.Параллельные задания: Возможность запуска множества экземпляров задачи для параллельной обработки данных.Пример использования:Ежедневное резервное копирование базы данных.Обработка очередей задач из очереди сообщений.Конвертация и обработка изображений по расписанию.Services (Сервисы)\nCloud Run Services предназначены для обслуживания HTTP-запросов. Это означает, что они используются для развёртывания веб-приложений, API и других HTTP-сервисов. Вот некоторые ключевые характеристики сервисов:HTTP-триггеры: Сервисы обрабатывают HTTP-запросы и возвращают HTTP-ответы.\nАвтоматическое масштабирование: Сервисы автоматически масштабируются в зависимости от нагрузки — от нуля до бесконечности контейнеров.\nСтатическое и динамическое содержание: Могут обрабатывать как статические файлы, так и динамически генерируемые данные.\nНастройка URL и доменов: Возможность привязки пользовательских доменов и маршрутизации трафика.Пример использования:Telegram боты.RESTful API для мобильного приложения.Прокси-сервис для обработки и маршрутизации HTTP-запросовТо есть, с помощью Job мы можем настроить запуск скрипта по расписанию, например, уже знакомого нам по первой главе скрипта, который запрашивает курсы валют и отправляет их в Telegram. С помощью Service мы можем развернуть полноценного бота с поддержкой команд и клавиатур, который будет обрабатывать запросы пользователей. Далее разберёмся с обеими функциями Google Cloud Run.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"как-настроить-запуск-скрипта-по-рассписанию-с-помощью-google-cloude-run-job","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3 Как настроить запуск скрипта по рассписанию с помощью Google Cloude Run Job","text":"","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"видео","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.1 Видео","text":"","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"обзор-рабочего-процесса-1","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.2 Обзор рабочего процесса","text":"Весь рабочий процесс по настройке запуска R-скрипта по расписанию выглядит следующим образом:Создайте и настройте проект в Google Cloud.Напишите R-скрипт, который планируете запускать по расписанию.Создайте Dockerfile для создания образа, на основе которого будет создаваться контейнер.Проведите тестовую сборку образа и запуск контейнера.С помощью Google Cloud SDK инициализируйте командную строку с вашим проектом в Google Cloud.Тегируйте и загрузите Docker-образ в Google Container Registry.Настройте Job в Google Cloud Run.Создайте триггер для запуска созданной Job.Теперь давайте рассмотрим каждый из этих шагов подробнее.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"настройка-проекта-в-google-cloud","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.3 Настройка проекта в Google Cloud","text":"Переходим в Google Cloud ConsoleС помощью выпадающего меню в верхнем левом углу экрана создаём новый проектПереходим в созданный проектВключаем в проекте необходимые API сервисы, в левом меню:\nCloud Run Admin API\nGoogle Schedule API\nArtifact Registry API\nCloud Run Admin APIGoogle Schedule APIArtifact Registry APIПри желании активировать необходимые API вы сможете позже через Google Cloud SDK.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"скрипт-который-будем-разворачивать-в-google-cloud-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.4 Скрипт который будем разворачивать в Google Cloud Run","text":"Ниже приведен листинг скрипта, который мы будем запускать по расписанию:Чтобы использовать этот же код, вам необходимо получить API-ключ на сайте exchangerate-api.com. Файл с R-кодом в данном случае называется currency_rates_alert.R, и это имя файла будет использоваться на следующем шаге.","code":"\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(telegram.bot)\nlibrary(stringr)\n\nget_exchange_rate <- function(api_key) {\n  url <- paste0(\"https://api.exchangerate-api.com/v4/latest/USD?apikey=\", api_key)\n  response <- GET(url)\n  data <- fromJSON(content(response, \"text\"))\n  return(data)\n}\n\nsend_telegram_message <- function(bot_token, chat_id, message) {\n  bot <- Bot(token = bot_token)\n  bot$sendMessage(chat_id = chat_id, text = message)\n}\n\n# Функция для выполнения основного логики\nexecute_script <- function() {\n  api_key   <- Sys.getenv(\"EXCHANGE_RATE_API_KEY\")\n  bot_token <- Sys.getenv(\"TELEGRAM_BOT_TOKEN\")\n  chat_id   <- Sys.getenv(\"TELEGRAM_CHAT_ID\")\n  \n  exchange_rate <- get_exchange_rate(api_key)\n  message <- str_glue(\n    \"Курс валют на {Sys.Date()}\",\n    '-----------------------------',\n    \"Курс EUR к USD: {exchange_rate$rates$EUR}\", \n    \"Курс GBP к USD: {exchange_rate$rates$GBP}\",\n    \"Курс UAH к USD: {exchange_rate$rates$UAH}\",\n    \"Курс EGP к USD: {exchange_rate$rates$EGP}\", \n    .sep = '\\n'\n    )\n  \n  send_telegram_message(bot_token, chat_id, message)\n}\n\n# Выполнение скрипта\nexecute_script()"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"создаём-dockerfile","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.5 Создаём Dockerfile","text":"С Dockerfile и функционалом Docker вы познакомились в предыдущей главе Упаковываем бота в Docker контейнер. Для нашего скрипта нужен следующий Dockerfile:В Dockerfile замените ВАШ_API_КЛЮЧ_К_EXCHANGERATE_API, ТОКЕН_ВАШЕГО_БОТА и ID_ЧАТА_КУДА_НАДО_ПРИСЛАТЬ_СООБЩЕНИЕ на ваши значения. Так же если файл с вашим R скриптом имеет другое название, то и в Dockerfile его необходимо изменить с currency_rates_alert.R.","code":"FROM rocker/r-base:latest\n\nSHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-e\", \"-u\", \"-x\", \"-c\"]\nUSER 0\nRUN apt-get update && apt-get install -y r-base r-base-core r-base-dev \\\n    libcurl4-openssl-dev libssl-dev && \\\n    rm -r /var/lib/apt/lists/*\n\n# Установка необходимых пакетов\nRUN R -e \"install.packages(c('httr', 'jsonlite', 'telegram.bot', 'stringr'), repos = 'http://cran.us.r-project.org')\"\n\n# Копирование R-скрипта в контейнер\nCOPY currency_rates_alert.R /app/currency_rates_alert.R\n\n# Установка переменных окружения (замените на свои значения)\nENV EXCHANGE_RATE_API_KEY=ВАШ_API_КЛЮЧ_К_EXCHANGERATE_API\nENV TELEGRAM_BOT_TOKEN=ТОКЕН_ВАШЕГО_БОТА\nENV TELEGRAM_CHAT_ID=ID_ЧАТА_КУДА_НАДО_ПРИСЛАТЬ_СООБЩЕНИЕ\n\n# Запуск R-скрипта\nCMD [\"Rscript\", \"/app/currency_rates_alert.R\"]"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"тестовая-сборка-образа-и-запуск-контейнера","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.6 Тестовая сборка образа и запуск контейнера","text":"Когда ваш скрипт готов и вы убедились, что он работает, запустив его предварительно в интерактивном режиме RStudio, протестируйте сборку образа и запуск контейнера локально.давайте перейдём в директорию с нашим проектом, т.е. в папку, в которой у вас хранится R скрипт и Dockerfile:Замените путь на ваш.Далее выполним сборку образа и запуск контейнера, для этого следующие команды:Если контейнер был успешно собран и ваш скрипт выполнился, можно переходить к следующему шагу.Подробности работы с Docker смотрите в главе Упаковываем бота в Docker контейнер.","code":"cd C:\\Users\\SAMSUNG\\Documents\\currency_rates_alertdocker build -t [IMAGE NAME] .\ndocker run --name [CONTAINER NAME] --rm [IMAGE NAME]"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"инициализация-google-cloud-sdk","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.7 Инициализация Google Cloud SDK","text":"Если у вас еще не установлен Google Cloud SDK, следуйте этой инструкции для его установки. После установки запустите Google Cloud SDK и выполните инициализацию:Эта команда откроет веб-браузер, чтобы вы могли войти в Google Cloud и выбрать проект, который будете использовать. После завершения инициализации сохраните конфигурацию.Далее вам необходимо настроить Docker для работы с Google Container Registry:, воспользуйтесь для этого следующей командой:Если при создании проекта вы не активировали нужные API, то на этом шаге вы можете сделать это из командной строки:Проверить список активированных в проекте API можно следующей командой:","code":"gcloud initgcloud auth configure-dockergcloud services enable run.googleapis.com\ngcloud services enable cloudscheduler.googleapis.com\ngcloud services enable artifactregistry.googleapis.comgcloud services list --enabled"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"тегирование-и-загрузка-docker-образа-в-google-container-registry","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.8 Тегирование и загрузка Docker-образа в Google Container Registry","text":"После успешного локального тестирования можно приступать к отравке образа и разворачиванию контейнера в Google Cloud. Но до этого образ необходимо тегорировать. Тегирование Docker-образа необходимо для его идентификации и управления версиями. В контексте работы с Google Container Registry (GCR) тегирование помогает определить, какой именно образ вы хотите загрузить, развернуть или использовать в дальнейшем.Замените [PROJECT ID] на идентификатор вашего проекта в Google Cloud.","code":"docker tag [IMAGE NAME] gcr.io/[PROJECT ID]/[IMAGE NAME]\ndocker push gcr.io/[PROJECT ID]/[IMAGE NAME]"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"настраиваем-job-в-google-cloud-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.9 Настраиваем Job в Google Cloud Run","text":"Для удобства дальнейшей работы перейдите в веб интерфейс сервиса Google Cloud Run на вкладку Jobs и нажмите кнопку “Create Job”.В поле “” нажмите кнопку “Select” и укажиет загруженный на прошлом шаге образ.После чего можете задать произвольное имя для джобы, и нажать “Create”.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"тестирование-созданной-job-в-google-cloud-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.10 Тестирование созданной Job в Google Cloud Run","text":"Для тестирования просто откройте нужную Job и нажмите “Execute”. Если задание успешно выполнися то можно переходить на вкладку TRIGGERS и создать расписание запуска.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"создаём-тригер-для-запуска-созданной-job","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.3.11 Создаём тригер для запуска созданной Job","text":"Мы на финальном шаге, всё, что нам остаётся это создать триггер для запуска созданного задания. На вкладке “TRIGGERS” жмём кнопку “ADD SCHEDULER TRRIGER”.В открывшемся диалоговом окне,в поле “Frequency” вам необходимо написать CRON выражение, для создания расписания запуска задания. В первой главе мы уже сталкивались с CRON выражении в разделе Настраиваем запуск расписания отправки сообщения с помощью GitHub Actions. Но я продублирую тут эту информацию.CRON выражение состоит из 5 значений, любое из которых можно пропустить поставив *:Минуты (0-59)Часы (0-23)День месяца (1-31)Месяц (1-12)День недели (0-6, где 0 — воскресенье)Т.е. если мы хотим настроить запуск нашего задание в 10:15 утра каждый понедельник то CRON выражение будет 15 10 * * 1, т.е.:15 - это 15 минут10 - это 10 часовДалее две звезды значит что мы пропускаем месяца и день месяца, они не будут учитываться в расписании.1 - понедельник.Но я сейчас создам триггер для запуска скрипта в 10:15 на ежедневной основе, т.е. 15 10 * * *.Так же вы можете нажать “Continue” вы можете настроить запуск задания от имени созданного вами сервисного аккаунта, но учтите что в таком случае вам необходимо для этого сервисного аккаунта в разделе IM выдать следующие разрешения:Откройте Google Cloud ConsoleПерейдите в раздел “IAM & Admin” > “IAM”Найдите ваш сервисный аккаунт (service-account-name@ptoj_id.iam.gserviceaccount.com)Нажмите на карандаш рядом с ним для редактирования разрешенийДобавьте следующие роли:Cloud Run Invoker (roles/run.invoker): Эта роль позволяет сервисному аккаунту запускать Job.Cloud Run Developer (roles/run.developer): Эта роль дает возможность создавать, обновлять и удалять Job, а также просматривать их логи.Service Account User (roles/iam.serviceAccountUser): Эта роль нужна, если ваш Job выполняется от имени другого сервисного аккаунта.Но, на самом деле создать Job и добавить в неё триггер можно непосредственно из самой консоли:Создание Job:Добавление триггера:Но, как по мне проще создавать Job и добавить ей триггеры через Веб интерфейс.","code":"gcloud run jobs create [JOB NAME] --image gcr.io/[PROJECT ID]/[IMAGE NAME] --platform managedgcloud scheduler jobs create http [SCHEDULER JOB NAME] \\\n    --schedule \"30 10 * * *\" \\\n    --http-method POST \\\n    --uri https://YOUR_REGION-run.googleapis.com/v2/projects/YOUR_PROJECT_ID/locations/YOUR_REGION/jobs/YOUR_JOB_NAME:run \\\n    --oauth-service-account-email YOUR_SERVICE_ACCOUNT_EMAIL \\\n    --region YOUR_REGION"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"разворачиваем-telegram-бота-в-google-cloud-run-service","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4 Разворачиваем Telegram бота в Google Cloud Run Service","text":"Как я уже писал в начале этой главе в сервисе Google Cloud Run есть 2 типа заданий, разовое - Job, и постоянное фоновое - Service. Для того, что бы запустить бота, который будет крутится в фоновом режиме и обрабатывать входящие запросы нам необходимо использовать именно Service.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"видео-1","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.1 Видео","text":"","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"рабочий-процесс","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.2 Рабочий процесс","text":"При развёртывании бота в Google Cloud Run Service алгоритм ваших действий будет следующим:Напишите скрипт бота, которого планируете развернуть.Создайте Dockerfile для создания образа, на основе которого будет создаваться контейнер.Проведите тестовую сборку образа и запуск контейнера.Создайте и настройте проект в Google Cloud.С помощью Google Cloud SDK инициализируйте командную строку с вашим проектом в Google Cloud.Тегируйте и загрузите Docker-образ в Google Artifact Registry.Запустите бота в Google Cloud Run для того что бы получить Webhook URL.Исправьте в переменных среды Webhook URL, выполните повторную сборку, отправку и развёртку вашего бота в Google Cloud Run.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"webhook-вместо-polling","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.3 Webhook вместо polling","text":"Прилшло время более подробно разобраться с тем, как устроен механизм получения ботом обновлений, и совсем немного окунутся в историю развития клиент серверных технологий.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"разница-между-механизмами-polling-и-webhook","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.3.1 Разница между механизмами polling и webhook","text":"В ранние годы веб-технологий, когда серверные технологии и базы данных только начинали развиваться, коммуникация между клиентом (в нашем случае машиной на которой работает скрипт вашего бота) и сервером (в нашем случае сервер Telegram API) была довольно простой. Клиенты периодически отправляли запросы к серверу для проверки наличия новых данных. Такой механизм получил название polling.Polling — это метод, при котором бот регулярно (с определённым интервалом) отправляет запросы к серверу Telegram для проверки наличия новых обновлений. Внутри класса Updater технически это реализуется так:Бот делает запросы к Telegram API с помощью метода getUpdates.Если есть новые сообщения или обновления, сервер Telegram отправляет их боту.Бот обрабатывает эти обновления и отвечает на них.До этого момента во всех примерах, которые я приводил в этой книге мы с вами использовали именно этот механиз получения обновлений. Делали мы это только потому, что его максимально просто запустить на локальной машине. Polling будет работать даже если к машине на которой вы развернули бота нет доступа из внешних ресурсов, firewall блокирует любые попытки достучатся до вашего ПК извне так как нет необходимости в открытых портах для входящих соединений, и даже если у вас динамический IP адрес.Polling был простым и понятным методом, но с увеличением количества пользователей и данных его эффективность стала проблемой. На смену polling пришел Webhook, который был разработан для решения проблем, связанных с эффективностью и нагрузкой при использовании polling. Webhook представляет собой более современный подход к получению обновлений и был внедрён для улучшения производительности и уменьшения задержек. Работает он по следующей схеме:Бот регистрирует URL для webhook с помощью метода setWebhook.Когда есть новое обновление, Telegram отправляет запрос на указанный URL.Бот получает и обрабатывает обновление в реальном времени.Схематично сравнить эти два механизма можно следующим образом:Если провести аналогию из реального мира, то представьте, что у вас есть старый почтовый ящик, и каждый день вы отправляетесь к нему, чтобы проверить, пришла ли новая почта. Вы открываете ящик и смотрите, есть ли что-то новое. Если нет, вы возвращаетесь домой и снова идёте проверять на следующий день. Это и есть polling. Теперь представьте, что у вас есть специальный почтальон, который приходит к вам домой каждый раз, когда приходит новая почта. Вместо того, чтобы самому ходить к почтовому ящику, почтальон вам сам звонит в дверь и приносит письмо прямо к вам. Это и есть webhook.Так вот, запустить механизм polling легко и просто на локальной машине, т.к. от вас не требуется практически никаких дополнительных настроект, но вот облачные технологии стремятся к тому, что бы экономить выделенные ресурсы, поэтому они позволяют вам развернуть бота используя технологию Webhook, Google Cloud Run не является тут исключением. К тому же технология Webhook позволит вам экономить на использовании раздичных облачных систем для развёртования бота, т.к. зачастую вы там платите только за используемые ресурсы.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"реализация-webhook-в-пакете-telegram.bot","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.3.2 Реализация webhook в пакете telegram.bot","text":"Изначально пакет telegram.bot включал в свой функционал только polling, метод обновления данных webhook в него был добавлен только в версии 3.0.0 сторонним разработчиком, но сделано это было по моей просьбе, кому интересно история добавления этого метода началась в этой ветке на GitHub, а [тут]9https://github.com/ebeneditos/telegram.bot/pull/27) уже был добавлен класс Webhook в пакет.Класс Webhook очень похож на Updater, ниже пример работы с ним:Т.е. процесс такой же как и при создании Updater, но помимо токена бота вам ещё необходимо указать webhook url, на который telegram будет присылать для бота обновления. О том как его получить мы поговорим немного позже. Далее, так же как и с Updater, вы просто добавляете в Webhook все обработчики, и запускаете процесс обработки обновления методом start_server(), который является аналогом start_polling().","code":"\n# Создаём метод start\nstart <- function(bot, update) {\n bot$sendMessage(\n   chat_id = update$message$chat_id,\n   text = sprintf(\n     \"Hello %s!\",\n     update$message$from$first_name\n   )\n )\n}\n\n# Инициализируем экземпляр класса Webhook\nwebhook <- Webhook(\n  webhook_url = \"https://example.com/webhook\", \n  token       = Sys.getenv(\"TOKEN\"), \n  verbose     = TRUE\n)\n\n# wire up handler\nwebhook <- webhook + CommandHandler(\"start\", start)\n\n# start polling\nwebhook$start_server(host = \"0.0.0.0\", port = 8080)\n\n# stop polling\nwebhook$stop_server()"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"код-бота-запрашивающего-курсы-валют","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.4 Код бота запрашивающего курсы валют","text":"В этом разделе мы продолжим развивать тему прошлого раздела о получении информации курсов валют, но теперь мы напишем полноценного бота, которого в любой момент можно спросить курс любой валюты.Код нашего бота:В основе метода get_cur_rate лежит логика, описанная в прошлом разделе. Бот получает сообщение в котором указан код валют, далее запрашивает курсы из exchangerate-api, парсит результат, и отправляет в ответе курс по указанной ранее валюте.Далее мы инициализируем объект класса Webhook, и передаём в аргумент webhook_url значение переменной среды WEBHOOK_URL, а в аргумент token, значение переменной R_TELEGRAM_BOT_CURBOT. Значения этих переменных мы будем задавать в Dockerfile.","code":"\nlibrary(telegram.bot)\nlibrary(httr)\nlibrary(jsonlite)\n\n# Метод запроса курса валют\nget_cur_rate <- function(bot, update, args) {\n  \n  currency_code <- toupper(args)\n  api_key <- Sys.getenv('EXCHANGERATE_API_KEY')\n  url     <- paste0(\"https://api.exchangerate-api.com/v4/latest/USD?apikey=\", api_key)\n  \n  response <- GET(url)\n  data <- fromJSON(content(response, \"text\"))\n  \n  if (!currency_code %in% names(data$rates)) {\n    bot$sendMessage(chat_id = update$message$chat_id, text = paste0(args, \" is Invalid currency code.\"))\n    return(NULL)\n  }\n  \n  rate <- data$rates[[currency_code]]\n  message <- sprintf(\"Курс %s к USD: %f\", currency_code, rate)\n  bot$sendMessage(chat_id = update$message$chat_id, text = message)\n  \n}\n\n# Создаём Webhook\nwebhook <- Webhook(\n  webhook_url = Sys.getenv('WEBHOOK_URL'), \n  token       = bot_token('CURBOT'), \n  verbose     = TRUE\n  )\n\n# Добавляем обработчики\nwebhook <- webhook + CommandHandler(\"get_cur_rate\", get_cur_rate, pass_args = T)\n\n# Запускаем Webhook\nwebhook$start_server(\n  host = \"0.0.0.0\",\n  port = 8080\n)"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"собираем-docker-образ","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.5 Собираем Docker образ","text":"Для сборки нужного Docker образа мы прописываем следующий Dockerfile:На данном этапе этапе мы ещё не знаем URL нашего сервиса, поэтому в переменную WEBHOOK_URL пока что прописываем совершенно любой URL, можно даже не работающий. На второй итерации развёртки мы будем заменять значение этой переменной.Далее выполним локальную сборку образа, и тестовый локальный запуск контейнера.Если контейнер был успешно запущен на этом этапе в консоли вы увидите примерно такое сообщение:Это говорит о том, что контейнер был успешно запущен. Теперь перейдите в Docker и остановите этот контейнер, ваш бот на этом этапе отвечать на запросы не будет.","code":"# Use the official R base image\nFROM rocker/r-ver:4.1.0\n\n# Set the shell\nSHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-e\", \"-u\", \"-x\", \"-c\"]\n\n# Install necessary system dependencies\nUSER root\nRUN apt-get update && apt-get install -y \\\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install necessary R packages\nRUN R -e \"install.packages(c('httr', 'jsonlite'))\"\nRUN R -e \"install.packages('telegram.bot', repos = 'http://cran.us.r-project.org')\"\n\nENV EXCHANGERATE_API_KEY=[ВАШ КЛЮЧ В exchangerate-api.com]\nENV R_TELEGRAM_BOT_CURBOT=[ТОКЕН ВАШЕГО БОТА]\nENV WEBHOOK_URL=https://my-service.a.run.app/webhook\n\n# Copy the R script to the container\nCOPY curbot.R /app/curbot.R\n\n# Set the working directory\nWORKDIR /app\n\n# Run the R script\nCMD [\"Rscript\", \"/app/curbot.R\"]docker build -t [IMAGE NAME] .\ndocker run --name [CONTAINER NAME] --rm [IMAGE NAME]Starting webhook server...\nListening on '0.0.0.0:8080'...\nConfiguring webhook 'https://currency-bot-xxxxxxxx-ew.a.run.app'...\nWaiting for requests..."},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"создание-и-настройка-проекта-в-google-cloud","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.6 Создание и настройка проекта в Google Cloud","text":"Переходим в Google Cloud ConsoleС помощью выпадающего меню в верхнем левом углу экрана создаём новый проектПереходим в созданный проектВключаем в проекте необходимые API сервисы, в левом меню:\nCloud Run Admin API\nArtifact Registry API\nCloud Run Admin APIArtifact Registry APIВключить данные API можно будет и с помощью Google Cloud SDK на следующем шаге.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"инициализация-google-cloud-sdk-и-настройка-docker","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.7 Инициализация Google Cloud SDK и настройка Docker","text":"Так же как и в разделе Как настроить запуск скрипта по рассписанию с помощью Google Cloude Run Job перед тем как что либо публиковать в Google Cloud нам необходимо там авторизоваться, и настроить Docker на работу с Google Cloud Platform, делается это двумя командами.Далее запуститься процесс инициализации, просто следуйте инструкциям, вам необходимо будет пройти авторизацию через браузер, выбрать нужный проект, и указать регион по умолчанию.Далее необходимо настроить Docker для работы с Google Cloud.Если а прошлом шаге вы пропустили процесс активации необходимых API в вашем Google Cloud проекте, то на даном этапе вы можете это сделать прямо из Google Cloud SDK Shell:","code":"gcloud initgcloud auth configure-dockergcloud services enable run.googleapis.com\ngcloud services enable artifactregistry.googleapis.com"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"отправка-docker-образа-в-google-cloud-и-первый-запуск-бота","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.8 Отправка Docker образа в Google Cloud и первый запуск бота","text":"После успешного локального тестирования мы можем тегировать и отправить наш Docker образ в Google Artifact Registry, для этого выполним следующие команды.Теперь пришло время первого запуска бота, выполняем следующую команду.В случае успешного запуска в консоли вы увидите подобное сообщение:Наш бот по прежнему не реагирует на сообщения, поскольку у него прописан неверный webhook URL. На данном этапе нам необходим было просто получить из Google Cloud Service URL нашего бота, который вы можете найти в последней строке сообщения, которое получили после успешного запуска сервиса. Останавливаем бота и копируем это URL, он нам понадобится на следующем шаге.","code":"docker tag curbot gcr.io/[PROJECT ID]/[IMAGE NAME]\ndocker push gcr.io/[PROJECT ID]/[IMAGE NAME]gcloud run deploy [SERVICE NAME] --image gcr.io/[PROJECT ID]/[IMAGE NAME] --platform managed --allow-unauthenticatedDeploying container to Cloud Run service [SERVICE NAME] in project [PROJECT ID] region [africa-south1]\nOK Deploying new service... Done.\nOK Creating Revision...\nOK Routing traffic...\nOK Setting IAM Policy...\nDone.\nService [SERVICE NAME] revision [currency-tg-bot-00001-6r2] has been deployed and is serving 100 percent of traffic.\nService URL: https://currency-tg-bot-lmgsq7kjta-bq.a.run.appgcloud run services delete [SERVICE NAME] --platform managed"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"прописываем-правильный-webhook-url-и-перезапускаем-бота","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.1.4.9 Прописываем правильный Webhook URL и перезапускаем бота","text":"Итак, теперь у нас есть Service URL, полученный на прошлом шагу, в моём примере это https://currency-tg-bot-lmgsq7kjta-bq..run.app, для того, что бы из этого URL дслеать рабоичй Webhook URL достаточно просто добавить /webhook. Т.е. редактируем значение переменной WEBHOOK_URL в нашем Dickorfie:Теперь необходимо локально пересобрать образ, протегировать его, отправить новую версию образа в Google Cloud и запустить на его основе сервис.Если всё прошло успешно вы вновь получите примерно следующее сообщение:поздравляю, теперь ваш ботразвёрнут на Google Cloud Run Service, и готов к использованию:","code":"# Use the official R base image\nFROM rocker/r-ver:4.1.0\n\n# Set the shell\nSHELL [\"/bin/bash\", \"-o\", \"pipefail\", \"-e\", \"-u\", \"-x\", \"-c\"]\n\n# Install necessary system dependencies\nUSER root\nRUN apt-get update && apt-get install -y \\\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install necessary R packages\nRUN R -e \"install.packages(c('httr', 'jsonlite', 'httpuv'))\"\nRUN R -e \"install.packages('telegram.bot', repos = 'http://cran.us.r-project.org')\"\n\nENV EXCHANGERATE_API_KEY=[ВАШ КЛЮЧ В exchangerate-api.com]\nENV R_TELEGRAM_BOT_CURBOT=[ТОКЕН ВАШЕГО БОТА]\nENV WEBHOOK_URL=https://currency-tg-bot-lmgsq7kjta-bq.a.run.app/webhook\n\n# Copy the R script to the container\nCOPY curbot.R /app/curbot.R\n\n# Set the working directory\nWORKDIR /app\n\n# Run the R script\nCMD [\"Rscript\", \"/app/curbot.R\"]docker build -t [IMAGE NAME] .\ndocker tag curbot gcr.io/[PROJECT ID]/[IMAGE NAME]\ndocker push gcr.io/[PROJECT ID]/[IMAGE NAME]\ngcloud run deploy [SERVICE NAME] --image gcr.io/[PROJECT ID]/[IMAGE NAME] --platform managed --allow-unauthenticatedDeploying container to Cloud Run service [currency-tg-bot] in project [curbot-430507] region [africa-south1]\nOK Deploying new service... Done.\nOK Creating Revision...\nOK Routing traffic...\nOK Setting IAM Policy...\nDone.\nService [currency-tg-bot] revision [currency-tg-bot-00001-kqg] has been deployed and is serving 100 percent of traffic.\nService URL: https://currency-tg-bot-lmgsq7kjta-bq.a.run.app"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"heroku","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2 Heroku","text":"Heroku — это облачный сервис, который помогает разрабатывать, развертывать и управлять веб-приложениями без необходимости заниматься настройкой серверов и инфраструктуры. Вы просто пишете код вашего приложения и отправляете его в Heroku, а система автоматически обрабатывает его развертывание, масштабирование и управление.Heroku поддерживает разные языки программирования, такие как Ruby, Node.js, Python и в том числе R Она делает процесс разработки проще за счет автоматического развертывания из систем контроля версий (например, Git), управления конфигурацией через переменные среды и возможности добавления различных сервисов, таких как базы данных, через аддоны. Это позволяет разработчикам сосредоточиться на создании функционала, не тратя время на управление серверной инфраструктурой.Эта платформа подойдёт тем, кто не хочет заморачиваться с Docker, т.к. Heroku имеет специальные buildpacks для различных языков и сред. Для R-скриптов можно использовать buildpack для R, например heroku-buildpack-r. В этом случае вы просто загружаете ваш код и указываете необходимые зависимости в файлах, таких как init.R и Procfile.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"разворачиваем-telegram-бота-на-heroku","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1 Разворачиваем telegram бота на Heroku","text":"","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"видео-2","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.1 Видео","text":"","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"обзор-рабочего-процесса-2","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.2 Обзор рабочего процесса","text":"Рабочий процесс по развёртыванию ваших ботов на платформе Heroku выглядит следующим образом.Напишите код вашего бота.Добавьте в проект остальные необходимые файлы такие как: Procfile, init.R, app.json.Зарегистрируйтесь на Heroku.Скачайте и установите утилиту Heroku CLI.Далее вся работа происходит в командной строке, для начала необходимо авторизоваться.Перейдите в папку вашего проекта и инициализируйте новый репозиторий Git.Создайте коммит со всеми изменениями.Добавьте изменения в рабочем каталоге в индекс (или stage area), чтобы они были включены в следующий коммит.Создайте новое приложение в Heroku.Запросите информацию о вашем приложение, что бы получить его URL.Создайте в приложении все необходимые перменные среды.Установите нужный buildpack для вашего приложения.Отправьте созданный ранее коммит на сервер Heroku и разверните приложение.Запустите рабочий процесс приложения.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"файлы-необходимые-для-разворачиваня-бота","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.3 Файлы необходимые для разворачиваня бота","text":"Для того, что бы Heroku понял, что ваш бот написан на языке R проекте должен присутствовать хотя бы один из ниже перечисленных файлов:init.Rpackrat/init/Rrenv/activate.Rrun.Rapp.Rplumber.RФайлы app.R и plumber.R характерны соответвенно для Shiny приложений, и API написанных с помощью пакета Plumber. В нашем случае нам пондобятся следующие файлы в проекте бота:bot.R - код самого ботаProcfile - Описание процесса, который будет запускаться в нашем приложении.init.R - Описание зависимостей, т.е. пакетов, которые необходимо установить для работы кода нашего бота, так же вы можете использовать более продвинутые техники управления зависимостями (пакеты pacrat или renv).app.json (опционально) - Используется для автоматизации процесса развертывания и описания приложения в рамках Heroku.Мы будем разворачивать того же бота, что и в предыдущем разделе, его код выглядит следующим образом:Единственное отличае от кода бота приведённого в прошлом разделе это то, что порт мы получаем из переменной среды Sys.getenv(\"PORT\", 8080). Т.к. Heroku назначит случайный порт для вашего приложения, а Google Cloud всегда назначает вашему боту порт 8080.Procfile используется Heroku для определения процесса, который будет запущен для вашего приложения. Это специальный файл, который указывает, какие команды нужно выполнять при запуске приложения.web — это тип процесса. Для веб-приложений на Heroku это обычно web, и Heroku ожидает, что этот процесс будет слушать входящие HTTP-запросы.R --file=bot.R — это команда, которая будет запущена Heroku для старта вашего приложения. Она указывает на то, что нужно выполнить скрипт из файла bot.R.Файл init.R используется для установки пакетов R по мере необходимости.ПРИМЕЧАНИЕ: Использование Packrat или renv — лучший способ управления зависимостями пакетов и их соответствующими версиями, поэтому этот init.Rфайл не требуется, если вы используете packratили renv.Я использую следующий пример init.R файла:Вспомогательная функция helpers.installPackages, упрощающая установку пакетов, включена в buildpack для удобства.Файл app.json используется для автоматизации процесса развертывания и описания приложения в рамках Heroku. Это полезно для использования с Heroku Review Apps и автоматическим развертыванием.Что это означает:“name” — имя вашего приложения на Heroku.“description” — краткое описание приложения.“repository” — ссылка на репозиторий с вашим кодом.“logo” — URL к логотипу вашего приложения.“keywords” — ключевые слова для поиска вашего приложения.“env” — переменные окружения, которые требуется установить для вашего приложения (например, токен для Telegram API и URL вебхука).“buildpacks” — список buildpacks, которые будут использоваться для развертывания. Здесь указан buildpack для R.","code":"\nlibrary(telegram.bot)\nlibrary(httr)\nlibrary(jsonlite)\n\n# Метод запроса курса валют\nget_cur_rate <- function(bot, update, args) {\n  \n  currency_code <- toupper(args)\n  api_key <- Sys.getenv('EXCHANGERATE_API_KEY')\n  url     <- paste0(\"https://api.exchangerate-api.com/v4/latest/USD?apikey=\", api_key)\n  \n  response <- GET(url)\n  data <- fromJSON(content(response, \"text\"))\n  \n  if (!currency_code %in% names(data$rates)) {\n    bot$sendMessage(chat_id = update$message$chat_id, text = paste0(args, \" is Invalid currency code.\"))\n    return(NULL)\n  }\n  \n  rate <- data$rates[[currency_code]]\n  message <- sprintf(\"Курс %s к USD: %f\", currency_code, rate)\n  bot$sendMessage(chat_id = update$message$chat_id, text = message)\n  \n}\n\n# Создаём Webhook\nwebhook <- Webhook(\n  webhook_url = Sys.getenv('WEBHOOK_URL'), \n  token       = bot_token('CURBOT'), \n  verbose     = TRUE\n  )\n\n# Добавляем обработчики\nwebhook <- webhook + CommandHandler(\"get_cur_rate\", get_cur_rate, pass_args = T)\n\n# Запускаем Webhook\nwebhook$start_server(\n  host = \"0.0.0.0\",\n  port = as.integer(Sys.getenv(\"PORT\", 8080))\n)web: R --file=bot.R\nhelpers.installPackages(\"httr\", \"jsonlite\", \"telegram.bot\", \"stringr\"){\n  \"name\": \"telegram-bot\",\n  \"description\": \"A Telegram bot deployed on Heroku\",\n  \"repository\": \"https://github.com/your-repo/your-bot-repo\",\n  \"logo\": \"https://example.com/logo.png\",\n  \"keywords\": [\"telegram\", \"bot\"],\n  \"env\": {\n    \"R_TELEGRAM_BOT_CURBOT\": {\n      \"description\": \"Telegram Bot Token\",\n      \"required\": true\n    },\n    \"EXCHANGERATE_API_KEY\": {\n      \"description\": \"Exchangerate api key\",\n      \"required\": true\n    },\n    \"WEBHOOK_URL\": {\n      \"description\": \"Webhook URL\",\n      \"required\": true\n    }\n  },\n  \"buildpacks\": [\n    {\n      \"url\": \"https://github.com/virtualstaticvoid/heroku-buildpack-r.git\"\n    }\n  ]\n}"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"авторизация-и-инициализация-git-репозитория","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.4 Авторизация и инициализация Git репозитория","text":"Далее для авторизации в командной строке выполняем команду:После чего необходимо инициализировать новый репозиторий, добавить все изменения и создать коммит.git init - Эта команда инициализирует новый репозиторий Git в текущей директории. Она создаёт скрытую папку .git, которая содержит всю информацию о версии и конфигурации вашего репозитория. После выполнения этой команды текущая директория становится рабочим репозиторием Git, в котором вы можете отслеживать изменения файлов и выполнять другие операции управления версиями.git add . - Команда git add добавляет изменения в рабочем каталоге в индекс (или stage area), чтобы они были включены в следующий коммит. Аргумент . указывает, что нужно добавить все изменения во всех файлах текущей директории и её поддиректориях. Это делает все текущие изменения подготовленными для следующего коммита.git commit -m \"Initial commit\" - Эта команда создает новый коммит в репозитории, включающий все изменения, добавленные в индекс с помощью git add. Флаг -m позволяет указать сообщение коммита прямо в командной строке. Сообщение “Initial commit” — это описание того, что делает этот коммит. Обычно первое сообщение коммита описывает начальную настройку репозитория или первые изменения в проекте.","code":"heroku logingit init\ngit add .\ngit commit -m \"Initial commit\""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"создаём-новое-приложение-и-запраиваем-его-url","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.5 Создаём новое приложение и запраиваем его URL","text":"Следующая команда создаст в вашем аккаунте Heroku новое приложение:Замените -app-name на название вашего приложения.Теперь запросим информацию о приложении, для того что бы получить его URL:В результате вы получите следующую информацию:Из всей этой информации нам понадобится только Web URL, т.к. добавив к его пути webhook, мы получим тот WEBHOOK URL, который нам необходимо будет установить для нашего бота.","code":"heroku create your-app-nameheroku apps:info=== your-app-name\n\nAuto Cert Mgmt: false\nDynos:          web: 1\nGit URL:        https://git.heroku.com/your-app-name.git\nOwner:          your@gmail.com\nRegion:         us\nRepo Size:      19 KB\nSlug Size:      149 MB\nStack:          heroku-22\nWeb URL:        https://your-app-name-abcdefgh.herokuapp.com/"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"добавляем-переменные-среды","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.6 Добавляем переменные среды","text":"В коде нашего бота мы используем 3 переменные среды:EXCHANGERATE_API_KEY - API Ключ, который вам необходимо получить на сайте exchangerate-api.comR_TELEGRAM_BOT_CURBOT - API Token вашего бота, получить его можно при создании бота через BotFatherWEBHOOK_URL - Webhook URL на который telegram будет присылать обновления для бота, берём значение из Web URL нашего приложения, и добавляем webhook, в нашем примере https://-app-name-abcdefgh.herokuapp.com/webhook.Теперь с помощью командной строки создадим эти переменные в приложении:","code":"heroku config:set R_TELEGRAM_BOT_CURBOT=ТОКЕН ВАШЕГО БОТА\nheroku config:set WEBHOOK_URL=https://your-app-name-abcdefgh.herokuapp.com/webhook\nheroku config:set EXCHANGERATE_API_KEY=Exchangerate API Ключ"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"установка-buildpack","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.7 Установка buildpack","text":"Buildpack — это инструмент, который автоматически устанавливает и настраивает необходимые зависимости для вашего приложения. Он помогает платформе как определить, как собрать и запустить ваше приложение.Вот основные моменты, зачем и как он используется:Автоматическая настройка среды: Buildpack управляет установкой всех необходимых зависимостей и инструментов, таких как языковые среды (например, Ruby, Python, Node.js), библиотеки и фреймворки. Он автоматически настраивает среду, в которой будет работать ваше приложение, чтобы не нужно было вручную управлять этими процессами.Определение процесса сборки: Buildpack предоставляет инструкции о том, как собрать ваше приложение. Например, он может определить, какие команды нужно выполнить для установки зависимостей или как собрать исходный код.Упрощение развертывания: С помощью buildpack процесс развертывания становится проще и более автоматизированным. Вы можете просто загрузить свой код, и buildpack позаботится обо всех необходимых шагах для подготовки и запуска приложения.Поддержка различных языков и фреймворков: Разные buildpack могут поддерживать разные языки программирования и фреймворки. Например, есть отдельные buildpack для Java, Python, R и других языков.Для использования buildpack в Heroku, вы указываете его при создании или настройке приложения. Например, если вы развертываете приложение на языке R, вам нужен соответствующий buildpack, который знает, как установить R и необходимые пакеты.Пример использования buildpack в Heroku:Установка buildpack: Команда heroku buildpacks:set https://github.com/virtualstaticvoid/heroku-buildpack-r.git устанавливает buildpack для языка R.\n( Автоматическая установка зависимостей: При развертывании Heroku использует buildpack для установки R, необходимых библиотек и фреймворков, а затем собирает и запускает ваше приложение.Таким образом, buildpack упрощает процесс развертывания, автоматизируя установку и настройку среды для вашего приложения.Для установки нужного для языка R buildpack используйте следующую команду:","code":"heroku buildpacks:set https://github.com/virtualstaticvoid/heroku-buildpack-r.git"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"отправка-данных-в-heroku-и-запуск-бота","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.8 Отправка данных в Heroku и запуск бота","text":"Последним шагом необзодимо отправить все изменения в Heroku и запустить рабочий процесс, делается жто следующими командами:Команда git push heroku master: Эта команда отправляет ваши файлы проекта на сервер Heroku и разворачивает приложение.\nОна обновляет код вашего приложения в Heroku и выполняет установку зависимостей, но не запускает процесс приложения.\nПосле выполнения этой команды ваше приложение будет развернуто на Heroku, но может еще не быть активным или не обрабатывать запросы, если не настроены нужные процессы.Команда git push heroku master: Эта команда отправляет ваши файлы проекта на сервер Heroku и разворачивает приложение.\nОна обновляет код вашего приложения в Heroku и выполняет установку зависимостей, но не запускает процесс приложения.\nПосле выполнения этой команды ваше приложение будет развернуто на Heroku, но может еще не быть активным или не обрабатывать запросы, если не настроены нужные процессы.Команда heroku ps:scale web=1: Эта команда запускает веб-процесс для вашего приложения.\nОна указывает Heroku, что нужно запустить один экземпляр веб-процесса, который будет слушать входящие HTTP-запросы.\nПосле выполнения этой команды ваш бот начнет принимать запросы и будет отвечать на них, если всё настроено правильно.Команда heroku ps:scale web=1: Эта команда запускает веб-процесс для вашего приложения.\nОна указывает Heroku, что нужно запустить один экземпляр веб-процесса, который будет слушать входящие HTTP-запросы.\nПосле выполнения этой команды ваш бот начнет принимать запросы и будет отвечать на них, если всё настроено правильно.Таким образом, после git push heroku master ваше приложение будет развернуто, но вам нужно выполнить heroku ps:scale web=1, чтобы запустить его и начать обработку запросов.Всё, ваш бот развёрнут на Heroku!","code":"git push heroku master\nheroku ps:scale web=1"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"переключение-между-разными-приложениями","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.9 Переключение между разными приложениями","text":"В heroku у вас могут быть созданы несколько приложений, если вам необходимо будет переключаться между ними, то можете воспользоваться следующими командами:heroku apps - Эта команда покажет все ваши приложения в Heroku.heroku git:remote -<app_name> - Для переключения между приложениями.В некоторых командах можно указать имя приложения, используя флаг -:heroku ps -<app_name>heroku logs --tail -<app_name>heroku ps:scale web=1 -<app_name>heroku config:set VAR_NAME=value -<app_name>","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"другие-полезные-команды-heroku-cli","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.1.10 Другие полезные команды Heroku cli","text":"Вот ещё несколько полезных команд, доступных в Heroku CLI:heroku ps - отображения текущего состояния процессов (dynos) вашего приложенияheroku config - просмотр переменныхheroku apps:info - получить инфу о приложении, включая его urlheroku logs --tail - покажет логи выполнения R скрипта","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"как-настроить-запуск-r-скрипта-по-расписанию-в-heroku","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.2 Как настроить запуск R скрипта по расписанию в Heroku","text":"На предыдущем шаге мы развернули в Heroku полноценного бота, но возможно вам необходимо просто настроить отправку какого либо сообщение в telegtam по расписанию. Алгоритм очень похож с развёртыванием бота, но всё таки он немного упрощён.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"подготовка-проекта","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.2.1 Подготовка проекта","text":"Мы будем разворачивать тот же скрипт, отправляющий курсы валют, который рассматривали в разеделе Как настроить запуск скрипта по рассписанию с помощью Google Cloude Run Job:Файл init.R:Файл script.R:","code":"\nhelpers.installPackages(\"httr\", \"jsonlite\", \"telegram.bot\", \"stringr\")\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(telegram.bot)\nlibrary(stringr)\n\nget_exchange_rate <- function(api_key) {\n  url <- paste0(\"https://api.exchangerate-api.com/v4/latest/USD?apikey=\", api_key)\n  response <- GET(url)\n  data <- fromJSON(content(response, \"text\"))\n  return(data)\n}\n\nsend_telegram_message <- function(bot_token, chat_id, message) {\n  bot <- Bot(token = bot_token)\n  bot$sendMessage(chat_id = chat_id, text = message)\n}\n\n# Функция для выполнения основного логики\nexecute_script <- function() {\n  api_key   <- Sys.getenv(\"EXCHANGE_RATE_API_KEY\")\n  bot_token <- Sys.getenv(\"TELEGRAM_BOT_TOKEN\")\n  chat_id   <- Sys.getenv(\"TELEGRAM_CHAT_ID\")\n  \n  exchange_rate <- get_exchange_rate(api_key)\n  message <- str_glue(\n    \"Курс валют на {Sys.Date()}\",\n    '-----------------------------',\n    \"Курс EUR к USD: {exchange_rate$rates$EUR}\", \n    \"Курс GBP к USD: {exchange_rate$rates$GBP}\",\n    \"Курс UAH к USD: {exchange_rate$rates$UAH}\",\n    \"Курс EGP к USD: {exchange_rate$rates$EGP}\", \n    .sep = '\\n'\n  )\n  \n  send_telegram_message(bot_token, chat_id, message)\n}\n\n# Выполнение скрипта\nexecute_script()"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"обзор-рабочего-процесса-3","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.2.2.2 Обзор рабочего процесса","text":"В вашем приложение достаточно двух файлов:\ninit.R с описанием зависимосте.\nscript.R, ну или любой файл с R кодом, который вам необходимо запускать по расписанию.\ninit.R с описанием зависимосте.script.R, ну или любой файл с R кодом, который вам необходимо запускать по расписанию.Залогиньтесь в Heroku, и подготовьте коммит:Создайте приложениеСоздайте все необходимые переменные среды:Устновите нужный buildpack:Запушьте приложениеПерейдите в web версию Heroku, зайдите в созданное приложение, перейдите на вкладку Resources? и добавьте Add-“Heroku Scheduler”, есть и другие дополнения, которые позволяют настраивать расписание запуска ваших скриптов, но они платные:Перейдите в дополннеие “Heroku Scheduler” и нажмите “Create job”Настройте расписание запуска, и укажите команду Rscript script.R:Возможности настройки расписания в дополнении “Heroku Scheduler” довольно примитывные, но можно настроить запуск каждый 10 минут, каждый час в определённую минуту, или каждый день в определённое время.","code":"heroku login\n\ngit init\ngit add .\ngit commit -m \"Initial commit\"heroku create app-nameheroku config:set EXCHANGE_RATE_API_KEY=<ВАШ КЛЮЧ К exchange-rate-api>\nheroku config:set TELEGRAM_BOT_TOKEN=<ТОКЕН ВАШЕГО БОТА>\nheroku config:set TELEGRAM_CHAT_ID=<ID чата в который будете отправлять курсы валют>heroku buildpacks:set https://github.com/virtualstaticvoid/heroku-buildpack-r.gitgit push heroku master"},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"какую-из-описанных-облачных-платформ-выбрать","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.3 Какую из описанных облачных платформ выбрать","text":"Развёртывание бота на Heroku и Google Cloud Run имеет свои особенности и преимущества, в зависимости от ваших требований и предпочтений. Вот некоторые ключевые моменты, которые могут помочь вам определиться:","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"преимущества-heroku","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.3.1 Преимущества Heroku","text":"Простота и удобство использования:\nИнтуитивный интерфейс: Heroku предлагает простой в использовании интерфейс и инструменты командной строки, которые облегчают развертывание и управление приложениями.\nАвтоматическое масштабирование: Heroku автоматически масштабирует ваше приложение в зависимости от нагрузки, и вам не нужно заботиться о настройке серверов.\nИнтуитивный интерфейс: Heroku предлагает простой в использовании интерфейс и инструменты командной строки, которые облегчают развертывание и управление приложениями.Автоматическое масштабирование: Heroku автоматически масштабирует ваше приложение в зависимости от нагрузки, и вам не нужно заботиться о настройке серверов.Широкий выбор buildpack и добавок:\nBuildpacks: Heroku поддерживает различные языковые среды через buildpacks, что упрощает настройку среды для вашего приложения.\nДополнения: В магазине расширений Heroku можно найти множество сервисов для мониторинга, баз данных, очередей и других нужд.\nBuildpacks: Heroku поддерживает различные языковые среды через buildpacks, что упрощает настройку среды для вашего приложения.Дополнения: В магазине расширений Heroku можно найти множество сервисов для мониторинга, баз данных, очередей и других нужд.Автоматическое управление зависимостями:\nЛегкость в управлении: Heroku автоматически управляет зависимостями и настройками окружения, что упрощает развертывание.\nЛегкость в управлении: Heroku автоматически управляет зависимостями и настройками окружения, что упрощает развертывание.Встроенные инструменты для мониторинга и логирования:\nЛоги и мониторинг: Heroku предоставляет встроенные инструменты для мониторинга и сбора логов, что помогает отслеживать состояние вашего приложения.\nЛоги и мониторинг: Heroku предоставляет встроенные инструменты для мониторинга и сбора логов, что помогает отслеживать состояние вашего приложения.Интеграция с Git:\nGit-процесс: Простая интеграция с Git позволяет использовать стандартные git-команды для развертывания и обновления приложений.\nGit-процесс: Простая интеграция с Git позволяет использовать стандартные git-команды для развертывания и обновления приложений.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"преимущества-google-cloud-run","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.3.2 Преимущества Google Cloud Run","text":"Масштабируемость и гибкость:\nМасштабируемость: Google Cloud Run автоматически масштабирует ваше приложение в зависимости от входящих запросов и может обрабатывать трафик от нуля до тысяч запросов в секунду.\nГибкость: Поддержка контейнеров позволяет вам использовать любой язык программирования и фреймворк, который вы хотите.\nМасштабируемость: Google Cloud Run автоматически масштабирует ваше приложение в зависимости от входящих запросов и может обрабатывать трафик от нуля до тысяч запросов в секунду.Гибкость: Поддержка контейнеров позволяет вам использовать любой язык программирования и фреймворк, который вы хотите.Полный контроль над окружением:\nКонтейнеры: Вы можете использовать Docker-контейнеры, что дает вам полный контроль над средой выполнения вашего приложения, включая версии зависимостей и настройки.\nКонтейнеры: Вы можете использовать Docker-контейнеры, что дает вам полный контроль над средой выполнения вашего приложения, включая версии зависимостей и настройки.Интеграция с другими сервисами Google Cloud:\nБогатая экосистема: Cloud Run легко интегрируется с другими сервисами Google Cloud, такими как Cloud SQL, Pub/Sub и Cloud Storage.\nБогатая экосистема: Cloud Run легко интегрируется с другими сервисами Google Cloud, такими как Cloud SQL, Pub/Sub и Cloud Storage.Биллинг по запросам:\nОплата за использование: Вы оплачиваете только фактическое время работы вашего приложения и количество обработанных запросов, что может быть более экономичным при низкой активности.\nОплата за использование: Вы оплачиваете только фактическое время работы вашего приложения и количество обработанных запросов, что может быть более экономичным при низкой активности.Быстрое развертывание и обновление:\nКонтейнеры: С использованием контейнеров вы можете быстро развернуть и обновить приложение, что упрощает управление версиями и деплой.\nКонтейнеры: С использованием контейнеров вы можете быстро развернуть и обновить приложение, что упрощает управление версиями и деплой.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"итог","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.3.3 Итог","text":"Heroku лучше подходит для разработчиков, которые ищут простоту и удобство в развертывании, особенно если вы используете стандартные языки программирования и фреймворки, поддерживаемые Heroku. Он хорош для быстрого старта и имеет много встроенных функций и добавок.Google Cloud Run предоставит больше гибкости и масштабируемости, особенно если вам нужен полный контроль над средой выполнения или если ваше приложение должно работать в контейнерах. Это хороший выбор для масштабируемых приложений с высокой нагрузкой.Выбор между Heroku и Google Cloud Run зависит от ваших требований к проекту и предпочтений в управлении приложением.","code":""},{"path":"разворачиваем-бота-в-облачных-сервисах.html","id":"заключение-8","chapter":"Глава 9 Разворачиваем бота в облачных сервисах","heading":"9.4 Заключение","text":"Поздравляю с завершением последней главы! Вы успешно развернули своего бота на Google Cloud Run и готовы к его масштабированию и поддержке в облаке. Надеюсь, вы получили все необходимые знания и навыки для успешного управления и развития вашего бота. Спасибо за участие в этом путешествии, и я надеюсь, что вы продолжите развиваться в мире разработки и анализа данных.","code":""},{"path":"заключение-9.html","id":"заключение-9","chapter":"Заключение","heading":"Заключение","text":"Поздравляю вас с завершением нашего путешествия в мир разработки Telegram-ботов с использованием языка R! Мы прошли через все этапы создания и настройки бота, от самых основ до сложных аспектов развертывания и масштабирования. Надеюсь, что вы нашли эту книгу полезной и вдохновляющей, и теперь обладаете всеми необходимыми знаниями для создания и управления собственными ботами.В ходе этой книги мы:Создали и настроили вашего первого бота: Вы узнали, как использовать API Telegram для запуска простого бота, который может взаимодействовать с пользователями и выполнять базовые функции.Добавили команды и фильтры: Мы рассмотрели, как настраивать команды для управления ботом и фильтры для обработки сообщений, чтобы бот мог эффективно выполнять задачи.Настроили клавиатуры: Вы изучили, как интегрировать reply и inline клавиатуры для создания интерактивных элементов, которые облегчают взаимодействие с пользователями.Построили диалоги: Мы разобрали методы создания сложных последовательностей диалогов для более естественного общения и улучшения понимания запросов пользователей.Управляли правами пользователей: Вы узнали, как настраивать права доступа для различных пользователей, обеспечивая безопасность и контроль над взаимодействием с вашим ботом.Повысили стабильность: Мы обсудили методы повышения надежности бота, включая обработку ошибок и оптимизацию производительности.Внедрили асинхронные операции: Вы научились использовать асинхронность для повышения производительности и масштабируемости вашего бота.Упаковали бота в Docker: Мы рассмотрели, как создать Docker-контейнер для удобного развертывания и управления окружением бота.Развернули бота на Google Cloud Run: В завершение, мы изучили, как развернуть бота на облачной платформе для обеспечения его масштабируемости и доступности.Теперь, когда вы освоили все эти аспекты, у вас есть отличная база для создания и управления Telegram-ботами, которые могут выполнять сложные задачи и взаимодействовать с пользователями на высоком уровне. Ваши знания и навыки позволят вам разрабатывать ботов для различных целей, от простых автоматизаций до сложных интерактивных решений.Не забывайте, что процесс разработки не заканчивается на развертывании. Постоянное совершенствование, тестирование и обновление — важные части успешного проекта. Надеюсь, что вы продолжите исследовать новые возможности и применять полученные знания для создания ещё более мощных и эффективных решений.Если вам понравилась эта книга, я буду рад, если вы подпишетесь на мой Telegram и YouTube каналы R4marketing. На них я делюсь множеством полезных материалов по разработке и анализу данных на языке R, которые помогут вам дальше развиваться в этой области.Кроме того, вы можете быть заинтересованы в других моих курсах, таких как:Язык R для пользователей Excel.Введение в dplyr 1.0.0.Циклы и функционалы в языке R.Разработка пакетов на языке R.Язык R для интернет-маркетинга.Спасибо, что выбрали эту книгу в качестве своего учебного пособия. Желаю вам удачи в ваших будущих проектах и не прекращайте учиться и развиваться в мире технологий!\n","code":""},{"path":"обновления.html","id":"обновления","chapter":"Обновления","heading":"Обновления","text":"","code":""},{"path":"обновления.html","id":"section","chapter":"Обновления","heading":"2024-08-28","text":"Добавлена новая глава Разворачиваем бота в облачных сервисах.","code":""},{"path":"обновления.html","id":"section-1","chapter":"Обновления","heading":"2024-08-02","text":"У книги новая обложка.В главу Создаём бота, и отправляем с его помощью сообщения в telegram добавлен раздел Настраиваем запуск расписания отправки сообщения с помощью GitHub Actions.Во вторую главу Добавляем боту поддержку команд и фильтры сообщений, класс Updater добавлен раздел Обработка голосовых сообщений. Переводим голосовое сообщение в текст. В которой приведён пример бота, который преобразует голосовые сообщения в текст.Во вторую главу Добавляем боту поддержку команд и фильтры сообщений, класс Updater добавлен раздел Бот для сбора статистики из Telegram чатов.К книге добавлено предисловие и заключение.В каждой главе переписаны предисловие и заключение.","code":""},{"path":"обновления.html","id":"section-2","chapter":"Обновления","heading":"2023-02-08","text":"В главе “Как добавить боту поддержку клавиатуры” переписан раздел “Пример бота, который выводит список самых свежих статей со ссылками по-указанному Хабу из habr.com”. Ранее в этом разделе приводился код, в котором для парсинга информации о статьях использовался уже не актуальный пакет habR, теперь данный бот работает с RRS каналом Хабра, с помощью пакета tidyRSS.","code":""},{"path":"обновления.html","id":"section-3","chapter":"Обновления","heading":"2023-01-20","text":"В первую главу Создаём бота, и отправляем с его помощью сообщения в telegram, добавлено описание всех методов бота.Во вторую главу Добавляем боту поддержку команд и фильтры сообщений, класс Updater, добавлено описание методов обновлений.Во вторую главу Добавляем боту поддержку команд и фильтры сообщений, класс Updater, добавлена информация о том, как запросить у пользователя номер телефона или локацию.","code":""},{"path":"обновления.html","id":"section-4","chapter":"Обновления","heading":"2022-09-06","text":"Добавлена 8 глава “Упаковываем бота в Docker контейнер”.","code":""},{"path":"обновления.html","id":"section-5","chapter":"Обновления","heading":"2022-08-17","text":"Добавлена 7 глава “Добавляем боту асинхронность”.","code":""},{"path":"обновления.html","id":"section-6","chapter":"Обновления","heading":"2022-08-09","text":"Практически во все уроки добавлены видео;Учебник переведён в формат bs4;Добавлена странца обновлений курса;Все ихсходники проекта учебника залиты на github.","code":""},{"path":"решение-задач.html","id":"решение-задач","chapter":"Решение задач","heading":"Решение задач","text":"В этом разделе книги приведены решения всех, представленных в учебнике задач.","code":""},{"path":"решение-задач.html","id":"задача-1.1","chapter":"Решение задач","heading":"Задача 1.1","text":"Создайте с помощью BotFather бота.Перейдите к диалогу с ботом, и узнайте идентификатор вашего с ботом чата.Отправьте с помощью созданного бота в telegram первые 20 строк из встроенного в R набора данных ToothGrowth.Решение:","code":"\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(telegram.bot)\n\n# функция для перевода data.frame в telegram таблицу \nto_tg_table <- function( table, align = NULL, indents = 3, parse_mode = 'Markdown' ) {\n  \n  # если выравнивание не задано то выравниваем по левому краю\n  if ( is.null(align) ) {\n    \n    col_num <- length(table)\n    align   <- str_c( rep('l', col_num), collapse = '' )\n    \n  }\n  \n  # проверяем правильно ли заданно выравнивание\n  if ( length(table) != nchar(align) ) {\n    \n    align <- NULL\n    \n  }\n  \n  # новое выравнивание столбцов \n  side <- sapply(1:nchar(align), \n                 function(x) { \n                   letter <- substr(align, x, x)\n                   switch (letter,\n                           'l' = 'right',\n                           'r' = 'left',\n                           'c' = 'both',\n                           'left'\n                   )\n                 })\n  \n  # сохраняем имена\n  t_names      <- names(table)\n  \n  # вычисляем ширину столбцов\n  names_length <- sapply(t_names, nchar) \n  value_length <- sapply(table, function(x) max(nchar(as.character(x))))\n  max_length   <- ifelse(value_length > names_length, value_length, names_length)\n  \n  # подгоняем размер имён столбцов под их ширину + указанное в indents к-во пробелов \n  t_names <- mapply(str_pad, \n                    string = t_names, \n                    width  = max_length + indents, \n                    side   = side)\n  \n  # объединяем названия столбцов\n  str_names <- str_c(t_names, collapse = '')\n  \n  # аргументы для фукнции str_pad\n  rules <- list(string = table, width = max_length + indents, side = side)\n  \n  # поочереди переводим каждый столбец к нужному виду\n  t_str <-   pmap_df( rules, str_pad )%>%\n    unite(\"data\", everything(), remove = TRUE, sep = '') %>%\n    unlist(data) %>%\n    str_c(collapse = '\\n') \n  \n  # если таблица занимает более 4096 символов обрезаем её\n  if ( nchar(t_str) >= 4021 ) {\n    \n    warning('Таблица составляет более 4096 символов!')\n    t_str <- substr(t_str, 1, 4021)\n    \n  }\n  \n  # символы выделения блока кода согласно выбранной разметке\n  code_block <- switch(parse_mode, \n                       'Markdown' = c('```', '```'),\n                       'HTML' = c('<code>', '<\/code>'))\n  \n  # переводим в code\n  res <- str_c(code_block[1], str_names, t_str, code_block[2], sep = '\\n')\n  \n  return(res)\n}\n\n# создаём экземпляр бота\nbot <- Bot('1165649194:AAFkDqIzQ6Wq5GV0YU7PmEZcv1gmWIFIB_8')\n\n# получаем ID чата \n# (предварительно отправьте боту любое сообщение)\nchat_id <- bot$getUpdates()[[1]]$from_chat_id()\n\n# преоразуем таблицу ToothGrowth\nTG <- to_tg_table( head(ToothGrowth, 20) )\n\n# отправляем таблицу в Telegram\nbot$sendMessage(chat_id, \n                TG,\n                'Markdown')"},{"path":"решение-задач.html","id":"задача-2.1","chapter":"Решение задач","heading":"Задача 2.1","text":"Создайте бота, который будет по команде /sum и переданное в качестве дополнительных параметров произвольное количество перечисленных через пробел чисел, возвращать их сумму.Решение:","code":"\nlibrary(telegram.bot)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Создаём функцию, которая будет суммировать переданные числа\nsumming <- function(bot, update, args) {\n\n  # Переводим полученный вектор параметров в числа и суммируем\n  x <- sum(as.integer(args))\n\n  # создаём сообщение\n  msg <- paste0('Сумма переданных чисел: ', x)\n\n  # отправляем результат\n  bot$sendMessage(update$message$chat_id, msg, 'Markdown')\n\n}\n\n# создаём обработчик\nh_sum <- CommandHandler('sum', summing, pass_args = TRUE)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + h_sum\n\n# запускаем бота\nupdater$start_polling()"},{"path":"решение-задач.html","id":"задача-3.1","chapter":"Решение задач","heading":"Задача 3.1","text":"Создайте бота, который будет поддерживать Reply клавиатуру. На Reply клавиатуре будет всего одна кнопка “Время”. По нажатию на неё будет появляться Inline клавиатура с выбором из 6 часовых поясов.Africa/CairoAmerica/ChicagoEurope/MoscowAsia/BangkokEurope/KievAustralia/SydneyКнопки Inline клавиатуры необходимо расположить по 2 в ряд, соответвенно в три ряда.По нажатию на одну из кнопки Inline клавиатуры бот будет запрашивать информацию по текущему времени из API worldtimeapi.org.Формат запроса к API: http://worldtimeapi.org/api/timezone/{area}/:{location}.Где area это континент, например Europe, а {location} это город, например Kiev. Дату и время надо брать в ответе из компонента datetime.Решение:","code":"\nlibrary(telegram.bot)\nlibrary(httr)\nlibrary(stringr)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Запуск клавиатуры\nstart <- function(bot, update) {\n  \n  # строим Reply клавиатуру\n  RKM <- ReplyKeyboardMarkup(\n    keyboard = list(\n      list(\n        KeyboardButton('Время')\n      )\n    ))\n  \n  # отпралвяем Reply клавиатуру\n  bot$sendMessage(update$message$chat_id, \n                  'Выберите команду', \n                  'Markdown',\n                  reply_markup = RKM)\n  \n}\n\n# Отправляем inline клавиатуру\ninline <- function(bot, update) {\n  \n  IKM <- InlineKeyboardMarkup(\n              inline_keyboard = \n                list(\n                  list(\n                    InlineKeyboardButton(text = 'Africa/Cairo', callback_data = 'Africa/Cairo'),\n                    InlineKeyboardButton(text = 'America/Chicago', callback_data = 'America/Chicago')\n                  ),\n                  list(\n                    InlineKeyboardButton(text = 'Europe/Moscow', callback_data = 'Europe/Moscow'),\n                    InlineKeyboardButton(text = 'Asia/Bangkok', callback_data = 'Asia/Bangkok')\n                  ),\n                  list(\n                    InlineKeyboardButton(text = 'Europe/Kiev', callback_data = 'Europe/Kiev'),\n                    InlineKeyboardButton(text = 'Australia/Sydney', callback_data = 'Australia/Sydney')\n                  )\n                ))\n  \n  # отпралвяем Reply клавиатуру\n  bot$sendMessage(update$message$chat_id, \n                  'Выберите регион', \n                  'Markdown',\n                  reply_markup = IKM)\n  \n}\n\n# обрабатываем нажатие на кнопку\ncurtime <- function(bot, update) {\n  \n  # сообщаем боту, что запрос с кнопки принят\n  bot$answerCallbackQuery(callback_query_id = update$callback_query$id) \n  \n  # данные с кнопки\n  data <- update$callback_query$data\n  \n  # разбиваем на регион и город\n  geo <- unlist(strsplit(data, split = '/'))\n  \n  # компонуем URL\n  url <- str_glue('http://worldtimeapi.org/api/timezone/{geo[1]}/{geo[2]}')\n  \n  # запрос к API\n  answer <- GET(url)\n  \n  # парсим ответ\n  res <- content(answer)\n  \n  # создаём сообщение\n  msg <- str_glue('Текущее время в {data}: {res$datetime}')\n  \n  # отправляем сообщение\n  bot$sendMessage(update$from_chat_id(), \n                  msg, \n                  'Markdown')\n}\n\n# Фильтр для Reply клавиатуры\nMessageFilters$start <- \n  BaseFilter(\n    function(message) {\n      message$text == 'Время'\n    }\n  )\n\n# Обработчики\nh_start <- CommandHandler('start', start)\nh_time  <- MessageHandler(inline, MessageFilters$start)\nh_cb    <- CallbackQueryHandler(curtime)\n\n# Добавляем обработчики в диспетчер\nupdater <- updater + h_start + h_time + h_cb\n\n# Запускаем бота\nupdater$start_polling()"},{"path":"решение-задач.html","id":"задача-4.1","chapter":"Решение задач","heading":"Задача 4.1","text":"Постройте бота который будет поддерживать игру угадай число. Т.е. по команде /start бот будет загадывать число от 1 до 50. Далее у вас будет 5 попыток угадать это число.Вы по очереди в каждой из попыток вводите числа, если введённое число меньше чем то, которое загадал бот то бот пишет “моё число больше”, иначе бот пишет “моё число меньше”. Если вы ввели правильное число то бот пишет что вы выйграли, и переводит диалог в исходное состояние.Решение:Создаём таблицу в базе данных для хранеия числа и текущей попытки.Далее создаём функции для работы с бахой данных.Основной код бота выглядит так:","code":"CREATE TABLE chat_data (\n    chat_id BIGINT  PRIMARY KEY\n                    UNIQUE,\n    attempt    INTEGER,\n    number     INTEGER\n);\n# write chat data\n# write chat data\nset_chat_data <- function(chat_id, field, value) {\n  \n  \n  con <- dbConnect(SQLite(), db)\n  \n  # upsert состояние чата\n  dbExecute(con, \n            str_interp(\"\n            INSERT INTO chat_data (chat_id, ${field})\n                VALUES(${chat_id}, '${value}') \n                ON CONFLICT(chat_id) \n                DO UPDATE SET ${field}='${value}';\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n}\n\n# read chat data\nget_chat_data <- function(chat_id, field) {\n  \n  \n  con <- dbConnect(SQLite(), db)\n  \n  # upsert состояние чата\n  data <- dbGetQuery(con, \n                     str_interp(\"\n            SELECT ${field}\n            FROM chat_data\n            WHERE chat_id = ${chat_id};\n            \")\n  )\n  \n  dbDisconnect(con)\n  \n  return(data[[field]])\n  \n}\nlibrary(RSQLite)\nlibrary(DBI)\nlibrary(telegram.bot)\nlibrary(stringr)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# путь к базе\ndb <- \"ПУСТЬ К БАЗЕ ДАННЫХ/bot.db\"\n\nstart <- function(bot, update) {\n  \n  # бот загадывает число\n  num <- round(runif(1, 1, 50), 0)\n  \n  # записываем данные в базу о начале игры\n  set_chat_data( update$message$chat_id, 'number', num)\n  set_chat_data( update$message$chat_id, 'attempt', 1)\n  \n  # отпралвяем Reply клавиатуру\n  bot$sendMessage(update$message$chat_id, \n                  'Число загаданно, начинаем игру, ваша первая попытка.', \n                  'Markdown')\n  \n}\n\nattempt <- function(bot, update) {\n  \n  num <- get_chat_data(update$message$chat_id, 'number')\n  att <- get_chat_data(update$message$chat_id, 'attempt')\n  \n  user_num <- update$message$text\n  \n  if ( user_num < num ) {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0('Номер попытки: ', att, \". Моё число больше\"),\n                    'Markdown')\n    \n  } else if ( user_num > num ) {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0('Номер попытки: ', att, \". Моё число меньше\"),\n                    'Markdown')\n    \n  } else {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0('Номер попытки: ', att, \". Поздравляю, вы угадали число!\"),\n                    'Markdown')\n    \n    set_chat_data( update$message$chat_id, 'attempt', 0)\n    \n  }\n  \n  if ( att == 5 &  user_num != num )  {\n    \n    bot$sendMessage(update$message$chat_id, \n                    paste0(\"Вы проиграли, я загадал число \", num),\n                    'Markdown')\n    set_chat_data( update$message$chat_id, 'attempt', 0)\n    \n  }\n  \n  set_chat_data( update$message$chat_id, 'attempt', att + 1)\n  \n}\n\n\n# фильтр сообщение в состоянии ожидания имени\nMessageFilters$attempt <- BaseFilter(function(message) {\n\n  att <- get_chat_data(message$chat_id, 'attempt') \n  0 < att & att < 6\n}\n)\n\n# обработчики\nh_start   <- CommandHandler('start', start)\nh_attempt <- MessageHandler(attempt, MessageFilters$attempt & !MessageFilters$command)\n\n# диспетчер\nupdater <- updater + h_start + h_attempt\n\n# запуск\nupdater$start_polling()"},{"path":"решение-задач.html","id":"задача-5.1","chapter":"Решение задач","heading":"Задача 5.1","text":"Возьмите задачу 2.1 из второй главы, и ограничьте использование единственного метода, доступного в созданном боте, так, что бы он работал только когда его запрашиваете вы.Решение:","code":"\nlibrary(telegram.bot)\n\n# Создаём жкземпляр класса Updater\nupdater <- Updater('ТОКЕН ВАШЕГО БОТА')\n\n# Создаём функцию, которая будет суммировать переданные числа\nsumming <- function(bot, update, args) {\n  \n  if ( update$message$from$username == 'YourUsername' ) {\n\n    # Переводим полученный вектор параметров в числа и суммируем\n    x <- sum(as.integer(args))\n  \n    # создаём сообщение\n    msg <- paste0('Сумма переданных чисел: ', x)\n  \n    # отправляем результат\n    bot$sendMessage(update$message$chat_id, msg, 'Markdown')\n    \n  } else {\n    \n    # отправляем результат\n    bot$sendMessage(update$message$chat_id, \n                    'У вас не достаточно прав на использование этой функции бота!', \n                    'Markdown')\n    \n  }\n\n}\n\n# создаём обработчик\nh_sum <- CommandHandler('sum', summing, pass_args = TRUE)\n\n# добавляем обработчик в диспетчер\nupdater <- updater + h_sum\n\n# запускаем бота\nupdater$start_polling()"}]
